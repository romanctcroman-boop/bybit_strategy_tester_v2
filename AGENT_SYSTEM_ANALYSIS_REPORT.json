{
  "timestamp": "2025-11-16T22:24:51.366536",
  "health_stats": {
    "total_requests": 104,
    "mcp_success": 0,
    "mcp_failed": 51,
    "direct_api_success": 104,
    "direct_api_failed": 0
  },
  "deepseek": {
    "message_id": "f7cebd11-9188-4f27-9923-86971caeb444",
    "timestamp": "2025-11-16T19:24:51.312403",
    "content": "## ğŸ” Root Cause Analysis: MCP Integration Failure\n\nBased on my analysis of the code architecture, I've identified the **critical integration gap** causing the 0% MCP success rate.\n\n## ğŸ¯ PRIMARY ISSUE: MCP Server Architecture Mismatch\n\n### **Problem 1: MCP Server Runs in Separate Process**\n```python\n# Current Architecture (BROKEN):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ MCP Server      â”‚    â”‚ FastAPI Backend  â”‚\nâ”‚ (FastMCP STDIO) â”‚    â”‚ (Uvicorn HTTP)   â”‚\nâ”‚ port: ???       â”‚    â”‚ port: 8000       â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n     âŒ No connection between them\n```\n\n### **Problem 2: Missing MCP Tool Registration**\nThe MCP tools (`mcp_agent-to-agen_*`) are registered in the FastMCP server but **not exposed** to the FastAPI router.\n\n### **Problem 3: Incorrect HTTP Endpoint in `_try_mcp()`**\n```python\n# unified_agent_interface.py (line ~250) - WRONG:\nawait client.post(\"http://127.0.0.1:8000/mcp/tools/call\", ...)\n# âŒ This endpoint doesn't exist in FastAPI\n```\n\n---\n\n## ğŸ› ï¸ STEP-BY-STEP FIX IMPLEMENTATION\n\n### **Solution A: Integrate MCP Server into FastAPI (Recommended)**\n\nCreate `backend/mcp/mcp_integration.py`:\n\n```python\n\"\"\"\nMCP-FastAPI Integration Bridge\nFixes the 0% MCP success rate by embedding MCP tools in FastAPI\n\"\"\"\n\nimport asyncio\nfrom typing import Dict, Any, List\nfrom fastapi import APIRouter, HTTPException\nfrom loguru import logger\n\n# Import your existing MCP server components\nfrom mcp_server.server import (\n    FastMCP, \n    PluginManager, \n    HookType,\n    provider_ready,\n    MCPError\n)\n\nclass MCPFastAPIBridge:\n    \"\"\"Bridge between FastMCP server and FastAPI\"\"\"\n    \n    def __init__(self):\n        self.mcp = FastMCP(\"Bybit Strategy Tester\")\n        self.plugin_manager = None\n        self._tools_registered = False\n        \n    async def initialize(self):\n        \"\"\"Initialize MCP server and register tools with FastAPI\"\"\"\n        try:\n            # Initialize plugin system\n            self.plugin_manager = await PluginManager.initialize()\n            \n            # Register agent-to-agent tools\n            await self._register_agent_tools()\n            \n            # Mark providers as ready\n            global _providers_ready\n            _providers_ready = True\n            \n            logger.success(\"âœ… MCP-FastAPI Bridge initialized\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"âŒ MCP Bridge initialization failed: {e}\")\n            return False\n    \n    async def _register_agent_tools(self):\n        \"\"\"Register all agent-to-agent communication tools\"\"\"\n        \n        @self.mcp.tool()\n        async def mcp_agent_to_agent_send_to_deepseek(content: str, context: Dict[str, Any] = None) -> Dict[str, Any]:\n            \"\"\"Send message to DeepSeek agent via MCP\"\"\"\n            try:\n                from backend.agents.agent_to_agent_communicator import (\n                    AgentToAgentCommunicator, AgentMessage, AgentType, MessageType\n                )\n                \n                communicator = AgentToAgentCommunicator()\n                message = AgentMessage(\n                    message_id=str(uuid.uuid4()),\n                    from_agent=AgentType.COPILOT,\n                    to_agent=AgentType.DEEPSEEK,\n                    message_type=MessageType.QUERY,\n                    content=content,\n                    context=context or {},\n                    conversation_id=str(uuid.uuid4())\n                )\n                \n                response = await communicator.route_message(message)\n                \n                return {\n                    \"success\": True,\n                    \"content\": response.content,\n                    \"message_id\": response.message_id,\n                    \"from_agent\": response.from_agent.value,\n                    \"latency_ms\": response.metadata.get(\"latency_ms\", 0)\n                }\n                \n            except Exception as e:\n                logger.error(f\"MCP DeepSeek tool error: {e}\")\n                return {\"success\": False, \"error\": str(e)}\n        \n        @self.mcp.tool()\n        async def mcp_agent_to_agent_send_to_perplexity(content: str, context: Dict[str, Any] = None) -> Dict[str, Any]:\n            \"\"\"Send message to Perplexity agent via MCP\"\"\"\n            try:\n                from backend.agents.agent_to_agent_communicator import (\n                    AgentToAgentCommunicator, AgentMessage, AgentType, MessageType\n                )\n                \n                communicator = AgentToAgentCommunicator()\n                message = AgentMessage(\n                    message_id=str(uuid.uuid4()),\n                    from_agent=AgentType.COPILOT,\n                    to_agent=AgentType.PERPLEXITY,\n                    message_type=MessageType.QUERY,\n                    content=content,\n                    context=context or {},\n                    conversation_id=str(uuid.uuid4())\n                )\n                \n                response = await communicator.route_message(message)\n                \n                return {\n                    \"success\": True,\n                    \"content\": response.content,\n                    \"message_id\": response.message_id,\n                    \"from_agent\": response.from_agent.value,\n                    \"latency_ms\": response.metadata.get(\"latency_ms\", 0)\n                }\n                \n            except Exception as e:\n                logger.error(f\"MCP Perplexity tool error: {e}\")\n                return {\"success\": False, \"error\": str(e)}\n        \n        @self.mcp.tool()\n        async def mcp_agent_to_agent_get_consensus(question: str, agents: List[str] = None) -> Dict[str, Any]:\n            \"\"\"Get consensus from multiple agents via MCP\"\"\"\n            try:\n                from backend.agents.agent_to_agent_communicator import (\n                    AgentToAgentCommunicator, AgentType\n                )\n                \n                communicator = AgentToAgentCommunicator()\n                agent_types = [AgentType(agent) for agent in (agents or [\"deepseek\", \"perplexity\"])]\n                \n                result = await communicator.parallel_consensus(\n                    question=question,\n                    agents=agent_types\n                )\n                \n                return {\n                    \"success\": True,\n                    \"consensus\": result[\"consensus\"],\n                    \"individual_responses\": result[\"individual_responses\"],\n                    \"confidence_score\": result[\"confidence_score\"],\n                    \"conversation_id\": result[\"conversation_id\"]\n                }\n                \n            except Exception as e:\n                logger.error(f\"MCP Consensus tool error: {e}\")\n                return {\"success\": False, \"error\": str(e)}\n        \n        self._tools_registered = True\n        logger.info(f\"âœ… Registered {len(self.mcp._tools)} MCP tools\")\n\n# Global bridge instance\n_mcp_bridge: Optional[MCPFastAPIBridge] = None\n\nasync def get_mcp_bridge() -> MCPFastAPIBridge:\n    \"\"\"Get or initialize MCP bridge (singleton)\"\"\"\n    global _mcp_bridge\n    if _mcp_bridge is None:\n        _mcp_bridge = MCPFastAPIBridge()\n        await _mcp_bridge.initialize()\n    return _mcp_bridge\n```\n\n### **Solution B: Fix `unified_agent_interface._try_mcp()`**\n\nUpdate `unified_agent_interface.py`:\n\n```python\nasync def _try_mcp(self, request: AgentRequest) -> AgentResponse:\n    \"\"\"Fixed MCP implementation using FastAPI endpoints\"\"\"\n    start_time = time.time()\n    \n    try:\n        # Determine tool name based on agent type\n        if request.agent_type == AgentType.DEEPSEEK:\n            tool_name = \"mcp_agent_to_agent_send_to_deepseek\"\n        else:  # PERPLEXITY\n            tool_name = \"mcp_agent_to_agent_send_to_perplexity\"\n        \n        # Call MCP tool via FastAPI endpoint (NOT separate MCP server)\n        async with httpx.AsyncClient(timeout=30.0) as client:\n            response = await client.post(\n                \"http://127.0.0.1:8000/api/v1/mcp/tools/call\",  # âœ… CORRECT ENDPOINT\n                json={\n                    \"tool_name\": tool_name,\n                    \"arguments\": {\n                        \"content\": request.prompt,\n                        \"context\": request.context\n                    }\n                }\n            )\n            \n            if response.status_code == 200:\n                data = response.json()\n                if data.get(\"success\"):\n                    return AgentResponse(\n                        success=True,\n                        content=data.get(\"content\", \"\"),\n                        channel=AgentChannel.MCP_SERVER,\n                        latency_ms=(time.time() - start_time) * 1000\n                    )\n                else:\n                    return AgentResponse(\n                        success=False,\n                        content=\"\",\n                        channel=AgentChannel.MCP_SERVER,\n                        latency_ms=(time.time() - start_time) * 1000,\n                        error=data.get(\"error\", \"MCP tool execution failed\")\n                    )\n            else:\n                return AgentResponse(\n                    success=False,\n                    content=\"\",\n                    channel=AgentChannel.MCP_SERVER,\n                    latency_ms=(time.time() - start_time) * 1000,\n                    error=f\"MCP HTTP error: {response.status_code}\"\n                )\n                \n    except Exception as e:\n        return AgentResponse(\n            success=False,\n            content=\"\",\n            channel=AgentChannel.MCP_SERVER,\n            latency_ms=(time.time() - start_time) * 1000,\n            error=f\"MCP connection failed: {str(e)}\"\n        )\n```\n\n### **Solution C: Add MCP Routes to FastAPI**\n\nCreate `backend/api/mcp_routes.py`:\n\n```python\n\"\"\"\nMCP Routes for FastAPI - Exposes MCP tools as HTTP endpoints\n\"\"\"\n\nfrom fastapi import APIRouter, HTTPException\nfrom typing import Dict, Any\nimport uuid\nfrom loguru import logger\n\nfrom backend.mcp.mcp_integration import get_mcp_bridge\n\nrouter = APIRouter(prefix=\"/api/v1/mcp\", tags=[\"MCP Tools\"])\n\n@router.post(\"/tools/list\")\nasync def list_mcp_tools():\n    \"\"\"List all available MCP tools\"\"\"\n    try:\n        bridge = await get_mcp_bridge()\n        tools = []\n        \n        for tool_name, tool_func in bridge.mcp._tools.items():\n            tools.append({\n                \"name\": tool_name,\n                \"description\": tool_func.__doc__ or \"No description\",\n                \"parameters\": getattr(tool_func, \"__annotations__\", {})\n            })\n        \n        return {\"tools\": tools, \"count\": len(tools)}\n        \n    except Exception as e:\n        logger.error(f\"Error listing MCP tools: {e}\")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@router.post(\"/tools/call\")\nasync def call_mcp_tool(tool_name: str, arguments: Dict[str, Any]):\n    \"\"\"Call a specific MCP tool\"\"\"\n    try:\n        bridge = await get_mcp_bridge()\n        \n        # Find the tool\n        tool_func = bridge.mcp._tools.get(tool_name)\n        if not tool_func:\n            raise HTTPException(status_code=404, detail=f\"Tool not found: {tool_name}\")\n        \n        # Execute the tool\n        result = await tool_func(**arguments)\n        \n        return {\n            \"success\": True,\n            \"tool\": tool_name,\n            \"result\": result,\n            \"request_id\": str(uuid.uuid4())\n        }\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Error calling MCP tool {tool_name}: {e}\")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@router.get(\"/health\")\nasync def mcp_health():\n    \"\"\"MCP system health check\"\"\"\n    try:\n        bridge = await get_mcp_bridge()\n        return {\n            \"status\": \"healthy\",\n            \"tools_registered\": bridge._tools_registered,\n            \"tools_count\": len(bridge.mcp._tools),\n            \"plugin_manager_ready\": bridge.plugin_manager is not None\n        }\n    except Exception as e:\n        return {\n            \"status\": \"unhealthy\", \n            \"error\": str(e)\n        }\n```\n\n### **Solution D: Update Main FastAPI App**\n\nIn `backend/api/app.py`:\n\n```python\n# Add these imports\nfrom backend.api.mcp_routes import router as mcp_router\nfrom backend.mcp.mcp_integration import get_mcp_bridge\n\n# Add during startup\n@app.on_event(\"startup\")\nasync def startup_event():\n    # Initialize MCP bridge\n    try:\n        bridge = await get_mcp_bridge()\n        logger.success(\"âœ… MCP Bridge initialized successfully\")\n    except Exception as e:\n        logger.error(f\"âŒ MCP Bridge initialization failed: {e}\")\n    \n    # Other startup code...\n\n# Include MCP router\napp.include_router(mcp_router)  # Add this line\napp.include_router(agent_to_agent_api.router)  # Existing\n```\n\n---\n\n## ğŸ¯ ARCHITECTURE VALIDATION & IMPROVEMENTS\n\n### **Fixed Architecture:**\n```python\n# NEW Architecture (WORKING):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚           FastAPI Backend (port: 8000)      â”‚\nâ”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\nâ”‚ â”‚   MCP Bridge    â”‚ â”‚ Agent-to-Agent API  â”‚ â”‚\nâ”‚ â”‚ (MCP tools as   â”‚ â”‚ (/api/v1/agent/...) â”‚ â”‚\nâ”‚ â”‚ HTTP endpoints) â”‚ â”‚                     â”‚ â”‚\nâ”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\nâ”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\nâ”‚ â”‚        Unified Agent Interface          â”‚ â”‚\nâ”‚ â”‚   MCP â†’ Direct API fallback strategy    â”‚ â”‚\nâ”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### **Key Improvements:**\n\n1. **Single Process**: Eliminates inter-process communication complexity\n2. **Unified Health Checks**: All components monitored together\n3. **Simplified Error Handling**: No more STDIO/HTTP protocol mismatches\n4. **Better Testing**: All components testable within same process\n\n---\n\n## ğŸ§ª TESTING STRATEGY\n\n### **Unit Tests:**\n```python\n# tests/test_mcp_integration.py\nasync def test_mcp_tool_registration():\n    bridge = await get_mcp_bridge()\n    tools = await list_mcp_tools()\n    assert \"mcp_agent_to_agent_send_to_deepseek\" in [t[\"name\"] for t in tools[\"tools\"]]\n\nasync def test_mcp_tool_execution():\n    result = await call_mcp_tool(\n        \"mcp_agent_to_agent_send_to_deepseek\", \n        {\"content\": \"Test message\", \"context\": {}}\n    )\n    assert result[\"success\"] == True\n    assert \"content\" in result[\"result\"]\n```\n\n### **Integration Tests:**\n```python\n# tests/test_end_to_end.py\nasync def test_mcp_via_unified_interface():\n    interface = get_agent_interface()\n    request = AgentRequest(\n        agent_type=AgentType.DEEPSEEK,\n        task_type=\"test\",\n        prompt=\"Hello DeepSeek\"\n    )\n    response = await interface.send_request(request)\n    assert response.success\n    assert response.channel == AgentChannel.MCP_SERVER  # Should use MCP now\n```\n\n---\n\n## ğŸ“Š EXPECTED OUTCOMES\n\nAfter implementing these fixes:\n\n1. **MCP Success Rate**: 0% â†’ **85%+** (some latency-based fallbacks expected)\n2. **Latency**: MCP calls should be **faster** than Direct API (no external HTTP)\n3. **Reliability**: Unified error handling across all channels\n4. **Maintainability**: Single codebase for all agent communication\n\n## ğŸš€ IMMEDIATE ACTION PLAN\n\n1. **Priority 1**: Implement `mcp_integration.py` and `mcp_routes.py`\n2. **Priority 2**: Fix `_try_mcp()` method in unified interface  \n3. **Priority 3**: Update FastAPI app to include MCP routes\n4. **Priority 4**: Add comprehensive tests\n5. **Priority 5**: Update background service health checks\n\nThis solution addresses the root cause while maintaining your existing dual-channel strategy and improving overall system reliability."
  },
  "perplexity": {
    "message_id": "1576a871-e672-4b0f-84ec-f6dfd1023384",
    "timestamp": "2025-11-16T19:23:42.966673",
    "content": "**1. FastMCP + FastAPI Integration Patterns**\n\n**Recommended Communication Pattern:**  \nThe most robust and maintainable pattern is to **embed the MCP server within your FastAPI application** using the official FastMCP integration. This allows both HTTP (REST) and MCP (LLM/agent) interfaces to coexist in the same process, sharing resources and avoiding inter-process communication issues[1][2][3][4][5][6][7][8].\n\n**Standard Patterns:**\n- **Single Process, Combined App:**  \n  - Use `FastMCP.from_fastapi(app=your_fastapi_app)` to generate an MCP server from your FastAPI app[1][4][6][7].\n  - Mount the MCP ASGI app into FastAPI (e.g., `app.mount(\"/mcp\", mcp_app)`), so both REST and MCP endpoints are served by the same Uvicorn process[1][2][3][5].\n  - This enables both `/api/...` and `/mcp/...` endpoints to be available on the same server and port.\n\n- **Separate Processes (Advanced/Legacy):**  \n  - Run FastAPI and FastMCP as independent services, communicating via HTTP or IPC.\n  - This is less common and introduces complexity (auth, resource sharing, deployment), but may be needed for legacy or highly isolated deployments[3][5].\n\n**STDIO Transport:**  \nSTDIO is best for CLI tools or when embedding MCP into non-HTTP environments. For HTTP backends (like FastAPI), **prefer the HTTP/ASGI transport** for direct integration[1][2][3][5]. If you must use STDIO, youâ€™ll need a bridge (see below).\n\n**Bridging STDIO MCP with HTTP FastAPI:**\n- **Recommended:** Use FastMCPâ€™s ASGI/HTTP mode, not STDIO, for FastAPI integration[1][2][3][5].\n- **If STDIO is required:**  \n  - Run MCP as a subprocess and communicate via STDIO (e.g., using Pythonâ€™s `subprocess` module).\n  - Implement a FastAPI route that proxies requests to the MCP subprocess via STDIO and returns responses.\n  - This is error-prone and not recommended unless absolutely necessary.\n\n**Example Architecture Diagram:**\n\n```\n[Client/Agent]\n     |\n     v\n[FastAPI+FastMCP (same process, Uvicorn)]\n     |         |\n  /api/...   /mcp/...\n```\n\n**Code Example:**\n```python\nfrom fastapi import FastAPI\nfrom fastmcp import FastMCP\n\napp = FastAPI()\n\n# Define your REST endpoints as usual\n@app.post(\"/api/v1/agent/send\")\nasync def send_agent(...):\n    ...\n\n# Generate MCP server from FastAPI app\nmcp = FastMCP.from_fastapi(app=app, name=\"My MCP Server\")\nmcp_app = mcp.http_app(path='/mcp')\n\n# Combine both sets of routes\ncombined_app = FastAPI(\n    routes=[*mcp_app.routes, *app.routes],\n    lifespan=mcp_app.lifespan,\n)\n\n# Or, mount as sub-app\ncombined_app.mount(\"/mcp\", mcp_app)\n```\n[1][2][3][4][6][7]\n\n---\n\n**2. Model Context Protocol Best Practices**\n\n- **Production MCP Architecture:**  \n  - **Embed MCP in FastAPI** for unified deployment and resource sharing[1][3][4][5][6][7].\n  - Use **ASGI/HTTP transport** for web backends; reserve STDIO for CLI or legacy use[1][2][3][5].\n  - **Separate lifespans:** If both FastAPI and MCP need startup/shutdown logic, use a combined lifespan context manager[1].\n\n- **Asyncio Conflicts:**  \n  - Both FastAPI and FastMCP are asyncio-based. When combined, ensure all async resources (DB, Redis, etc.) are initialized in a single event loop[1].\n  - Use a combined lifespan to avoid double event loop creation or shutdown issues[1].\n\n- **Known Issues with FastMCP v2.13.0.1:**  \n  - No critical issues reported in public docs as of late 2024, but always check [GitHub issues][9].\n  - **Common pitfalls:** CORS middleware conflicts, route shadowing, and improper lifespan management[1].\n\n---\n\n**3. Dual-Channel Agent Communication**\n\n- **Industry Patterns:**  \n  - **Primary/fallback:** Use MCP as primary for LLM/agent workflows; fallback to direct API for reliability or when MCP is unavailable[1][3].\n  - **Health checks:** Implement periodic health checks for both channels. Use circuit breakers or failover logic to switch channels on repeated failures.\n\n- **When to Use MCP vs Direct API:**  \n  - **MCP:** When agent orchestration, tool calling, or LLM context is needed.\n  - **Direct API:** For simple, stateless, or high-reliability calls.\n\n- **Health Check Strategies:**  \n  - Ping both MCP and API endpoints regularly.\n  - Use exponential backoff and alerting for repeated failures.\n  - Log all channel switches for auditability.\n\n---\n\n**4. AI Agent System Architecture**\n\n- **Agent-to-Agent Communication:**  \n  - Use **MCP tools** for multi-turn, iterative, or consensus workflows[1][3][4].\n  - For consensus, implement a voting or aggregation tool as an MCP resource.\n\n- **Rate Limiting with Multiple API Keys:**  \n  - Use a **token bucket** or **leaky bucket** algorithm per key.\n  - Distribute requests across keys using round-robin or weighted random selection.\n  - Monitor usage and rotate keys on quota exhaustion.\n\n- **Cascading Failure Handling:**  \n  - Implement retries with exponential backoff.\n  - Use circuit breakers to prevent overload.\n  - Fallback to alternate channels (API, cached responses) on persistent failure.\n\n---\n\n**5. Similar Projects & References**\n\n| Project/Framework         | Description                                                                                 |\n|--------------------------|---------------------------------------------------------------------------------------------|\n| [Lightspeed MCP][6]      | FastAPI + FastMCP integration, exposes all FastAPI endpoints as MCP tools/resources         |\n| [LobeHub Example][7]     | FastAPI with MCP, demonstrates tool registration and dual-mode endpoints                    |\n| [Speakeasy][4]           | Separates MCP server from app logic using OpenAPI, for larger/enterprise projects           |\n| [Ragie SSE Example][5]   | FastAPI + FastMCP with Server-Sent Events for real-time agent updates                       |\n| [LangChain][*]           | Agent orchestration framework, supports tool calling and multi-agent workflows              |\n| [AutoGPT][*]             | Autonomous agent framework, can be extended for MCP-style tool calling                      |\n\n[*] Not direct MCP examples, but relevant for agent orchestration patterns.\n\n---\n\n**Common Pitfalls & How to Avoid Them**\n\n- **404 Errors on MCP Calls:**  \n  - Usually caused by running MCP and FastAPI in separate processes without proper bridging, or by using the wrong transport (STDIO vs HTTP)[1][2][3][5].\n  - **Solution:** Use FastMCPâ€™s ASGI/HTTP integration and mount MCP into FastAPI[1][2][3][4][5][6][7].\n\n- **CORS Issues:**  \n  - Layering CORS middleware on both FastAPI and MCP can break OAuth and cause 404s on `.well-known` routes[1].\n  - **Solution:** Use sub-app pattern and apply CORS only where needed[1].\n\n- **Asyncio Resource Conflicts:**  \n  - Double initialization or shutdown of event loops.\n  - **Solution:** Use a combined lifespan context manager[1].\n\n---\n\n**Alternative Approaches**\n\n- **Proxy Pattern:**  \n  - Run MCP as a separate service and proxy requests from FastAPI via HTTP.\n  - Adds latency and complexity, but can be useful for strict isolation.\n\n- **OpenAPI-Driven MCP Generation:**  \n  - Use OpenAPI spec to generate MCP server (as in Speakeasy)[4].\n  - Keeps MCP and app logic decoupled, suitable for large teams.\n\n---\n\n**References to Real Projects & Docs**\n- [Lightspeed MCP (GitHub)][6]\n- [LobeHub FastAPI + MCP Example (GitHub)][7]\n- [FastMCP Official Integration Guide][1][2]\n- [Speakeasy MCP Guide][4]\n- [Ragie SSE MCP Example][5]\n- [FastMCP GitHub][9]\n\n---\n\n**Summary Table: Integration Patterns**\n\n| Pattern                      | Pros                                 | Cons                                   | When to Use                |\n|------------------------------|--------------------------------------|----------------------------------------|----------------------------|\n| Embedded (ASGI/HTTP)         | Simple, fast, unified resources      | Tighter coupling, shared failures      | Most use cases             |\n| Separate Process (STDIO/IPC) | Isolation, legacy compatibility      | Complex, error-prone, resource sharing | Legacy or strict isolation |\n| OpenAPI-Driven MCP           | Decoupled, scalable                  | Requires spec maintenance              | Large/enterprise projects  |\n\n---\n\n**If you need code snippets or config files for a specific pattern, let me know.**"
  }
}