{
  "message_id": "3703db6d-c5d8-4e8c-8306-51cb0d0bef6e",
  "from_agent": "deepseek",
  "to_agent": "copilot",
  "content": "–¢–µ–ø–µ—Ä—å –ø—Ä–æ–≤–µ–¥—É –∞–Ω–∞–ª–∏–∑ –ø—Ä–æ–±–ª–µ–º—ã —Å tool calling:\n\n## –ê–ù–ê–õ–ò–ó –ü–†–û–ë–õ–ï–ú–´\n\n### 1. –ù–∞–π–¥–µ–Ω –∫–æ–¥ –¥–ª—è –≤—ã–±–æ—Ä–∞ DIRECT_API –∫–∞–Ω–∞–ª–∞\n\n–í —Ñ–∞–π–ª–µ `backend/agents/agent_to_agent_communicator.py` –≤ –º–µ—Ç–æ–¥–µ `_handle_deepseek_message` (—Å—Ç—Ä–æ–∫–∏ 212-225) –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –µ—Å—Ç—å –∫–æ–¥ –¥–ª—è –≤—ã–±–æ—Ä–∞ –∫–∞–Ω–∞–ª–∞:\n\n```python\n# Determine preferred channel based on file access requirement\n# File access tools require Direct API (tool calling support)\nfrom backend.agents.unified_agent_interface import AgentChannel\npreferred_channel = (\n    AgentChannel.DIRECT_API\n    if message.context.get(\"use_file_access\", False)\n    else AgentChannel.MCP_SERVER\n)\n\nlogger.info(f\"üîÄ Routing to {preferred_channel.value} (use_file_access={message.context.get('use_file_access')})\")\n```\n\n**–ö–æ–¥ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏ –≤—ã–≥–ª—è–¥–∏—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º.**\n\n### 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–µ—Ç–æ–¥–∞ send_request –≤ unified_agent_interface.py\n\n–í —Ñ–∞–π–ª–µ `backend/agents/unified_agent_interface.py` –º–µ—Ç–æ–¥ `send_request` (—Å—Ç—Ä–æ–∫–∏ 358-403) –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —É—á–∏—Ç—ã–≤–∞–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä `preferred_channel`:\n\n```python\nasync def send_request(\n    self,\n    request: AgentRequest,\n    preferred_channel: AgentChannel = AgentChannel.MCP_SERVER\n) -> AgentResponse:\n```\n\n–ò –≤ –ª–æ–≥–∏–∫–µ –≤—ã–±–æ—Ä–∞ –∫–∞–Ω–∞–ª–∞:\n```python\n# Try MCP Server first\nif preferred_channel == AgentChannel.MCP_SERVER and self.mcp_available:\n    # ... MCP logic\n```\n\n### 3. –ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ tool calling\n\n–í –º–µ—Ç–æ–¥–µ `_try_direct_api` (—Å—Ç—Ä–æ–∫–∏ 406-531) –µ—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º:\n\n**–ü—Ä–æ–±–ª–µ–º–∞ 1: –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ tool calling loop**\n- –í —Å—Ç—Ä–æ–∫–µ 448: `payload = request.to_direct_api_format(include_tools=True)` - tools –≤–∫–ª—é—á–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –ø–µ—Ä–≤—É—é –∏—Ç–µ—Ä–∞—Ü–∏—é\n- –í –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö –∏—Ç–µ—Ä–∞—Ü–∏—è—Ö tools –Ω–µ –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è –≤ payload\n\n**–ü—Ä–æ–±–ª–µ–º–∞ 2: –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ MCP tools**\n–í –º–µ—Ç–æ–¥–µ `_execute_mcp_tool` (—Å—Ç—Ä–æ–∫–∏ 532-620):\n```python\n# Extract actual function from FunctionTool wrapper using .fn attribute\ntool_map = {\n    \"mcp_read_project_file\": getattr(mcp_read_project_file, 'fn', mcp_read_project_file),\n    \"mcp_list_project_structure\": getattr(mcp_list_project_structure, 'fn', mcp_list_project_structure),\n    \"mcp_analyze_code_quality\": getattr(mcp_analyze_code_quality, 'fn', mcp_analyze_code_quality),\n}\n```\n\n–≠—Ç–æ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏–µ, —á—Ç–æ MCP tools –∏–º–µ—é—Ç –∞—Ç—Ä–∏–±—É—Ç `.fn`, –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–≤–µ—Ä–Ω—ã–º.\n\n## –ü–†–ï–î–õ–ê–ì–ê–ï–ú–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï\n\n### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ 1: –°–æ—Ö—Ä–∞–Ω—è—Ç—å tools –≤–æ –≤—Å–µ—Ö –∏—Ç–µ—Ä–∞—Ü–∏—è—Ö tool calling\n\n```python\nasync def _try_direct_api(self, request: AgentRequest) -> AgentResponse:\n    \"\"\"–ü–æ–ø—ã—Ç–∫–∞ —á–µ—Ä–µ–∑ Direct API (—Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π tool calling)\"\"\"\n    start_time = time.time()\n    \n    # Get active API key\n    key = self.key_manager.get_active_key(request.agent_type)\n    if not key:\n        return AgentResponse(\n            success=False,\n            content=\"\",\n            channel=AgentChannel.DIRECT_API,\n            error=f\"No active {request.agent_type.value} API keys\"\n        )\n    \n    # Make API request with tool calling loop\n    try:\n        url = self._get_api_url(request.agent_type)\n        headers = self._get_headers(key)\n        \n        # Store the original payload with tools\n        original_payload = request.to_direct_api_format(include_tools=True)\n        messages = original_payload[\"messages\"].copy()\n        max_iterations = 5  # Prevent infinite loops\n        iteration = 0\n        \n        async with httpx.AsyncClient(timeout=120.0) as client:\n            while iteration < max_iterations:\n                iteration += 1\n                \n                # Create payload for this iteration - ALWAYS include tools\n                payload = original_payload.copy()\n                payload[\"messages\"] = messages\n                \n                response = await client.post(url, json=payload, headers=headers)\n                response.raise_for_status()\n                \n                data = response.json()\n                logger.debug(f\"   API response keys: {list(data.keys())}\")\n                \n                # Check if agent wants to call tools (DeepSeek only)\n                if request.agent_type == AgentType.DEEPSEEK:\n                    message = data.get(\"choices\", [{}])[0].get(\"message\", {})\n                    tool_calls = message.get(\"tool_calls\")\n                    \n                    if tool_calls:\n                        logger.info(f\"üîß Agent requested {len(tool_calls)} tool calls (iteration {iteration})\")\n                        \n                        # Add assistant message with tool calls\n                        messages.append(message)\n                        \n                        # Execute each tool call\n                        for tool_call in tool_calls:\n                            tool_result = await self._execute_mcp_tool(tool_call)\n                            \n                            # Format tool result\n                            if tool_result.get(\"success\"):\n                                # Extract the actual data from the result\n                                if \"content\" in tool_result:\n                                    result_content = str(tool_result[\"content\"])\n                                elif \"structure\" in tool_result:\n                                    result_content = json.dumps(tool_result[\"structure\"], indent=2)\n                                elif \"report\" in tool_result:\n                                    result_content = tool_result[\"report\"]\n                                else:\n                                    result_content = json.dumps(tool_result, indent=2)\n                            else:\n                                result_content = f\"Error: {tool_result.get('error', 'Unknown error')}\"\n                            \n                            # Add tool result to messages\n                            messages.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.get(\"id\"),\n                                \"name\": tool_call.get(\"function\", {}).get(\"name\"),\n                                \"content\": result_content\n                            })\n                        \n                        # Continue loop to get agent's final response\n                        continue\n                \n                # No more tool calls - extract final content\n                content = self._extract_content(data, request.agent_type)\n                self.key_manager.mark_success(key)\n                \n                logger.info(f\"‚úÖ Agent completed in {iteration} iterations\")\n                \n                return AgentResponse(\n                    success=True,\n                    content=content,\n                    channel=AgentChannel.DIRECT_API,\n                    api_key_index=key.index,\n                    latency_ms=(time.time() - start_time) * 1000\n                )\n            \n            # Max iterations reached\n            logger.warning(f\"‚ö†Ô∏è Max iterations ({max_iterations}) reached for tool calling\")\n            return AgentResponse(\n                success=False,\n                content=\"\",\n                channel=AgentChannel.DIRECT_API,\n                latency_ms=(time.time() - start_time) * 1000,\n                error=f\"Max tool calling iterations ({max_iterations}) reached\"\n            )\n    \n    except httpx.HTTPStatusError as e:\n        self.key_manager.mark_error(key)\n        logger.error(f\"‚ùå API HTTP error {e.response.status_code}: {e.response.text[:200]}\")\n        \n        # Try backup key\n        return await self._try_backup_key(request, start_time)\n    \n    except Exception as e:\n        self.key_manager.mark_error(key)\n        logger.error(f\"‚ùå API request failed: {e}\")\n        return await self._try_backup_key(request, start_time)\n```\n\n### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ 2: –£–ø—Ä–æ—Å—Ç–∏—Ç—å –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ MCP —Ñ—É–Ω–∫—Ü–∏–π\n\n```python\nasync def _execute_mcp_tool(self, tool_call: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    –í—ã–ø–æ–ª–Ω–∏—Ç—å MCP tool call\n    \"\"\"\n    function_name = None\n    try:\n        function_name = tool_call.get(\"function\", {}).get(\"name\")\n        arguments_str = tool_call.get(\"function\", {}).get(\"arguments\", \"{}\")\n        \n        logger.info(f\"üîß Executing tool: {function_name}\")\n        \n        # Parse arguments\n        if isinstance(arguments_str, str):\n            try:\n                arguments = json.loads(arguments_str)\n            except json.JSONDecodeError as e:\n                logger.error(f\"‚ùå Failed to parse tool arguments: {e}\")\n                return {\n                    \"success\": False,\n                    \"error\": f\"Invalid tool arguments JSON: {str(e)}\"\n                }\n        else:\n            arguments = arguments_str\n        \n        # Import MCP tools from app.py\n        try:\n            from backend.api.app import (\n                mcp_read_project_file,\n                mcp_list_project_structure,\n                mcp_analyze_code_quality\n            )\n        except ImportError as e:\n            logger.error(f\"‚ùå Failed to import MCP tools: {e}\")\n            return {\n                \"success\": False,\n                \"error\": f\"Failed to import MCP tools: {str(e)}\"\n            }\n        \n        # Map tool names to functions - use functions directly\n        tool_map = {\n            \"mcp_read_project_file\": mcp_read_project_file,\n            \"mcp_list_project_structure\": mcp_list_project_structure,\n            \"mcp_analyze_code_quality\": mcp_analyze_code_quality,\n        }\n        \n        if function_name not in tool_map:\n            logger.error(f\"‚ùå Unknown tool: {function_name}\")\n            return {\n                \"success\": False,\n                \"error\": f\"Unknown tool: {function_name}\"\n            }\n        \n        # Execute tool\n        tool_func = tool_map[function_name]\n        result = await tool_func(**arguments)\n        \n        logger.info(f\"‚úÖ Tool executed: {function_name} -> success={result.get('success')}\")\n        return result\n        \n    except Exception as e:\n        logger.error(f\"‚ùå Tool execution failed for {function_name}: {e}\")\n        return {\n            \"success\": False,\n            \"error\": f\"Tool execution error: {str(e)}\"\n        }\n```\n\n## –í–´–í–û–î\n\n**–û—Å–Ω–æ–≤–Ω–∞—è –ø—Ä–æ–±–ª–µ–º–∞**: –í –º–µ—Ç–æ–¥–µ `_try_direct_api` tools –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤–æ –≤—Å–µ—Ö –∏—Ç–µ—Ä–∞—Ü–∏—è—Ö tool calling loop. –í –ø–µ—Ä–≤–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏ tools –≤–∫–ª—é—á–∞—é—Ç—Å—è, –Ω–æ –≤ –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö –∏—Ç–µ—Ä–∞—Ü–∏—è—Ö —Å–æ–∑–¥–∞–µ—Ç—Å—è –Ω–æ–≤—ã–π payload –±–µ–∑ tools.\n\n**–†–µ—à–µ–Ω–∏–µ**: –°–æ—Ö—Ä–∞–Ω—è—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π payload —Å tools –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ –¥–ª—è –≤—Å–µ—Ö –∏—Ç–µ—Ä–∞—Ü–∏–π, –æ–±–Ω–æ–≤–ª—è—è —Ç–æ–ª—å–∫–æ messages.\n\n**–°—Ç–∞—Ç—É—Å**: –ö–æ–¥ –¥–ª—è –≤—ã–±–æ—Ä–∞ DIRECT_API –∫–∞–Ω–∞–ª–∞ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ, –Ω–æ —Å–∞–º–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è tool calling —Ç—Ä–µ–±—É–µ—Ç –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è.",
  "timestamp": "2025-11-17T11:33:21.159993",
  "conversation_id": "33057fd4-68fd-447f-b273-7f26ef64c813",
  "iteration": 2,
  "success": true,
  "error": null
}