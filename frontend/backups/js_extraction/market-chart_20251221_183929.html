<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Security Headers -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://cdn.jsdelivr.net https://unpkg.com; style-src 'self' https://cdn.jsdelivr.net https://fonts.googleapis.com 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' https://cdn.jsdelivr.net https://fonts.gstatic.com; connect-src 'self' https://api.bybit.com wss://stream.bybit.com ws://localhost:* http://localhost:*; frame-src 'none'; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta name="referrer" content="strict-origin-when-cross-origin">

    <title>Advanced Market Chart - Bybit Strategy Tester v2</title>
    <link rel="icon" href="/frontend/favicon.ico" type="image/x-icon">
    <!-- TradingView Lightweight Charts (local) -->
    <script src="libs/lightweight-charts.js"></script>
    <!-- Bootstrap 5.3.2 (local) -->
    <link href="libs/bootstrap.min.css" rel="stylesheet">
    <link href="libs/bootstrap-icons.css" rel="stylesheet">
    <!-- External CSS (Phase 1) -->
    <link rel="stylesheet" href="/frontend/css/variables.css">
    <link rel="stylesheet" href="/frontend/css/components.css">
    <link rel="stylesheet" href="/frontend/css/common.css">
    <link rel="stylesheet" href="/frontend/css/market_chart.css">

    </head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="header-left">
                <div class="logo">
                    <a href="dashboard.html"><i class="bi bi-graph-up-arrow"></i> Charts</a>
                </div>
                
                <div class="symbol-selector">
                    <div class="symbol-dropdown" id="symbolDropdown" onclick="openSymbolSearch(false)">
                        <span id="currentSymbol">BTCUSDT</span>
                        <i class="bi bi-chevron-down"></i>
                    </div>
                    
                    <div class="price-info">
                        <span class="current-price up" id="currentPrice">$97,234.50</span>
                        <span class="price-change positive" id="priceChange">
                            <span>+2.34%</span>
                            <span>+$2,234.50</span>
                        </span>
                    </div>
                </div>

                <div class="timeframe-selector">
                    <button class="tf-btn" data-tf="1">1m</button>
                    <button class="tf-btn" data-tf="5">5m</button>
                    <button class="tf-btn" data-tf="15">15m</button>
                    <button class="tf-btn" data-tf="30">30m</button>
                    <button class="tf-btn" data-tf="60">1H</button>
                    <button class="tf-btn" data-tf="240">4H</button>
                    <button class="tf-btn" data-tf="D">1D</button>
                    <button class="tf-btn" data-tf="W">1W</button>
                </div>
            </div>

            <div class="header-right">
                <div class="compare-wrapper">
                    <button class="header-btn" id="compareBtn" onclick="toggleCompareDropdown()" title="Compare symbols (C)">
                        <i class="bi bi-layers"></i> Compare
                    </button>
                    <!-- Compare Dropdown Panel -->
                    <div class="compare-panel" id="comparePanel">
                        <div class="compare-header">
                            <span class="compare-header-title">Compare Symbols</span>
                            <button class="btn-icon" onclick="toggleCompareMode()" id="compareModeToggle" title="Toggle compare mode">
                                <i class="bi bi-toggle-off" id="compareModeIcon"></i>
                            </button>
                        </div>
                        <div class="compare-chips" id="compareChips">
                            <!-- Dynamically populated -->
                        </div>
                        <button class="compare-add-btn" onclick="openSymbolSearch(true)">
                            <i class="bi bi-plus"></i> Add Symbol
                        </button>
                        <div class="compare-hint">
                            Add symbols to compare their performance
                        </div>
                    </div>
                </div>
                <button class="header-btn" onclick="location.href='tick-chart.html'" title="Tick Chart (T)">
                    <i class="bi bi-activity"></i> Tick
                </button>
                <button class="header-btn" onclick="openIndicatorsModal()" title="Indicators (I)">
                    <i class="bi bi-graph-up"></i> Indicators
                </button>
                <button class="header-btn" onclick="openAlertsModal()" title="Price Alerts (A)">
                    <i class="bi bi-bell"></i> Alerts
                    <span class="alert-badge hidden" id="alertBadge">0</span>
                </button>
                <button class="header-btn" id="settingsBtn" title="Chart Settings (,)">
                    <i class="bi bi-gear"></i> Settings
                </button>
                <button class="header-btn" onclick="exportChart()" title="Export (E)">
                    <i class="bi bi-download"></i> Export
                </button>
                <button class="header-btn" onclick="openShortcutsModal()" title="Keyboard Shortcuts (?)">
                    <i class="bi bi-keyboard"></i>
                </button>
                <button class="header-btn" onclick="toggleFullscreen()" title="Toggle Fullscreen (F)" aria-label="Toggle fullscreen mode">
                    <i class="bi bi-fullscreen"></i>
                </button>
            </div>
        </header>
        
        <!-- Compare Legend (shows current values) -->
        <div class="compare-legend hidden" id="compareLegend">
            <!-- Dynamically populated with current % values -->
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Left Toolbar -->
            <div class="sidebar">
                <button class="tool-btn active" data-tool="cursor" title="Cursor"><i class="bi bi-cursor"></i></button>
                <button class="tool-btn" data-tool="crosshair" title="Crosshair"><i class="bi bi-plus-lg"></i></button>
                <div class="tool-separator"></div>
                <button class="tool-btn" data-tool="trendline" title="Trend Line"><i class="bi bi-slash-lg"></i></button>
                <button class="tool-btn" data-tool="hline" title="Horizontal Line"><i class="bi bi-dash-lg"></i></button>
                <button class="tool-btn" data-tool="rectangle" title="Rectangle"><i class="bi bi-square"></i></button>
                <button class="tool-btn" data-tool="fibonacci" title="Fibonacci"><i class="bi bi-rulers"></i></button>
                <div class="tool-separator"></div>
                <button class="tool-btn" data-tool="text" title="Text"><i class="bi bi-fonts"></i></button>
                <button class="tool-btn" data-tool="arrow" title="Arrow"><i class="bi bi-arrow-right"></i></button>
                <div class="tool-separator"></div>
                <button class="tool-btn" data-tool="measure" title="Measure"><i class="bi bi-rulers"></i></button>
                <button class="tool-btn" data-tool="zoom" title="Zoom"><i class="bi bi-zoom-in"></i></button>
                <div class="tool-separator"></div>
                <button class="tool-btn" onclick="clearDrawings()" title="Clear All"><i class="bi bi-trash"></i></button>
            </div>

            <!-- Chart Area -->
            <div class="chart-area">
                <div class="chart-container" id="chartContainer">
                    <div id="chart"></div>
                    <!-- Countdown Timer -->
                    <div id="candleCountdown" class="candle-countdown">00:00</div>
                    <!-- Pulse Animation Container -->
                    <div id="pricePulse" class="pulse-container">
                        <div class="pulse-ring"></div>
                        <div class="pulse-dot"></div>
                    </div>
                    <div class="loading-overlay" id="loadingOverlay">
                        <div class="spinner"></div>
                    </div>
                </div>
                <!-- Resizable divider -->
                <div class="chart-resizer" id="chartResizer"></div>
                <div class="indicators-panel" id="indicatorsPanel">
                    <div class="volume-label">Объём SMA <span id="volumeSmaValue">9</span></div>
                    <div id="volumeChart"></div>
                </div>
            </div>

            <!-- Right Panel -->
            <div class="right-panel">
                <div class="panel-tabs">
                    <button class="panel-tab active" data-panel="orderbook">Order Book</button>
                    <button class="panel-tab" data-panel="trades">Trades</button>
                    <button class="panel-tab" data-panel="stats">Stats</button>
                </div>
                <div class="panel-content">
                    <!-- Order Book (default) -->
                    <div id="orderbookPanel" class="orderbook">
                        <div class="orderbook-header">
                            <span>Price</span>
                            <span class="text-right">Size</span>
                            <span class="text-right">Total</span>
                        </div>
                        <div id="asks"></div>
                        <!-- Depth Scale Bar - визуальный разделитель -->
                        <div class="depth-scale">
                            <div class="depth-scale-bar">
                                <div class="depth-scale-sell" id="depthSellBar"></div>
                                <div class="depth-scale-buy" id="depthBuyBar"></div>
                            </div>
                        </div>
                        <div class="depth-scale-labels">
                            <span class="depth-scale-label-sell" id="depthSellLabel">50%</span>
                            <span class="spread-row">Spread: <span id="spread">$12.50 (0.01%)</span></span>
                            <span class="depth-scale-label-buy" id="depthBuyLabel">50%</span>
                        </div>
                        <div id="bids"></div>
                        <!-- Buy/Sell Pressure Indicator - single price with dynamic color -->
                        <div class="pressure-indicator">
                            <span class="pressure-arrow" id="pressureArrow">↑</span>
                            <span class="pressure-price" id="pressurePrice">86,426.90</span>
                        </div>
                    </div>
                    <!-- Trades Panel (hidden) -->
                    <div id="tradesPanel" class="trades-list hidden-panel">
                        <div class="trades-header">
                            <span>Price</span>
                            <span class="text-right">Size</span>
                            <span class="text-right">Time</span>
                        </div>
                        <div id="tradesList"></div>
                    </div>
                    <!-- Stats Panel (hidden) -->
                    <div id="statsPanel" class="stats-grid hidden-panel">
                        <div class="stat-item">
                            <div class="stat-label">24h High</div>
                            <div class="stat-value" id="stat24hHigh">$98,500.00</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">24h Low</div>
                            <div class="stat-value" id="stat24hLow">$94,200.00</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">24h Volume</div>
                            <div class="stat-value" id="stat24hVolume">$2.4B</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">24h Trades</div>
                            <div class="stat-value" id="stat24hTrades">1.2M</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Open Interest</div>
                            <div class="stat-value" id="statOI">$12.5B</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Funding Rate</div>
                            <div class="stat-value" id="statFunding">0.01%</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <footer class="status-bar">
            <div class="status-item">
                <span class="status-dot" id="connectionDot"></span>
                <span id="connectionStatus">Connecting...</span>
            </div>
            <div class="status-item">
                <span>Last Update: <span id="lastUpdate">--:--:--</span></span>
            </div>
            <div class="status-item">
                <span>O: <span id="ohlcOpen">--</span></span>
                <span>H: <span id="ohlcHigh">--</span></span>
                <span>L: <span id="ohlcLow">--</span></span>
                <span>C: <span id="ohlcClose">--</span></span>
            </div>
        </footer>
    </div>

    <!-- Symbol Search Modal -->
    <div class="symbol-search-modal" id="symbolSearchModal">
        <div class="symbol-search-container">
            <div class="symbol-search-header">
                <input type="text" class="symbol-search-input" id="symbolSearchInput" 
                       placeholder="Search symbols... (e.g., BTC, ETH, SOL)" 
                       autocomplete="off">
            </div>
            <div class="symbol-categories" id="symbolCategories">
                <button class="symbol-category active" data-category="all">All</button>
                <button class="symbol-category" data-category="popular">Popular</button>
                <button class="symbol-category" data-category="btc">BTC Pairs</button>
                <button class="symbol-category" data-category="eth">ETH Pairs</button>
                <button class="symbol-category" data-category="defi">DeFi</button>
                <button class="symbol-category" data-category="meme">Meme</button>
                <button class="symbol-category" data-category="layer1">Layer 1</button>
            </div>
            <div class="symbol-list" id="symbolList">
                <!-- Dynamically populated -->
            </div>
        </div>
    </div>

    <!-- Indicators Modal -->
    <div class="modal-overlay hidden" id="indicatorsModal">
        <div class="modal" id="indicatorsModalContent">
            <div class="modal-header">
                <h3><i class="bi bi-graph-up"></i> Technical Indicators</h3>
                <button class="modal-close" onclick="closeIndicatorsModal()">×</button>
            </div>
            <div class="modal-body">
                <div class="indicator-item" onclick="toggleIndicator('sma')">
                    <div class="indicator-info">
                        <h4>SMA (Simple Moving Average)</h4>
                        <p>20, 50, 200 periods</p>
                    </div>
                    <div class="indicator-toggle" id="toggle-sma"></div>
                </div>
                <div class="indicator-item" onclick="toggleIndicator('ema')">
                    <div class="indicator-info">
                        <h4>EMA (Exponential Moving Average)</h4>
                        <p>12, 26 periods</p>
                    </div>
                    <div class="indicator-toggle" id="toggle-ema"></div>
                </div>
                <div class="indicator-item" onclick="toggleIndicator('bb')">
                    <div class="indicator-info">
                        <h4>Bollinger Bands</h4>
                        <p>20 period, 2 std dev</p>
                    </div>
                    <div class="indicator-toggle" id="toggle-bb"></div>
                </div>
                <div class="indicator-item" onclick="toggleIndicator('rsi')">
                    <div class="indicator-info">
                        <h4>RSI (Relative Strength Index)</h4>
                        <p>14 period</p>
                    </div>
                    <div class="indicator-toggle" id="toggle-rsi"></div>
                </div>
                <div class="indicator-item" onclick="toggleIndicator('macd')">
                    <div class="indicator-info">
                        <h4>MACD</h4>
                        <p>12, 26, 9 periods</p>
                    </div>
                    <div class="indicator-toggle" id="toggle-macd"></div>
                </div>
                <div class="indicator-item" onclick="toggleIndicator('vwap')">
                    <div class="indicator-info">
                        <h4>VWAP</h4>
                        <p>Volume Weighted Average Price</p>
                    </div>
                    <div class="indicator-toggle" id="toggle-vwap"></div>
                </div>
                <div class="indicator-item" onclick="toggleIndicator('stoch')">
                    <div class="indicator-info">
                        <h4>Stochastic Oscillator</h4>
                        <p>14, 3, 3 periods (K, D, Smooth)</p>
                    </div>
                    <div class="indicator-toggle" id="toggle-stoch"></div>
                </div>
                <div class="indicator-item" onclick="toggleIndicator('atr')">
                    <div class="indicator-info">
                        <h4>ATR (Average True Range)</h4>
                        <p>14 period volatility indicator</p>
                    </div>
                    <div class="indicator-toggle" id="toggle-atr"></div>
                </div>
                <div class="indicator-item" onclick="toggleIndicator('ichimoku')">
                    <div class="indicator-info">
                        <h4>Ichimoku Cloud</h4>
                        <p>9, 26, 52 periods</p>
                    </div>
                    <div class="indicator-toggle" id="toggle-ichimoku"></div>
                </div>
                <div class="indicator-item" onclick="toggleIndicator('pivots')">
                    <div class="indicator-info">
                        <h4>Pivot Points</h4>
                        <p>Support/Resistance levels (S1-S3, R1-R3)</p>
                    </div>
                    <div class="indicator-toggle" id="toggle-pivots"></div>
                </div>
                <div class="indicator-item" onclick="toggleIndicator('supertrend')">
                    <div class="indicator-info">
                        <h4>SuperTrend</h4>
                        <p>ATR-based trend following (10, 3)</p>
                    </div>
                    <div class="indicator-toggle" id="toggle-supertrend"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Price Alerts Modal -->
    <div class="modal-overlay hidden" id="alertsModal">
        <div class="modal modal-wide">
            <div class="modal-header">
                <h3><i class="bi bi-bell"></i> Price Alerts</h3>
                <button class="modal-close" onclick="closeAlertsModal()">×</button>
            </div>
            <div class="modal-body">
                <div class="alert-form">
                    <div class="alert-form-row">
                        <select id="alertCondition" class="form-select">
                            <option value="above">Price Above</option>
                            <option value="below">Price Below</option>
                            <option value="cross_up">Crosses Up</option>
                            <option value="cross_down">Crosses Down</option>
                        </select>
                        <input type="number" id="alertPrice" placeholder="Price" class="form-input">
                    </div>
                    <div class="alert-form-row">
                        <input type="text" id="alertMessage" placeholder="Alert message (optional)" class="form-input">
                        <button onclick="createAlert()" class="btn-primary">
                            <i class="bi bi-plus-lg"></i> Add
                        </button>
                    </div>
                </div>
                <div id="alertsList" class="alerts-list">
                    <!-- Alerts will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Keyboard Shortcuts Modal -->
    <div class="modal-overlay hidden" id="shortcutsModal">
        <div class="modal modal-medium">
            <div class="modal-header">
                <h3><i class="bi bi-keyboard"></i> Keyboard Shortcuts</h3>
                <button class="modal-close" onclick="closeShortcutsModal()">×</button>
            </div>
            <div class="modal-body">
                <div class="shortcuts-grid">
                    <div class="shortcut-item">
                        <span>Toggle Indicators</span>
                        <kbd>I</kbd>
                    </div>
                    <div class="shortcut-item">
                        <span>Search Symbol</span>
                        <kbd>S</kbd>
                    </div>
                    <div class="shortcut-item">
                        <span>Price Alerts</span>
                        <kbd>A</kbd>
                    </div>
                    <div class="shortcut-item">
                        <span>Toggle Fullscreen</span>
                        <kbd>F</kbd>
                    </div>
                    <div class="shortcut-item">
                        <span>Zoom In</span>
                        <kbd>+</kbd>
                    </div>
                    <div class="shortcut-item">
                        <span>Zoom Out</span>
                        <kbd>-</kbd>
                    </div>
                    <div class="shortcut-item">
                        <span>Reset Zoom</span>
                        <kbd>R</kbd>
                    </div>
                    <div class="shortcut-item">
                        <span>Toggle Compare Mode</span>
                        <kbd>C</kbd>
                    </div>
                    <div class="shortcut-item">
                        <span>Export Chart</span>
                        <kbd>E</kbd>
                    </div>
                    <div class="shortcut-item">
                        <span>Chart Settings</span>
                        <kbd>,</kbd>
                    </div>
                    <div class="shortcut-item">
                        <span>Timeframes (1m-1W)</span>
                        <kbd>1-7</kbd>
                    </div>
                    <div class="shortcut-item">
                        <span>Show Shortcuts</span>
                        <kbd>?</kbd>
                    </div>
                    <div class="shortcut-item">
                        <span>Close Modal</span>
                        <kbd>Esc</kbd>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay settings-modal hidden" id="settingsModal">
        <div class="modal modal-wide">
            <div class="modal-header">
                <h3><i class="bi bi-gear"></i> Chart Settings</h3>
                <button class="modal-close" onclick="closeSettingsModal()">×</button>
            </div>
            <div class="modal-body">
                <!-- Settings Tabs -->
                <div class="settings-tabs">
                    <button class="settings-tab active" data-tab="display" onclick="switchSettingsTab('display')">
                        <i class="bi bi-display"></i> Display
                    </button>
                    <button class="settings-tab" data-tab="volume" onclick="switchSettingsTab('volume')">
                        <i class="bi bi-bar-chart-fill"></i> Volume
                    </button>
                    <button class="settings-tab" data-tab="trading" onclick="switchSettingsTab('trading')">
                        <i class="bi bi-graph-up-arrow"></i> Trading
                    </button>
                    <button class="settings-tab" data-tab="patterns" onclick="switchSettingsTab('patterns')">
                        <i class="bi bi-diagram-3"></i> Patterns
                    </button>
                    <button class="settings-tab" data-tab="advanced" onclick="switchSettingsTab('advanced')">
                        <i class="bi bi-sliders"></i> Advanced
                    </button>
                </div>
                
                <!-- Display Settings -->
                <div class="settings-panel active" id="settings-display">
                    <div class="settings-section">
                        <h4>Chart Appearance</h4>
                        <div class="settings-grid">
                            <!-- Visual Enhancements -->

                             <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Comp. Scrollbar</span>
                                    <span class="setting-desc">Sleek dark mode scrollbars</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-customScrollbar" onchange="updateSetting('customScrollbar', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Price Pulse</span>
                                    <span class="setting-desc">Animating pulse at current price</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-pulse" onchange="updateSetting('pulse', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Candle Countdown</span>
                                    <span class="setting-desc">Show time remaining</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-countdown" onchange="updateSetting('countdown', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                             <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Trade Markers</span>
                                    <span class="setting-desc">Show mock executions</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-tradeMarkers" onchange="updateSetting('tradeMarkers', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            
                            <hr class="settings-separator">
                            
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Show Grid Lines</span>
                                    <span class="setting-desc">Display horizontal and vertical grid</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-gridLines" checked onchange="updateSetting('gridLines', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Show Volume Chart</span>
                                    <span class="setting-desc">Display volume histogram below candles</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-volumeChart" checked onchange="updateSetting('volumeChart', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Show Watermark</span>
                                    <span class="setting-desc">Display symbol name as watermark</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-watermark" onchange="updateSetting('watermark', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Show Last Price Line</span>
                                    <span class="setting-desc">Horizontal line at current price</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-lastPriceLine" checked onchange="updateSetting('lastPriceLine', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Show Crosshair</span>
                                    <span class="setting-desc">Display crosshair on mouse hover</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-crosshair" checked onchange="updateSetting('crosshair', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Volume Settings -->
                <div class="settings-panel" id="settings-volume">
                    <div class="settings-section">
                        <h4>Volume Indicators</h4>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Volume SMA</span>
                                    <span class="setting-desc">Simple Moving Average of Volume</span>
                                </div>
                                <div class="setting-controls">
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="setting-volumeSma" checked onchange="updateVolumeSetting('sma', this.checked)">
                                        <span class="toggle-slider"></span>
                                    </label>
                                    <input type="number" id="setting-volumeSmaPeriod" value="9" min="2" max="50" 
                                           class="setting-input-small" onchange="updateVolumeSetting('smaPeriod', this.value)">
                                </div>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Volume EMA</span>
                                    <span class="setting-desc">Exponential Moving Average of Volume</span>
                                </div>
                                <div class="setting-controls">
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="setting-volumeEma" onchange="updateVolumeSetting('ema', this.checked)">
                                        <span class="toggle-slider"></span>
                                    </label>
                                    <input type="number" id="setting-volumeEmaPeriod" value="21" min="2" max="50" 
                                           class="setting-input-small" onchange="updateVolumeSetting('emaPeriod', this.value)">
                                </div>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">VWAP</span>
                                    <span class="setting-desc">Volume Weighted Average Price (on main chart)</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-vwap" onchange="updateVolumeSetting('vwap', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Volume Bollinger Bands</span>
                                    <span class="setting-desc">Detect abnormal volume spikes</span>
                                </div>
                                <div class="setting-controls">
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="setting-volumeBB" onchange="updateVolumeSetting('bb', this.checked)">
                                        <span class="toggle-slider"></span>
                                    </label>
                                    <input type="number" id="setting-volumeBBPeriod" value="20" min="5" max="50" 
                                           class="setting-input-small" onchange="updateVolumeSetting('bbPeriod', this.value)">
                                </div>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">OBV (On-Balance Volume)</span>
                                    <span class="setting-desc">Cumulative volume indicator</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-obv" onchange="updateVolumeSetting('obv', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Volume Delta</span>
                                    <span class="setting-desc">Buy vs Sell volume difference</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-volumeDelta" onchange="updateVolumeSetting('delta', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Highlight High Volume</span>
                                    <span class="setting-desc">Highlight bars with above-average volume</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-highlightVolume" checked onchange="updateVolumeSetting('highlight', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>
                    <div class="settings-section">
                        <h4>Volume Chart Style</h4>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Bar Opacity</span>
                                    <span class="setting-desc">Volume bar transparency</span>
                                </div>
                                <input type="range" id="setting-volumeOpacity" min="20" max="100" value="80" 
                                       class="setting-range" onchange="updateVolumeSetting('opacity', this.value)">
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Trading Settings -->
                <div class="settings-panel" id="settings-trading">
                    <div class="settings-section">
                        <h4>Price Levels</h4>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Show Support/Resistance</span>
                                    <span class="setting-desc">Auto-detect and display S/R levels</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-supportResistance" onchange="updateSetting('supportResistance', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Show 24h High/Low</span>
                                    <span class="setting-desc">Display 24h price range lines</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-highLowLines" onchange="updateSetting('highLowLines', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Show Open Price</span>
                                    <span class="setting-desc">Display daily open price line</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-openPriceLine" onchange="updateSetting('openPriceLine', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>
                    <div class="settings-section">
                        <h4>Trade Signals</h4>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Show Buy/Sell Markers</span>
                                    <span class="setting-desc">Display strategy signals on chart</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-buySellMarkers" onchange="updateSetting('buySellMarkers', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Show Liquidations</span>
                                    <span class="setting-desc">Display large liquidation events</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-liquidations" onchange="updateSetting('liquidations', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Pattern Detection Settings -->
                <div class="settings-panel" id="settings-patterns">
                    <div class="settings-section">
                        <h4>Candlestick Patterns</h4>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Detect Doji</span>
                                    <span class="setting-desc">Indecision candles</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-pattern-doji" onchange="updateSetting('patternDoji', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Detect Hammer/Hanging Man</span>
                                    <span class="setting-desc">Reversal patterns</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-pattern-hammer" onchange="updateSetting('patternHammer', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Detect Engulfing</span>
                                    <span class="setting-desc">Bullish/Bearish engulfing</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-pattern-engulfing" onchange="updateSetting('patternEngulfing', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Detect Morning/Evening Star</span>
                                    <span class="setting-desc">3-candle reversal patterns</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-pattern-star" onchange="updateSetting('patternStar', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Detect Three Soldiers/Crows</span>
                                    <span class="setting-desc">Strong trend continuation</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-pattern-soldiers" onchange="updateSetting('patternSoldiers', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Advanced Settings -->
                <div class="settings-panel" id="settings-advanced">
                    <div class="settings-section">
                        <h4>Data & Performance</h4>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Auto-Load History</span>
                                    <span class="setting-desc">Load more data when scrolling left</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-infiniteHistory" checked onchange="updateSetting('infiniteHistory', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Auto-Scroll to New Candles</span>
                                    <span class="setting-desc">Keep latest candle visible</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-autoScroll" checked onchange="updateSetting('autoScroll', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Show Connection Status</span>
                                    <span class="setting-desc">Display WebSocket status indicator</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-connectionStatus" checked onchange="updateSetting('connectionStatus', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>
                    <div class="settings-section">
                        <h4>Right Panel</h4>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Show Order Book</span>
                                    <span class="setting-desc">Display real-time order book</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-orderBook" checked onchange="updateSetting('orderBook', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-info">
                                    <span class="setting-label">Show Recent Trades</span>
                                    <span class="setting-desc">Display trade feed</span>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="setting-recentTrades" checked onchange="updateSetting('recentTrades', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>
                    <div class="settings-actions">
                        <button class="btn-secondary" onclick="resetSettings()">
                            <i class="bi bi-arrow-counterclockwise"></i> Reset to Defaults
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // console.log('[Script] Loading market-chart.html JavaScript...');
        
        // Configuration
        const API_BASE = window.location.origin;
        const MARKET_API = `${API_BASE}/api/v1/marketdata`;
        
        // Extended Symbol List
        const SYMBOLS = [
            // Popular
            { symbol: 'BTCUSDT', base: 'Bitcoin', category: ['popular', 'layer1'] },
            { symbol: 'ETHUSDT', base: 'Ethereum', category: ['popular', 'layer1'] },
            { symbol: 'SOLUSDT', base: 'Solana', category: ['popular', 'layer1'] },
            { symbol: 'BNBUSDT', base: 'BNB', category: ['popular', 'layer1'] },
            { symbol: 'XRPUSDT', base: 'Ripple', category: ['popular'] },
            { symbol: 'ADAUSDT', base: 'Cardano', category: ['popular', 'layer1'] },
            { symbol: 'AVAXUSDT', base: 'Avalanche', category: ['popular', 'layer1'] },
            { symbol: 'DOTUSDT', base: 'Polkadot', category: ['popular', 'layer1'] },
            { symbol: 'MATICUSDT', base: 'Polygon', category: ['popular', 'layer1'] },
            { symbol: 'LINKUSDT', base: 'Chainlink', category: ['popular', 'defi'] },
            // DeFi
            { symbol: 'UNIUSDT', base: 'Uniswap', category: ['defi'] },
            { symbol: 'AAVEUSDT', base: 'Aave', category: ['defi'] },
            { symbol: 'CRVUSDT', base: 'Curve', category: ['defi'] },
            { symbol: 'MKRUSDT', base: 'Maker', category: ['defi'] },
            { symbol: 'COMPUSDT', base: 'Compound', category: ['defi'] },
            { symbol: 'SUSHIUSDT', base: 'SushiSwap', category: ['defi'] },
            { symbol: 'SNXUSDT', base: 'Synthetix', category: ['defi'] },
            // Meme
            { symbol: 'DOGEUSDT', base: 'Dogecoin', category: ['popular', 'meme'] },
            { symbol: 'SHIBUSDT', base: 'Shiba Inu', category: ['meme'] },
            { symbol: 'PEPEUSDT', base: 'Pepe', category: ['meme'] },
            { symbol: 'FLOKIUSDT', base: 'Floki', category: ['meme'] },
            { symbol: 'BONKUSDT', base: 'Bonk', category: ['meme'] },
            // Layer 1
            { symbol: 'NEARUSDT', base: 'Near Protocol', category: ['layer1'] },
            { symbol: 'APTUSDT', base: 'Aptos', category: ['layer1'] },
            { symbol: 'SUIUSDT', base: 'Sui', category: ['layer1'] },
            { symbol: 'ATOMUSDT', base: 'Cosmos', category: ['layer1'] },
            { symbol: 'FTMUSDT', base: 'Fantom', category: ['layer1'] },
            // BTC Pairs
            { symbol: 'ETHBTC', base: 'ETH/BTC', category: ['btc'] },
            { symbol: 'SOLBTC', base: 'SOL/BTC', category: ['btc'] },
            { symbol: 'BNBBTC', base: 'BNB/BTC', category: ['btc'] },
            // ETH Pairs  
            { symbol: 'LINKETH', base: 'LINK/ETH', category: ['eth'] },
            { symbol: 'UNIAETH', base: 'UNI/ETH', category: ['eth'] },
        ];

        // Compare mode colors
        const COMPARE_COLORS = ['#58a6ff', '#00c853', '#d29922', '#ff1744', '#a371f7', '#db6d28'];
        
        // State
        let chart = null;
        let volumeChart = null;
        let candleSeries = null;
        let volumeSeries = null;
        let volumeSmaSeries = null;
        
        // Volume Settings - matches HTML toggle IDs
        let volumeSettings = {
            sma: true,           // setting-volumeSma
            smaPeriod: 9,        // setting-volumeSmaPeriod
            ema: false,          // setting-volumeEma
            emaPeriod: 21,       // setting-volumeEmaPeriod
            vwap: false,         // setting-vwap
            bb: false,           // setting-volumeBB (Bollinger Bands)
            bbPeriod: 20,        // setting-volumeBBPeriod
            obv: false,          // setting-obv
            delta: false,        // setting-volumeDelta
            highlight: true,     // setting-highlightVolume
            opacity: 80          // setting-volumeOpacity
        };

        let indicatorSeries = {};
        let currentSymbol = localStorage.getItem('chart_symbol') || 'BTCUSDT';
        let currentTimeframe = localStorage.getItem('chart_timeframe') || '60';
        let activeIndicators = new Set();
        let ws = null;
        let currentCandles = [];  // Store candle data for mock updates
        let currentVolumes = [];  // Store volume data for mock updates
        let rawVolumes = [];  // Store raw volume values for normalization
        let mockPriceIntervalId = null;  // Interval for mock price updates
        let latestTickerData = null;  // Store latest ticker for price lines

        // -----------------------------------------------------
        // LightweightCharts safety: never feed invalid points
        // -----------------------------------------------------
        function safeSetData(series, data, seriesName = 'series') {
            if (!series || typeof series.setData !== 'function') return { ok: false, reason: 'no_series', points: 0 };

            const src = Array.isArray(data) ? data : [];
            const cleaned = [];
            let isHistogramLike = false;
            let isCandlestick = false;

            for (const p of src) {
                if (!p) continue;
                const t = p.time;
                
                // Check if this is candlestick data (has open, high, low, close)
                if (p.open != null && p.high != null && p.low != null && p.close != null) {
                    isCandlestick = true;
                    const open = typeof p.open === 'number' ? p.open : parseFloat(p.open);
                    const high = typeof p.high === 'number' ? p.high : parseFloat(p.high);
                    const low = typeof p.low === 'number' ? p.low : parseFloat(p.low);
                    const close = typeof p.close === 'number' ? p.close : parseFloat(p.close);
                    
                    if (t != null && Number.isFinite(open) && Number.isFinite(high) && Number.isFinite(low) && Number.isFinite(close)) {
                        cleaned.push({ time: t, open, high, low, close });
                    }
                    continue;
                }
                
                // Otherwise treat as histogram/line series (has value)
                const v = p.value;
                if (t == null || v == null) continue;

                const num = typeof v === 'number' ? v : parseFloat(v);
                if (!Number.isFinite(num)) continue;

                // Preserve histogram extras (e.g., MACD/volume bars use {time,value,color}).
                if (p.color != null) {
                    isHistogramLike = true;
                    cleaned.push({ time: t, value: num, color: p.color });
                } else {
                    cleaned.push({ time: t, value: num });
                }
            }

            // Prevent LightweightCharts from throwing on empty/invalid datasets.
            if (cleaned.length < 2) {
                try { series.setData([]); } catch (e) {
                    console.warn('[safeSetData] setData([]) failed for', seriesName, e);
                }
                return { ok: false, reason: 'too_few_points', points: cleaned.length };
            }

            try {
                series.setData(cleaned);
                return { ok: true, points: cleaned.length, histogram: isHistogramLike, candlestick: isCandlestick };
            } catch (e) {
                console.warn('[safeSetData] setData failed for', seriesName, e);
                try { series.setData([]); } catch (_) {}
                return { ok: false, reason: 'exception', points: cleaned.length, histogram: isHistogramLike, candlestick: isCandlestick };
            }
        }

        // Patch LightweightCharts series creation so ANY setData call is filtered.
        // This protects against crashes from other indicator paths that still call series.setData directly.
        function patchSeriesSetData(chartObj, chartName) {
            if (!chartObj || chartObj.__setDataPatched) return;
            const methods = [
                'addLineSeries',
                'addHistogramSeries',
                'addAreaSeries',
                'addBaselineSeries',
                'addCandlestickSeries',
            ];
            for (const m of methods) {
                const orig = chartObj[m];
                if (typeof orig !== 'function') continue;
                chartObj[m] = function(...args) {
                    const series = orig.apply(this, args);
                    if (series && typeof series.setData === 'function' && !series.__setDataWrapped) {
                        const seriesLabel = `${chartName}.${m}`;
                        const origSetData = series.setData.bind(series);
                        series.setData = function(data) {
                            // Always sanitize BEFORE reaching LightweightCharts.
                            safeSetData({ setData: origSetData }, data, seriesLabel);
                        };
                        series.__setDataWrapped = true;
                    }
                    return series;
                };
            }
            chartObj.__setDataPatched = true;
        }
        
        // Return volumes as-is - let chart auto-scale naturally
        // This shows true volume proportions like Bybit
        function normalizeVolumes(volumes) {
            if (!volumes || volumes.length === 0) return volumes;
            // No transformation - show real volume values
            return volumes;
        }

        // Calculate SMA for volume (like Bybit's "Объём SMA 9")
        function calculateVolumeSMA(volumes, period = 9) {
            if (!volumes || volumes.length < period) return [];
            
            const result = [];
            for (let i = period - 1; i < volumes.length; i++) {
                let sum = 0;
                for (let j = 0; j < period; j++) {
                    sum += volumes[i - j].value;
                }
                result.push({ 
                    time: volumes[i].time, 
                    value: sum / period  // Real SMA value without sqrt
                });
            }
            return result;
        }
        
        // Compare Mode State
        let compareMode = false;
        let compareSymbols = []; // [{symbol, series, color}]
        let isSelectingForCompare = false;
        let isLoadingData = false;  // Flag to prevent sync errors during data loading
        
        // Infinite scroll history state
        let isLoadingHistory = false;
        let noMoreHistory = false;  // Flag when we've reached the beginning of history

        // =====================================================
        // CONSOLIDATED DOMContentLoaded Handler
        // =====================================================
        document.addEventListener('DOMContentLoaded', async () => {
            // console.log('[Init] Starting...');
            try {
                // ---- Core Initialization ----
                initCharts();
                initChartResizer();  // Initialize resizable divider
                // console.log('[Init] Charts initialized');
                
                // Load settings before applying them
                loadSettings();
                loadVolumeSettings();
                // console.log('[Init] Settings loaded');
                
                setupEventListeners();
                initSymbolSearch();

                
                // Get symbol from URL if provided, otherwise use localStorage
                const urlParams = new URLSearchParams(window.location.search);
                const symbolParam = urlParams.get('symbol');
                if (symbolParam) {
                    currentSymbol = symbolParam.toUpperCase();
                }
                // Update UI with current symbol
                document.getElementById('currentSymbol').textContent = currentSymbol;
                
                // Set active timeframe button based on saved/default value
                document.querySelectorAll('.tf-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.tf === currentTimeframe) {
                        btn.classList.add('active');
                    }
                });
                
                // Start WebSocket connection early (non-blocking)
                // This allows real-time updates to start while history loads
                connectWebSocket();
                
                // Load candle data (now fast - uses cache first)
                // console.log('[Init] Loading candle data...');
                await loadCandleData();
                // console.log('[Init] Candle data loaded');
                
                // Apply all settings now that chart and data are ready
                applyAllSettings();
                // console.log('[Init] Settings applied');
                
                // Resize charts after data loaded to ensure proper dimensions
                requestAnimationFrame(() => resizeCharts());
                
                // Apply settings after chart data is loaded
                setTimeout(() => {
                    applyAllSettings();
                    // console.log('[Init] Settings applied');
                }, 100);
                setTimeout(() => {
                    applyAllSettings();
                    // console.log('[Init] Settings applied');
                }, 100);
                
                // WebSocket already started earlier (parallel with data load)
                
                // ---- Load saved state ----
                loadSavedIndicators();
                
                // Load alerts after a small delay to ensure chart is ready
                setTimeout(() => {
                    loadAlerts();
                }, 500);
            } catch (e) {
                console.error('[Init] Error:', e);
            }
        });

        // WebSocket timestamp tracking
        let lastWsMessageTs = 0;

        // =====================================================
        // Chart Resizer - Drag to resize price/volume charts
        // =====================================================
        function initChartResizer() {
            const resizer = document.getElementById('chartResizer');
            const chartContainer = document.getElementById('chartContainer');
            const indicatorsPanel = document.getElementById('indicatorsPanel');
            const chartArea = document.querySelector('.chart-area');
            
            if (!resizer || !chartContainer || !indicatorsPanel) return;
            
            let isDragging = false;
            let startY = 0;
            let startVolumeHeight = 0;
            
            resizer.addEventListener('mousedown', (e) => {
                isDragging = true;
                startY = e.clientY;
                startVolumeHeight = indicatorsPanel.offsetHeight;
                resizer.classList.add('dragging');
                document.body.style.cursor = 'ns-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaY = startY - e.clientY;
                const chartAreaHeight = document.querySelector('.chart-area').offsetHeight;
                const maxVolumeHeight = Math.min(400, chartAreaHeight * 0.4); // Max 40% of chart area
                const newVolumeHeight = Math.max(80, Math.min(maxVolumeHeight, startVolumeHeight + deltaY));
                
                indicatorsPanel.style.height = newVolumeHeight + 'px';
                
                // Resize charts to fit new dimensions
                resizeCharts();
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    resizer.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                    
                    // Save preference
                    localStorage.setItem('volumePanelHeight', indicatorsPanel.offsetHeight);
                }
            });
            
            // Restore saved height with validation
            const savedHeight = parseInt(localStorage.getItem('volumePanelHeight'));
            if (savedHeight && savedHeight >= 80 && savedHeight <= 300) {
                indicatorsPanel.style.height = savedHeight + 'px';
            } else {
                // Reset to default if invalid
                localStorage.removeItem('volumePanelHeight');
                indicatorsPanel.style.height = '150px';
            }
            
            // Force resize after setting height to ensure charts fit
            requestAnimationFrame(() => resizeCharts());
        }
        
        function resizeCharts() {
            // Get main chart dimensions
            const chartContainer = document.getElementById('chart');
            const mainWidth = chartContainer.clientWidth;
            
            if (chart) {
                if (mainWidth > 0 && chartContainer.clientHeight > 0) {
                    chart.applyOptions({
                        width: mainWidth,
                        height: chartContainer.clientHeight
                    });
                }
            }
            
            // Apply main chart width to volume chart for perfect alignment
            if (volumeChart) {
                const volumeContainer = document.getElementById('volumeChart');
                if (mainWidth > 0 && volumeContainer.clientHeight > 0) {
                    volumeChart.applyOptions({
                        width: mainWidth, // Use main chart width
                        height: volumeContainer.clientHeight
                    });
                }
            }
        }

        function initCharts() {
            // Main candlestick chart
            const chartContainer = document.getElementById('chart');
            chart = LightweightCharts.createChart(chartContainer, {
                width: chartContainer.clientWidth,
                height: chartContainer.clientHeight,
                layout: {
                    background: { type: 'solid', color: '#0d1117' },
                    textColor: '#8b949e'
                },
                grid: {
                    vertLines: { color: '#21262d' },
                    horzLines: { color: '#21262d' }
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                    vertLine: {
                        color: '#58a6ff',
                        width: 1,
                        style: LightweightCharts.LineStyle.Dashed
                    },
                    horzLine: {
                        color: '#58a6ff',
                        width: 1,
                        style: LightweightCharts.LineStyle.Dashed
                    }
                },
                rightPriceScale: {
                    borderColor: '#30363d',
                    width: 80
                },
                timeScale: {
                    borderColor: '#30363d',
                    timeVisible: true,
                    secondsVisible: false,
                    rightOffset: 12,  // Keep space for new candles on the right
                    shiftVisibleRangeOnNewBar: true  // Auto-scroll when new candle appears
                }
            });

            // Wrap all future series.setData calls on this chart.
            patchSeriesSetData(chart, 'chart');

            candleSeries = chart.addCandlestickSeries({
                upColor: '#00c853',       // Brighter green like Bybit
                downColor: '#ff1744',      // Brighter red like Bybit
                borderDownColor: '#ff1744',
                borderUpColor: '#00c853',
                wickDownColor: '#ff1744',
                wickUpColor: '#00c853',
                priceFormat: {
                    type: 'price',
                    precision: 2,
                    minMove: 0.01
                }
            });

            // Volume chart
            const volumeContainer = document.getElementById('volumeChart');
            volumeChart = LightweightCharts.createChart(volumeContainer, {
                width: volumeContainer.clientWidth,
                height: volumeContainer.clientHeight,
                layout: {
                    background: { type: 'solid', color: '#0d1117' },
                    textColor: '#8b949e'
                },
                grid: {
                    vertLines: { color: '#21262d' },
                    horzLines: { color: '#21262d' }
                },
                rightPriceScale: {
                    borderColor: '#30363d',
                    scaleMargins: { top: 0, bottom: 0 },
                    width: 80
                },
                timeScale: {
            visible: false,
            rightOffset: 12,
            shiftVisibleRangeOnNewBar: true,
        }
    });

            // Wrap all future series.setData calls on the volume chart.
            patchSeriesSetData(volumeChart, 'volumeChart');

    // Force initial resize to ensure alignment
    resizeCharts();

            volumeSeries = volumeChart.addHistogramSeries({
                priceFormat: { 
                    type: 'custom',
                    minMove: 1,
                    formatter: (value) => {
                        // Ensure value is a number
                        const num = typeof value === 'number' ? value : parseFloat(value) || 0;
                        if (num >= 1000000) return '  ' + (num / 1000000).toFixed(2) + 'M';
                        if (num >= 1000) return '  ' + (num / 1000).toFixed(2) + 'K';
                        return num.toFixed(0).padStart(8, ' ');
                    }
                },
                // priceScaleId: 'right' // Default
            });

            volumeChart.priceScale('right').applyOptions({
                scaleMargins: { top: 0.1, bottom: 0 },
                width: 80
            });

            // Volume SMA 9 line (like Bybit)
            volumeSmaSeries = volumeChart.addLineSeries({
                color: '#58a6ff',
                lineWidth: 1,
                // priceScaleId: 'right', // Default
                lastValueVisible: false,
                priceLineVisible: false
            });

            // =====================================================
            // LOGICAL RANGE SYNCHRONIZATION (Best for alignment)
            // =====================================================
            let isSyncingCharts = false;

            // Sync volume chart when main chart changes
            chart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
                if (isLoadingData || isSyncingCharts) return;
                try {
                    isSyncingCharts = true;
                    if (volumeChart && logicalRange) {
                        volumeChart.timeScale().setVisibleLogicalRange(logicalRange);
                    }
                } finally {
                    isSyncingCharts = false;
                }
            });
            
            volumeChart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
                if (isLoadingData || isSyncingCharts) return;
                try {
                    isSyncingCharts = true;
                    if (chart && logicalRange) {
                        chart.timeScale().setVisibleLogicalRange(logicalRange);
                    }
                } finally {
                    isSyncingCharts = false;
                }
            });
            
            // Infinite scroll - load more history when scrolling left
            // Uses global isLoadingHistory and noMoreHistory variables
            let loadHistoryDebounceTimer = null;
            
            chart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
                if (!logicalRange || isLoadingData || isLoadingHistory || isSyncingCharts || noMoreHistory) return;
                
                // If user scrolled to near the left edge (first ~20 candles visible)
                if (logicalRange.from < 20 && currentCandles.length > 0) {
                    // Debounce: wait 500ms before triggering load to avoid rapid-fire requests
                    clearTimeout(loadHistoryDebounceTimer);
                    loadHistoryDebounceTimer = setTimeout(() => {
                        loadMoreHistory();
                    }, 500);
                }
            });
            
            async function loadMoreHistory() {
                if (isLoadingHistory || noMoreHistory || currentCandles.length === 0) return;
                
                isLoadingHistory = true;
                // console.log('[History] Loading more history...');
                
                // Add timeout to prevent infinite hang
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    controller.abort();
                    console.warn('[History] Request timed out after 10s');
                }, 10000);
                
                try {
                    // Get timestamp of the oldest candle (convert back to ms)
                    const oldestTime = currentCandles[0].time * 1000;
                    
                    // Fetch older candles using smart-history endpoint (checks DB first, then API)
                    const response = await fetch(
                        `${MARKET_API}/bybit/klines/smart-history?symbol=${currentSymbol}&interval=${currentTimeframe}&end_time=${oldestTime}&limit=200`,
                        { signal: controller.signal }
                    );
                    
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        const data = await response.json();
                        
                        if (data && Array.isArray(data) && data.length > 0) {
                            // Sort by time ascending
                            const sortedData = [...data].sort((a, b) => a.open_time - b.open_time);
                            
                            // Filter out candles we already have
                            const existingTimes = new Set(currentCandles.map(c => c.time));
                            const newCandles = sortedData
                                .filter(k => !existingTimes.has(Math.floor(k.open_time / 1000)))
                                .map(k => ({
                                    time: Math.floor(k.open_time / 1000),
                                    open: parseFloat(k.open),
                                    high: parseFloat(k.high),
                                    low: parseFloat(k.low),
                                    close: parseFloat(k.close)
                                }));
                            
                            const newVolumes = sortedData
                                .filter(k => !existingTimes.has(Math.floor(k.open_time / 1000)))
                                .map(k => ({
                                    time: Math.floor(k.open_time / 1000),
                                    value: parseFloat(k.volume),
                                    color: parseFloat(k.close) >= parseFloat(k.open) ? '#00c853' : '#ff1744'
                                }));
                            
                            if (newCandles.length === 0) {
                                // console.log('[History] No new candles, reached beginning');
                                noMoreHistory = true;
                            } else {
                                // Prepend new candles to existing data
                                currentCandles = [...newCandles, ...currentCandles];
                                const normalizedNewVolumes = normalizeVolumes(newVolumes);
                                currentVolumes = [...normalizedNewVolumes, ...currentVolumes];
                                rawVolumes = [...newVolumes, ...rawVolumes];
                                
                                // Update charts
                                candleSeries.setData(currentCandles);
                                volumeSeries.setData(currentVolumes);
                                
                                // console.log('[History] Added', newCandles.length, 'candles, total:', currentCandles.length);
                            }
                        } else {
                            // console.log('[History] No more data available');
                            noMoreHistory = true;
                        }
                    }
                } catch (error) {
                    clearTimeout(timeoutId);
                    if (error.name === 'AbortError') {
                        console.warn('[History] Request aborted (timeout)');
                    } else {
                        console.error('[History] Error loading history:', error);
                    }
                }
                
                isLoadingHistory = false;
            }

            // Handle resize
            window.addEventListener('resize', () => {
                resizeCharts();
            });

            // Crosshair sync - prevent infinite loops
            let isSyncingCrosshair = false;

            // Crosshair data display + sync to volume chart
            chart.subscribeCrosshairMove((param) => {
                if (param.time) {
                    const data = param.seriesData.get(candleSeries);
                    if (data) {
                        document.getElementById('ohlcOpen').textContent = formatPrice(data.open);
                        document.getElementById('ohlcHigh').textContent = formatPrice(data.high);
                        document.getElementById('ohlcLow').textContent = formatPrice(data.low);
                        document.getElementById('ohlcClose').textContent = formatPrice(data.close);
                    }
                }
                
                // Sync crosshair to volume chart
                if (!isSyncingCrosshair && volumeChart) {
                    isSyncingCrosshair = true;
                    if (param.time) {
                        // Use the cursor y-coordinate when available; some LightweightCharts internals
                        // will throw if passed an invalid/null price coordinate.
                        const y = (typeof param.point?.y === 'number') ? param.point.y : null;
                        if (y !== null && volumeSeries) {
                            try {
                                volumeChart.setCrosshairPosition(y, param.time, volumeSeries);
                            } catch (e) {
                                // Never let crosshair sync crash the page
                                // (Playwright treats pageerror as a test failure)
                                // console.warn('[CrosshairSync] volumeChart setCrosshairPosition failed', e);
                            }
                        } else {
                            volumeChart.clearCrosshairPosition();
                        }
                    } else {
                        volumeChart.clearCrosshairPosition();
                    }
                    isSyncingCrosshair = false;
                }
            });

            // Sync crosshair from volume chart to main chart
            volumeChart.subscribeCrosshairMove((param) => {
                if (!isSyncingCrosshair && chart) {
                    isSyncingCrosshair = true;
                    if (param.time) {
                        const y = (typeof param.point?.y === 'number') ? param.point.y : null;
                        if (y !== null && candleSeries) {
                            try {
                                chart.setCrosshairPosition(y, param.time, candleSeries);
                            } catch (e) {
                                // console.warn('[CrosshairSync] chart setCrosshairPosition failed', e);
                            }
                        } else {
                            chart.clearCrosshairPosition();
                        }
                    } else {
                        chart.clearCrosshairPosition();
                    }
                    isSyncingCrosshair = false;
                }
            });
        }

        async function loadCandleData() {
            const startTime = performance.now();
            updateVolumeIndicators();
            
            showLoading(true);
            isLoadingData = true;  // Prevent sync errors
            
            try {
                // Use Smart Kline Service - uses RAM cache → DB → API (fast)
                // WebSocket will keep data fresh in real-time
                // console.log('[Chart] Fetching data via smart service...');
                const DEFAULT_CANDLE_LIMIT = 300;
                
                // Add timeout to prevent infinite hang (60 second timeout for initial load / slower timeframes)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);
                
                // Always use force_fresh=true to ensure we get the latest candle data
                const response = await fetch(
                    `${MARKET_API}/bybit/klines/smart?symbol=${currentSymbol}&interval=${currentTimeframe}&limit=${DEFAULT_CANDLE_LIMIT}&force_fresh=true`,
                    { signal: controller.signal }
                );
                clearTimeout(timeoutId);
                
                // console.log('[Chart] Fetch took', (performance.now() - startTime).toFixed(0), 'ms');
                
                if (response.ok) {
                    const data = await response.json();
                    // console.log('[Chart] API response:', data?.length, 'candles, total time:', (performance.now() - startTime).toFixed(0), 'ms');
                    
                    if (data && Array.isArray(data) && data.length > 0) {
                        // Sort by time ascending (oldest first) - API returns newest first
                        const sortedData = [...data].sort((a, b) => a.open_time - b.open_time);
                        
                        const candles = sortedData.map(k => ({
                            time: Math.floor(k.open_time / 1000),  // Convert ms to seconds for chart
                            open: parseFloat(k.open),
                            high: parseFloat(k.high),
                            low: parseFloat(k.low),
                            close: parseFloat(k.close)
                        }));
                        
                        const volumes = sortedData.map(k => ({
                            time: Math.floor(k.open_time / 1000),
                            value: parseFloat(k.volume),
                            color: parseFloat(k.close) >= parseFloat(k.open) ? '#00c853' : '#ff1744'
                        }));
                        
                        // No normalization - show real volume proportions
                        const normalizedVolumes = normalizeVolumes(volumes);
                        rawVolumes = volumes;  // Keep raw for reference
                        
                        // console.log('[Chart] Setting', candles.length, 'candles, first:', candles[0]?.time, 'last:', candles[candles.length-1]?.time);
                        // console.log('[Chart] candleSeries exists:', !!candleSeries, 'volumeSeries exists:', !!volumeSeries);
                        
                        try {
                            hideChartError(); // Clear any previous error overlay
                            candleSeries.setData(candles);
                            currentCandles = candles;  // Store for mock updates
                            // console.log('[Chart] Candles set successfully');
                            safeSetData(volumeSeries, normalizedVolumes, 'volumeSeries (initial load)');
                            currentVolumes = normalizedVolumes;  // Store for mock updates
                            // console.log('[Chart] Volumes set successfully (normalized)');
                            
                            // Apply volume indicators (SMA, EMA, BB, VWAP etc.)
                            applyVolumeIndicators();
                            // console.log('[Chart] Volume indicators applied');
                            
                            // Re-apply any active indicators after data load
                            if (activeIndicators.size > 0) {
                                // console.log('[Chart] Re-applying', activeIndicators.size, 'active indicators');
                                activeIndicators.forEach(ind => addIndicator(ind));
                            }
                        } catch (setDataError) {
                            console.error('[Chart] setData error:', setDataError);
                        }
                        
                        updatePriceDisplay(candles[candles.length - 1]);
                        isLoadingData = false;  // Re-enable sync
                        showLoading(false);
                        // console.log('[Chart] Loading hidden');
                        
                        // Start mock price updates (will be stopped if real WebSocket data arrives)

                        return;
                    } else {
                        console.warn('[Chart] Invalid data format:', typeof data, data);
                    }
                } else {
                    console.error('[Chart] API error:', response.status, response.statusText);
                }
            } catch (error) {
                console.error('[Chart] Fetch error:', error);
                showChartError('Не удалось загрузить данные. Проверьте подключение к серверу.');
            }
            
            // Ensure globals are always initialized (for Playwright tests etc.)
            if (!currentCandles || !Array.isArray(currentCandles)) {
                currentCandles = [];
            }
            if (!currentVolumes || !Array.isArray(currentVolumes)) {
                currentVolumes = [];
            }
            
            isLoadingData = false;
            showLoading(false);
        }
        
        // Показать ошибку на графике
        function showChartError(message) {
            const container = document.querySelector('.chart-container') || document.getElementById('chart')?.parentElement;
            let overlay = container.querySelector('.chart-error-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.className = 'chart-error-overlay';
                overlay.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#ff4444;font-size:14px;text-align:center;background:#1e222d;padding:20px;border-radius:8px;border:1px solid #363a45;z-index:100;';
                container.style.position = 'relative';
                container.appendChild(overlay);
            }
            overlay.textContent = message;
        }
        
        // Hide chart error overlay
        function hideChartError() {
            const container = document.querySelector('.chart-container') || document.getElementById('chart')?.parentElement;
            if (!container) return;
            const overlay = container.querySelector('.chart-error-overlay');
            if (overlay) {
                overlay.remove();
            }
        }
        
        // Smart Kline Service - Initialize symbol with 12 months history
        async function initializeSymbolData(symbol, interval) {
            try {
                // console.log(`[Smart] Initializing ${symbol} with interval ${interval}`);
                const response = await fetch(
                    `${MARKET_API}/bybit/symbol/initialize?symbol=${symbol}&interval=${interval}&load_history=true&load_adjacent=true`,
                    { method: 'POST' }
                );
                
                if (response.ok) {
                    const data = await response.json();
                    // console.log('[Smart] Initialization response:', data);
                    
                    // Show loading status in console
                    if (data.intervals_loading && data.intervals_loading.length > 0) {
                        // console.log(`[Smart] Background loading: ${data.intervals_loading.join(', ')}`);
                    }
                    if (data.intervals_loaded && data.intervals_loaded.length > 0) {
                        // console.log(`[Smart] Already cached: ${data.intervals_loaded.join(', ')}`);
                    }
                    if (data.db_coverage) {
                        for (const [tf, info] of Object.entries(data.db_coverage)) {
                            if (info) {
                                // console.log(`[Smart] DB ${tf}: ${info.count} candles`);
                            }
                        }
                    }
                } else {
                    console.warn('[Smart] Initialization failed:', response.status);
                }
            } catch (error) {
                console.error('[Smart] Initialization error:', error);
            }
        }
        
        // Check loading status periodically
        async function checkLoadingStatus() {
            try {
                const response = await fetch(`${MARKET_API}/bybit/symbol/loading-progress`);
                if (response.ok) {
                    const data = await response.json();
                    const loading = Object.values(data).filter(p => p.status === 'loading');
                    if (loading.length > 0) {
                    }
                }
            } catch (e) {
                // Ignore errors
            }
        }

        function updatePriceDisplay(lastCandle, priceChangePercent = null) {
            if (!lastCandle) return;
            
            // Update currentRealPrice for pressure indicator fallback
            if (lastCandle.close) {
                currentRealPrice = lastCandle.close;
            }
            
            const priceEl = document.getElementById('currentPrice');
            const changeEl = document.getElementById('priceChange');
            
            priceEl.textContent = formatPrice(lastCandle.close);
            
            // Используем реальное изменение если доступно, иначе скрываем
            if (priceChangePercent !== null) {
                const change = priceChangePercent;
                const changeValue = lastCandle.close * change / 100;
                
                if (change >= 0) {
                    priceEl.className = 'current-price up';
                    changeEl.className = 'price-change positive';
                    changeEl.innerHTML = `<span>+${change.toFixed(2)}%</span> <span>+${formatPrice(changeValue)}</span>`;
                } else {
                    priceEl.className = 'current-price down';
                    changeEl.className = 'price-change negative';
                    changeEl.innerHTML = `<span>${change.toFixed(2)}%</span> <span>${formatPrice(changeValue)}</span>`;
                }
            } else {
                // Нет данных о изменении - используем направление свечи (close vs open)
                const isUp = lastCandle.close >= lastCandle.open;
                priceEl.className = 'current-price ' + (isUp ? 'up' : 'down');
                changeEl.innerHTML = '';
            }
            
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }

        function setupEventListeners() {
            // Timeframe buttons
            document.querySelectorAll('.tf-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const oldTimeframe = currentTimeframe;
                    document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    currentTimeframe = e.target.dataset.tf;
                    
                    // Save to localStorage
                    localStorage.setItem('chart_timeframe', currentTimeframe);
                    
                    // Reset history scroll flag for new timeframe
                    noMoreHistory = false;
                    
                    // Resubscribe WebSocket to new timeframe kline
                    if (bybitWs && bybitWs.readyState === WebSocket.OPEN) {
                        bybitWs.send(JSON.stringify({
                            op: 'unsubscribe',
                            args: [`kline.${oldTimeframe}.${currentSymbol}`]
                        }));
                        bybitWs.send(JSON.stringify({
                            op: 'subscribe',
                            args: [`kline.${currentTimeframe}.${currentSymbol}`]
                        }));
                    }
                    
                    loadCandleData();
                });
            });

            // Tool buttons
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    // Would implement drawing tools here
                });
            });

            // Panel tabs
            document.querySelectorAll('.panel-tab').forEach(tab => {
                tab.addEventListener('click', (e) => {
                    document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    const panel = e.target.dataset.panel;
                    
                    // Hide all panels first
                    document.getElementById('orderbookPanel').classList.add('hidden-panel');
                    document.getElementById('tradesPanel').classList.add('hidden-panel');
                    document.getElementById('statsPanel').classList.add('hidden-panel');
                    
                    // Show selected panel
                    if (panel === 'orderbook') {
                        document.getElementById('orderbookPanel').classList.remove('hidden-panel');
                    } else if (panel === 'trades') {
                        document.getElementById('tradesPanel').classList.remove('hidden-panel');
                    } else if (panel === 'stats') {
                        document.getElementById('statsPanel').classList.remove('hidden-panel');
                    }
                });
            });
        }

        // Store current real price for order book
        let currentRealPrice = 97234.50;
        let lastOrderBookUpdate = 0;
        let lastOrderBookProcess = 0;
        const ORDER_BOOK_THROTTLE = 500;  // Update order book max every 500ms (2 times/sec) to prevent lag
        const ORDER_BOOK_PROCESS_THROTTLE = 100;  // Process deltas max 10 times/sec
        
        // Cache DOM elements for efficient updates (avoid innerHTML)
        let cachedAskRows = [];
        let cachedBidRows = [];
        let orderbookInitialized = false;
        
        // Real orderbook data storage
        let orderbookAsks = new Map();  // price -> size
        let orderbookBids = new Map();  // price -> size
        let pendingOrderBookRender = false;
        
        // Handle real Bybit orderbook data
        function handleBybitOrderbook(type, data) {
            if (!data) return;
            
            const processTime = Date.now();
            
            // type = 'snapshot' or 'delta'
            // data = { s: symbol, a: [[price, size], ...], b: [[price, size], ...], u: updateId }
            
            // For deltas, skip if processed too recently (snapshots always processed)
            // BUG FIX: Never throttle DATA processing, only RENDER processing. Dropping deltas corrupts state.
            /*
            if (type === 'delta' && processTime - lastOrderBookProcess < ORDER_BOOK_PROCESS_THROTTLE) {
                return;  // Skip this delta, will catch up on next
            }
            */
            lastOrderBookProcess = processTime;
            
            if (type === 'snapshot') {
                // Full snapshot - replace everything
                orderbookAsks.clear();
                orderbookBids.clear();
                
                if (data.a) {
                    data.a.forEach(([price, size]) => {
                        const p = parseFloat(price);
                        const s = parseFloat(size);
                        if (s > 0) orderbookAsks.set(p, s);
                    });
                }
                
                if (data.b) {
                    data.b.forEach(([price, size]) => {
                        const p = parseFloat(price);
                        const s = parseFloat(size);
                        if (s > 0) orderbookBids.set(p, s);
                    });
                }
            } else if (type === 'delta') {
                // Delta update - modify existing entries
                if (data.a) {
                    data.a.forEach(([price, size]) => {
                        const p = parseFloat(price);
                        const s = parseFloat(size);
                        if (s === 0) {
                            orderbookAsks.delete(p);
                        } else {
                            orderbookAsks.set(p, s);
                        }
                    });
                }
                
                if (data.b) {
                    data.b.forEach(([price, size]) => {
                        const p = parseFloat(price);
                        const s = parseFloat(size);
                        if (s === 0) {
                            orderbookBids.delete(p);
                        } else {
                            orderbookBids.set(p, s);
                        }
                    });
                }
                
                // Limit Map size to 50 levels (prevent memory leak)
                const MAX_ORDERBOOK_LEVELS = 50;
                if (orderbookAsks.size > MAX_ORDERBOOK_LEVELS) {
                    const sortedAsks = Array.from(orderbookAsks.keys()).sort((a, b) => a - b);
                    sortedAsks.slice(MAX_ORDERBOOK_LEVELS).forEach(p => orderbookAsks.delete(p));
                }
                if (orderbookBids.size > MAX_ORDERBOOK_LEVELS) {
                    const sortedBids = Array.from(orderbookBids.keys()).sort((a, b) => b - a);
                    sortedBids.slice(MAX_ORDERBOOK_LEVELS).forEach(p => orderbookBids.delete(p));
                }
            }
            
            // Throttled render using requestAnimationFrame
            if (!pendingOrderBookRender) {
                pendingOrderBookRender = true;
                requestAnimationFrame(() => {
                    const now = Date.now();
                    if (now - lastOrderBookUpdate >= ORDER_BOOK_THROTTLE) {
                        renderRealOrderBook();
                        lastOrderBookUpdate = now;
                    }
                    pendingOrderBookRender = false;
                });
            }
        }
        
        function renderRealOrderBook() {
            // Bybit orderbook.50 - show 16 levels
            const DISPLAY_LEVELS = 16;
            
            // Sort asks ascending (lowest first - closest to market)
            const sortedAsks = Array.from(orderbookAsks.entries())
                .sort((a, b) => a[0] - b[0])
                .slice(0, DISPLAY_LEVELS);
            
            // Sort bids descending (highest first - closest to market)
            const sortedBids = Array.from(orderbookBids.entries())
                .sort((a, b) => b[0] - a[0])
                .slice(0, DISPLAY_LEVELS);
            
            // Calculate cumulative totals
            let askTotal = 0;
            const asks = sortedAsks.map(([price, size]) => {
                askTotal += size;
                return { price, size, total: askTotal };
            });
            
            let bidTotal = 0;
            const bids = sortedBids.map(([price, size]) => {
                bidTotal += size;
                return { price, size, total: bidTotal };
            });
            
            // Reverse asks so highest (furthest) is at top, lowest (closest) at bottom near spread
            renderOrderBook(asks.reverse(), bids);
        }
        

        // Optimized renderOrderBook - updates existing DOM elements instead of innerHTML
        function renderOrderBook(asks, bids) {
            const asksEl = document.getElementById('asks');
            const bidsEl = document.getElementById('bids');
            if (!asksEl || !bidsEl) return;
            
            const maxTotal = Math.max(
                ...asks.map(a => a.total),
                ...bids.map(b => b.total),
                1  // prevent division by zero
            );
            
            // Initialize rows once if needed
            if (!orderbookInitialized || cachedAskRows.length !== asks.length) {
                initOrderBookRows(asksEl, bidsEl, asks.length, bids.length);
            }
            
                // Update asks - only modify changed values (no innerHTML)
            // TRANSFROM OPTIMIZATION: Use scaleX instead of width
            // VIRTUAL DOM OPTIMIZATION: Check JS cache instead of DOM textContent
            for (let i = 0; i < asks.length && i < cachedAskRows.length; i++) {
                const row = cachedAskRows[i];
                const ask = asks[i];
                const scale = ask.total / maxTotal; // 0 to 1
                
                // Update Bar (Composite only)
                if (Math.abs((row._lastScale || 0) - scale) > 0.001) {
                    row.bgBar.style.transform = `scaleX(${scale})`;
                    row._lastScale = scale;
                }
                
                // Update Text (Layout/Paint) - check primitives first to avoid expensive formatting
                if (row._lastPrice !== ask.price) {
                    const newPriceStr = formatPrice(ask.price);
                    row.priceEl.textContent = newPriceStr;
                    row._lastPriceStr = newPriceStr;
                    row._lastPrice = ask.price;
                }
                
                if (row._lastSize !== ask.size) {
                    const newSizeStr = ask.size.toFixed(4);
                    row.sizeEl.textContent = newSizeStr;
                    row._lastSizeStr = newSizeStr;
                    row._lastSize = ask.size;
                }
                
                if (row._lastTotal !== ask.total) {
                    const newTotalStr = ask.total.toFixed(4);
                    row.totalEl.textContent = newTotalStr;
                    row._lastTotalStr = newTotalStr;
                    row._lastTotal = ask.total;
                }
            }
            
            // Update bids - only modify changed values
            for (let i = 0; i < bids.length && i < cachedBidRows.length; i++) {
                const row = cachedBidRows[i];
                const bid = bids[i];
                const scale = bid.total / maxTotal; // 0 to 1
                
                // Update Bar
                if (Math.abs((row._lastScale || 0) - scale) > 0.001) {
                    row.bgBar.style.transform = `scaleX(${scale})`;
                    row._lastScale = scale;
                }
                
                // Update Text - check primitives first
                if (row._lastPrice !== bid.price) {
                    const newPriceStr = formatPrice(bid.price);
                    row.priceEl.textContent = newPriceStr;
                    row._lastPriceStr = newPriceStr;
                    row._lastPrice = bid.price;
                }
                
                if (row._lastSize !== bid.size) {
                    const newSizeStr = bid.size.toFixed(4);
                    row.sizeEl.textContent = newSizeStr;
                    row._lastSizeStr = newSizeStr;
                    row._lastSize = bid.size;
                }
                
                if (row._lastTotal !== bid.total) {
                    const newTotalStr = bid.total.toFixed(4);
                    row.totalEl.textContent = newTotalStr;
                    row._lastTotalStr = newTotalStr;
                    row._lastTotal = bid.total;
                }
            }
            
            // Update spread
            if (asks.length > 0 && bids.length > 0) {
                const spread = asks[asks.length - 1].price - bids[0].price;
                const spreadPct = (spread / asks[asks.length - 1].price) * 100;
                const spreadText = `${formatPrice(spread)} (${spreadPct.toFixed(4)}%)`;
                
                const spreadEl = document.getElementById('spread');
                // Use custom prop on element for cache
                if (spreadEl && spreadEl._lastText !== spreadText) {
                    spreadEl.textContent = spreadText;
                    spreadEl._lastText = spreadText;
                }
            }
            
            // Update depth scale bar
            const totalAskVolume = asks.reduce((sum, a) => sum + a.total, 0);
            const totalBidVolume = bids.reduce((sum, b) => sum + b.total, 0);
            const totalVolume = totalAskVolume + totalBidVolume;
            
            if (totalVolume > 0) {
                const sellPct = (totalAskVolume / totalVolume) * 100;
                const buyPct = (totalBidVolume / totalVolume) * 100;
                
                const sellBar = document.getElementById('depthSellBar');
                const buyBar = document.getElementById('depthBuyBar');
                const sellLabel = document.getElementById('depthSellLabel');
                const buyLabel = document.getElementById('depthBuyLabel');
                
                // Only update if changed significantly (>0.5%)
                if (sellBar && Math.abs((sellBar._lastPct || 0) - sellPct) > 0.5) {
                    sellBar.style.width = sellPct + '%'; // Keep width for this one (flexbox) or switch to flex-grow?
                    // Width is fine for flex items usually, but flex-basis is better.
                    // For now keep width as it's not the main bottleneck (only 2 elements).
                    sellBar._lastPct = sellPct;
                    if (sellLabel) sellLabel.textContent = sellPct.toFixed(0) + '%';
                }
                if (buyBar && Math.abs((buyBar._lastPct || 0) - buyPct) > 0.5) {
                    buyBar.style.width = buyPct + '%';
                    buyBar._lastPct = buyPct;
                    if (buyLabel) buyLabel.textContent = buyPct.toFixed(0) + '%';
                }
            }

            
            // Update pressure indicator - single price with dynamic color based on direction
            // Use mid-market price if orderbook data available, otherwise fall back to currentRealPrice
            let newPrice = null;
            if (asks.length > 0 && bids.length > 0) {
                const bestAsk = asks[asks.length - 1].price;  // Lowest ask
                const bestBid = bids[0].price;                // Highest bid
                newPrice = (bestAsk + bestBid) / 2;           // Mid-market price
            } else if (currentRealPrice) {
                // Fallback to last known ticker price if orderbook is empty
                newPrice = currentRealPrice;
            }
            
            if (newPrice !== null) {
                const priceEl = document.getElementById('pressurePrice');
                const arrowEl = document.getElementById('pressureArrow');
                
                if (priceEl && arrowEl) {
                    const oldPrice = window._lastPressurePrice || newPrice;
                    window._lastPressurePrice = newPrice;
                    
                    // Determine direction
                    const isUp = newPrice >= oldPrice;
                    
                    // Update arrow and color
                    const newArrow = isUp ? '↑' : '↓';
                    const newClass = 'pressure-arrow ' + (isUp ? 'buy' : 'sell');
                    const newPriceClass = 'pressure-price ' + (isUp ? 'buy' : 'sell');
                    const newPriceText = formatPrice(newPrice).replace('$', '');

                    // Use arrowEl custom cache
                    if (arrowEl._lastText !== newArrow) {
                        arrowEl.textContent = newArrow;
                        arrowEl._lastText = newArrow;
                    }
                    if (arrowEl._lastClass !== newClass) {
                        arrowEl.className = newClass;
                        arrowEl._lastClass = newClass;
                    }
                    if (priceEl._lastClass !== newPriceClass) {
                        priceEl.className = newPriceClass;
                        priceEl._lastClass = newPriceClass;
                    }
                    if (priceEl._lastText !== newPriceText) {
                        priceEl.textContent = newPriceText;
                        priceEl._lastText = newPriceText;
                    }
                }
            }
        }
        
        // Initialize orderbook rows once - create static DOM elements
        function initOrderBookRows(asksEl, bidsEl, askCount, bidCount) {
            // Clear and create ask rows
            asksEl.innerHTML = '';
            cachedAskRows = [];
            for (let i = 0; i < askCount; i++) {
                const row = document.createElement('div');
                row.className = 'orderbook-row ask';
                row.innerHTML = `
                    <span class="bg-bar"></span>
                    <span class="price">0</span>
                    <span style="text-align: right;">0</span>
                    <span style="text-align: right;">0</span>
                `;
                asksEl.appendChild(row);
                cachedAskRows.push({
                    el: row,
                    bgBar: row.querySelector('.bg-bar'),
                    priceEl: row.querySelector('.price'),
                    sizeEl: row.children[2],
                    totalEl: row.children[3],
                    // Cache props
                    _lastScale: 0,
                    _lastPriceStr: '0',
                    _lastSizeStr: '0',
                    _lastTotalStr: '0'
                });
            }
            
            // Clear and create bid rows
            bidsEl.innerHTML = '';
            cachedBidRows = [];
            for (let i = 0; i < bidCount; i++) {
                const row = document.createElement('div');
                row.className = 'orderbook-row bid';
                row.innerHTML = `
                    <span class="bg-bar"></span>
                    <span class="price">0</span>
                    <span style="text-align: right;">0</span>
                    <span style="text-align: right;">0</span>
                `;
                bidsEl.appendChild(row);
                cachedBidRows.push({
                    el: row,
                    bgBar: row.querySelector('.bg-bar'),
                    priceEl: row.querySelector('.price'),
                    sizeEl: row.children[2],
                    totalEl: row.children[3],
                    // Cache props
                    _lastScale: 0,
                    _lastPriceStr: '0',
                    _lastSizeStr: '0',
                    _lastTotalStr: '0'
                });
            }
            
            orderbookInitialized = true;
            // console.log('[OrderBook] Initialized', askCount, 'asks +', bidCount, 'bids rows');
        }
        
        // =====================================================
        // REAL-TIME PUBLIC TRADES HANDLING
        // =====================================================
        
        const MAX_TRADES_DISPLAY = 25;  // Max trades to show in Recent Trades panel
        let recentTrades = [];
        let pendingTradesRender = false;
        
        // Accumulate volume from trades for real-time volume chart updates
        let accumulatedVolume = 0;
        let lastVolumeUpdate = 0;
        const VOLUME_UPDATE_THROTTLE = 200;  // Update volume chart every 200ms
        
        // Throttle for trades processing (skip if too frequent)
        let lastTradeProcessTime = 0;
        const TRADE_PROCESS_THROTTLE = 100;  // Process trades max 10 times/sec
        
        function handleBybitTrades(data) {
            if (!data || !Array.isArray(data)) return;
            
            // Throttle trade processing to reduce CPU load
            const processNow = Date.now();
            if (processNow - lastTradeProcessTime < TRADE_PROCESS_THROTTLE) {
                return;  // Skip this batch, will catch up on next
            }
            lastTradeProcessTime = processNow;
            
            // Bybit sends array of trades: [{T, s, S, v, p, L, i}, ...]
            // T = timestamp, s = symbol, S = side (Buy/Sell), v = size, p = price, L = tick direction
            
            let tradeVolume = 0;
            data.forEach(trade => {
                const size = parseFloat(trade.v);
                tradeVolume += size;
                
                recentTrades.unshift({
                    time: trade.T,
                    price: parseFloat(trade.p),
                    size: size,
                    side: trade.S,  // 'Buy' or 'Sell'
                    id: trade.i
                });
            });
            
            // Accumulate volume for current candle
            accumulatedVolume += tradeVolume;
            
            // Throttled volume chart update
            const now = Date.now();
            if (now - lastVolumeUpdate >= VOLUME_UPDATE_THROTTLE && currentCandles.length > 0) {
                lastVolumeUpdate = now;
                updateVolumeFromTrades();
            }
            
            // Keep only last MAX_TRADES_DISPLAY trades
            if (recentTrades.length > MAX_TRADES_DISPLAY) {
                recentTrades = recentTrades.slice(0, MAX_TRADES_DISPLAY);
            }
            
            // Throttled render (max 2 times/sec for performance)
            const nowTrades = Date.now();
            if (!pendingTradesRender && nowTrades - lastTradesRender >= 500) {
                pendingTradesRender = true;
                lastTradesRender = nowTrades;
                requestAnimationFrame(() => {
                    renderRecentTrades();
                    pendingTradesRender = false;
                });
            }
        }
        
        let lastTradesRender = 0;
        
        // Update volume chart with accumulated trade volume
        // Note: This is for visual smoothness between kline updates only
        // Kline provides authoritative volume, trades just add visual delta
        function updateVolumeFromTrades() {
            if (currentCandles.length === 0 || !currentVolumes || currentVolumes.length === 0) return;
            
            const lastIdx = currentVolumes.length - 1;
            const lastVolume = currentVolumes[lastIdx];
            const lastCandle = currentCandles[currentCandles.length - 1];
            
            // Get direction from current candle
            const isBullish = lastCandle.close >= lastCandle.open;
            
            // Update volume with accumulated trades (visual only, don't persist)
            // Use baseVolume to avoid compounding
            const baseVolume = lastVolume._baseValue !== undefined ? lastVolume._baseValue : lastVolume.value;
            const updatedVolume = {
                time: lastVolume.time,
                value: baseVolume + accumulatedVolume,
                color: isBullish ? '#00c853' : '#ff1744',
                _baseValue: baseVolume  // Store original kline volume
            };
            
            try {
                volumeSeries.update(updatedVolume);
                // DON'T update currentVolumes here - kline will provide authoritative value
                // currentVolumes[lastIdx] = updatedVolume;  // REMOVED - caused compounding
            } catch (e) {
                console.error('[Volume] Update error:', e);
            }
            
            // Don't reset accumulatedVolume here - it accumulates until kline resets it
        }
        
        // Cache for trades DOM elements
        let cachedTradeRows = [];
        let tradesInitialized = false;
        const TRADES_DISPLAY_COUNT = 30;  // Reduced from 50 for performance
        
        // Optimized renderRecentTrades - updates existing DOM elements
        function renderRecentTrades() {
            const tradesListEl = document.getElementById('tradesList');
            if (!tradesListEl) return;
            
            // Initialize rows once
            if (!tradesInitialized || cachedTradeRows.length < TRADES_DISPLAY_COUNT) {
                initTradeRows(tradesListEl);
            }
            
            // Update only visible rows
            const displayCount = Math.min(recentTrades.length, TRADES_DISPLAY_COUNT);
            for (let i = 0; i < cachedTradeRows.length; i++) {
                const row = cachedTradeRows[i];
                if (i < displayCount) {
                    const trade = recentTrades[i];
                    const time = new Date(trade.time).toLocaleTimeString('en-US', { 
                        hour12: false, 
                        hour: '2-digit', 
                        minute: '2-digit', 
                        second: '2-digit' 
                    });
                    
                    // Update class only if side changed
                    const newClass = trade.side === 'Buy' ? 'trade-row buy' : 'trade-row sell';
                    if (row.el.className !== newClass) {
                        row.el.className = newClass;
                    }
                    
                    row.priceEl.textContent = formatPrice(trade.price);
                    row.sizeEl.textContent = trade.size.toFixed(4);
                    row.timeEl.textContent = time;
                    row.el.style.display = '';
                } else {
                    // Hide unused rows
                    row.el.style.display = 'none';
                }
            }
        }
        
        // Initialize trade rows once
        function initTradeRows(container) {
            container.innerHTML = '';
            cachedTradeRows = [];
            
            for (let i = 0; i < TRADES_DISPLAY_COUNT; i++) {
                const row = document.createElement('div');
                row.className = 'trade-row buy';
                row.innerHTML = `
                    <span class="trade-price">0</span>
                    <span class="trade-size">0</span>
                    <span class="trade-time">00:00:00</span>
                `;
                container.appendChild(row);
                cachedTradeRows.push({
                    el: row,
                    priceEl: row.querySelector('.trade-price'),
                    sizeEl: row.querySelector('.trade-size'),
                    timeEl: row.querySelector('.trade-time')
                });
            }
            
            tradesInitialized = true;
            // console.log('[Trades] Initialized', TRADES_DISPLAY_COUNT, 'trade rows');
        }

        // Indicator functions
        let indicatorsModalPosition = null;
        
        function openIndicatorsModal() {
            const modal = document.getElementById('indicatorsModal');
            const content = document.getElementById('indicatorsModalContent');
            
            modal.classList.remove('hidden');
            modal.style.cssText = 'display: block !important; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 9999; pointer-events: none;';
            
            // Position content - use saved position or center
            if (indicatorsModalPosition) {
                content.style.cssText = `display: block !important; position: fixed; left: ${indicatorsModalPosition.x}px; top: ${indicatorsModalPosition.y}px; z-index: 10000; pointer-events: auto; cursor: default;`;
            } else {
                // Center on screen
                const rect = content.getBoundingClientRect();
                const x = (window.innerWidth - 400) / 2;
                const y = (window.innerHeight - rect.height) / 2;
                content.style.cssText = `display: block !important; position: fixed; left: ${x}px; top: ${Math.max(50, y)}px; z-index: 10000; pointer-events: auto; cursor: default;`;
            }
            
            // Initialize dragging if not already done
            if (!content.dataset.dragInitialized) {
                initIndicatorsDrag(content);
                content.dataset.dragInitialized = 'true';
            }
        }

        function closeIndicatorsModal() {
            const modal = document.getElementById('indicatorsModal');
            const content = document.getElementById('indicatorsModalContent');
            
            // Save position before closing
            if (content.style.left && content.style.top) {
                indicatorsModalPosition = {
                    x: parseInt(content.style.left),
                    y: parseInt(content.style.top)
                };
            }
            
            modal.classList.add('hidden');
            modal.style.display = 'none';
        }
        
        function initIndicatorsDrag(content) {
            const header = content.querySelector('.modal-header');
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            header.style.cursor = 'move';
            
            header.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('modal-close')) return;
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                initialX = parseInt(content.style.left) || 0;
                initialY = parseInt(content.style.top) || 0;
                content.classList.add('dragging');
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                content.style.left = (initialX + dx) + 'px';
                content.style.top = (initialY + dy) + 'px';
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    content.classList.remove('dragging');
                }
            });
        }

        function toggleIndicator(indicator) {
            const toggle = document.getElementById(`toggle-${indicator}`);
            
            if (activeIndicators.has(indicator)) {
                activeIndicators.delete(indicator);
                toggle.classList.remove('active');
                removeIndicator(indicator);
            } else {
                activeIndicators.add(indicator);
                toggle.classList.add('active');
                addIndicator(indicator);
            }
            
            // Save indicator preferences
            saveIndicators();
        }

        function addIndicator(indicator) {
            const data = currentCandles;  // Use stored data instead of candleSeries.data()
            // console.log('[Indicator] Adding:', indicator, 'Data length:', data?.length, 'Chart:', !!chart);
            
            if (!data || data.length === 0) {
                console.warn('[Indicator] No candle data available for:', indicator);
                return;
            }
            
            if (!chart) {
                console.warn('[Indicator] Chart not initialized for:', indicator);
                return;
            }

            try {
                switch (indicator) {
                    case 'sma':
                        addSMA(data, 20, '#58a6ff');
                        addSMA(data, 50, '#d29922');
                        addSMA(data, 200, '#a371f7');
                        break;
                    case 'ema':
                        addEMA(data, 12, '#3fb950');
                        addEMA(data, 26, '#f85149');
                        break;
                    case 'bb':
                        addBollingerBands(data);
                        break;
                    case 'rsi':
                        addRSI(data, 14);
                        break;
                    case 'macd':
                        addMACD(data, 12, 26, 9);
                        break;
                    case 'vwap':
                        addVWAP(data);
                        break;
                    case 'stoch':
                        addStochastic(data, 14, 3, 3);
                        break;
                    case 'atr':
                        addATR(data, 14);
                        break;
                    case 'ichimoku':
                        addIchimoku(data);
                        break;
                    case 'pivots':
                        addPivotPoints(data);
                        break;
                    case 'supertrend':
                        addSuperTrend(data, 10, 3);
                        break;
                }
            } catch (error) {
                console.error('[Indicator] Error adding', indicator, ':', error);
            }
        }

        function addSMA(data, period, color) {
            const smaData = calculateSMA(data, period);
            // console.log('[SMA] Period:', period, 'Data points:', smaData.length);
            const series = chart.addLineSeries({
                color: color,
                lineWidth: 2,
                priceLineVisible: false,
                lastValueVisible: true,
                title: `SMA ${period}`
            });
            series.setData(smaData);
            indicatorSeries[`sma-${period}`] = series;
        }

        function addEMA(data, period, color) {
            const emaData = calculateEMA(data, period);
            // console.log('[EMA] Period:', period, 'Data points:', emaData.length);
            const series = chart.addLineSeries({
                color: color,
                lineWidth: 2,
                priceLineVisible: false,
                lastValueVisible: true,
                title: `EMA ${period}`
            });
            series.setData(emaData);
            indicatorSeries[`ema-${period}`] = series;
        }

        function addBollingerBands(data) {
            const bb = calculateBollingerBands(data, 20, 2);
            // console.log('[BB] Upper:', bb.upper.length, 'Middle:', bb.middle.length, 'Lower:', bb.lower.length);
            
            const upperSeries = chart.addLineSeries({
                color: 'rgba(139, 148, 158, 0.7)',
                lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Solid,
                priceLineVisible: false,
                lastValueVisible: false
            });
            upperSeries.setData(bb.upper);
            indicatorSeries['bb-upper'] = upperSeries;
            
            const middleSeries = chart.addLineSeries({
                color: '#58a6ff',
                lineWidth: 1,
                priceLineVisible: false,
                lastValueVisible: true,
                title: 'BB Mid'
            });
            middleSeries.setData(bb.middle);
            indicatorSeries['bb-middle'] = middleSeries;
            
            const lowerSeries = chart.addLineSeries({
                color: 'rgba(139, 148, 158, 0.7)',
                lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Solid,
                priceLineVisible: false,
                lastValueVisible: false
            });
            lowerSeries.setData(bb.lower);
            indicatorSeries['bb-lower'] = lowerSeries;
        }

        // RSI - displayed as overlay line on main chart (scaled to price range)
        function addRSI(data, period) {
            const rsiData = calculateRSI(data, period);
            // Create RSI line on volume chart area (since it's 0-100 scale)
            const rsiSeries = volumeChart.addLineSeries({
                color: '#a855f7',
                lineWidth: 2,
                priceScaleId: 'rsi',
                priceLineVisible: false,
                lastValueVisible: true
            });
            volumeChart.priceScale('rsi').applyOptions({
                scaleMargins: { top: 0.1, bottom: 0.1 },
                visible: false
            });
            rsiSeries.setData(rsiData);
            indicatorSeries['rsi'] = rsiSeries;
            
            // Add overbought/oversold lines
            const rsi70 = data.map(d => ({ time: d.time, value: 70 }));
            const rsi30 = data.map(d => ({ time: d.time, value: 30 }));
            
            const rsi70Series = volumeChart.addLineSeries({
                color: '#f85149',
                lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Dotted,
                priceScaleId: 'rsi',
                priceLineVisible: false,
                lastValueVisible: false
            });
            rsi70Series.setData(rsi70);
            indicatorSeries['rsi-70'] = rsi70Series;
            
            const rsi30Series = volumeChart.addLineSeries({
                color: '#3fb950',
                lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Dotted,
                priceScaleId: 'rsi',
                priceLineVisible: false,
                lastValueVisible: false
            });
            rsi30Series.setData(rsi30);
            indicatorSeries['rsi-30'] = rsi30Series;
        }

        // MACD - histogram + signal lines
        function addMACD(data, fast, slow, signal) {
            const macdResult = calculateMACD(data, fast, slow, signal);
            
            // MACD histogram on volume chart
            const histogramSeries = volumeChart.addHistogramSeries({
                priceScaleId: 'macd',
                priceLineVisible: false,
                lastValueVisible: false
            });
            histogramSeries.setData(macdResult.histogram);
            indicatorSeries['macd-histogram'] = histogramSeries;
            
            // MACD line
            const macdLine = volumeChart.addLineSeries({
                color: '#58a6ff',
                lineWidth: 1,
                priceScaleId: 'macd',
                priceLineVisible: false,
                lastValueVisible: false
            });
            macdLine.setData(macdResult.macd);
            indicatorSeries['macd-line'] = macdLine;
            
            // Signal line
            const signalLine = volumeChart.addLineSeries({
                color: '#f97316',
                lineWidth: 1,
                priceScaleId: 'macd',
                priceLineVisible: false,
                lastValueVisible: false
            });
            signalLine.setData(macdResult.signal);
            indicatorSeries['macd-signal'] = signalLine;
            
            volumeChart.priceScale('macd').applyOptions({
                scaleMargins: { top: 0.6, bottom: 0 },
                visible: false
            });
        }

        // VWAP - Volume Weighted Average Price
        function addVWAP(data) {
            const vwapData = calculateVWAPIndicator(data);
            const series = chart.addLineSeries({
                color: '#06b6d4',
                lineWidth: 2,
                priceLineVisible: false,
                lastValueVisible: true
            });
            series.setData(vwapData);
            indicatorSeries['vwap'] = series;
        }

        // Stochastic Oscillator
        function addStochastic(data, kPeriod, kSmooth, dPeriod) {
            const stochData = calculateStochastic(data, kPeriod, kSmooth, dPeriod);
            
            const kLine = volumeChart.addLineSeries({
                color: '#3b82f6',
                lineWidth: 1,
                priceScaleId: 'stoch',
                priceLineVisible: false,
                lastValueVisible: false
            });
            kLine.setData(stochData.k);
            indicatorSeries['stoch-k'] = kLine;
            
            const dLine = volumeChart.addLineSeries({
                color: '#f97316',
                lineWidth: 1,
                priceScaleId: 'stoch',
                priceLineVisible: false,
                lastValueVisible: false
            });
            dLine.setData(stochData.d);
            indicatorSeries['stoch-d'] = dLine;
            
            volumeChart.priceScale('stoch').applyOptions({
                scaleMargins: { top: 0.7, bottom: 0 },
                visible: false
            });
        }

        // ATR - Average True Range
        function addATR(data, period) {
            const atrData = calculateATR(data, period);
            const series = volumeChart.addLineSeries({
                color: '#eab308',
                lineWidth: 1,
                priceScaleId: 'atr',
                priceLineVisible: false,
                lastValueVisible: true
            });
            series.setData(atrData);
            indicatorSeries['atr'] = series;
            
            volumeChart.priceScale('atr').applyOptions({
                scaleMargins: { top: 0.8, bottom: 0 },
                visible: false
            });
        }

        // Ichimoku Cloud - Standard (9, 26, 52, 26)
        function addIchimoku(data) {
            const ichimoku = calculateIchimoku(data);
            
            if (ichimoku.tenkan.length === 0) {
                console.warn('[Ichimoku] Not enough data for calculation');
                return;
            }
            
            // Tenkan-sen (Conversion Line) - blue, fast line
            const tenkanSeries = chart.addLineSeries({
                color: '#2563eb',
                lineWidth: 1,
                priceLineVisible: false,
                lastValueVisible: true,
                title: 'Tenkan'
            });
            tenkanSeries.setData(ichimoku.tenkan);
            indicatorSeries['ichimoku-tenkan'] = tenkanSeries;
            
            // Kijun-sen (Base Line) - maroon, slow line
            const kijunSeries = chart.addLineSeries({
                color: '#dc2626',
                lineWidth: 1,
                priceLineVisible: false,
                lastValueVisible: true,
                title: 'Kijun'
            });
            kijunSeries.setData(ichimoku.kijun);
            indicatorSeries['ichimoku-kijun'] = kijunSeries;
            
            // Senkou Span A (Leading Span A) - green cloud boundary
            const senkouASeries = chart.addLineSeries({
                color: 'rgba(34, 197, 94, 0.6)',
                lineWidth: 1,
                priceLineVisible: false,
                lastValueVisible: false
            });
            senkouASeries.setData(ichimoku.senkouA);
            indicatorSeries['ichimoku-senkouA'] = senkouASeries;
            
            // Senkou Span B (Leading Span B) - red cloud boundary
            const senkouBSeries = chart.addLineSeries({
                color: 'rgba(239, 68, 68, 0.6)',
                lineWidth: 1,
                priceLineVisible: false,
                lastValueVisible: false
            });
            senkouBSeries.setData(ichimoku.senkouB);
            indicatorSeries['ichimoku-senkouB'] = senkouBSeries;
            
            // Chikou Span (Lagging Span) - purple, lagging close
            const chikouSeries = chart.addLineSeries({
                color: '#8b5cf6',
                lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Dotted,
                priceLineVisible: false,
                lastValueVisible: false,
                title: 'Chikou'
            });
            chikouSeries.setData(ichimoku.chikou);
            indicatorSeries['ichimoku-chikou'] = chikouSeries;
        }

        // Pivot Points
        function addPivotPoints(data) {
            const pivots = calculatePivotPoints(data);
            if (!pivots) return;
            
            const colors = {
                'pivot': '#f59e0b',
                'r1': '#ef4444', 'r2': '#dc2626', 'r3': '#b91c1c',
                's1': '#22c55e', 's2': '#16a34a', 's3': '#15803d'
            };
            
            Object.entries(pivots).forEach(([key, lineData]) => {
                const series = chart.addLineSeries({
                    color: colors[key] || '#8b949e',
                    lineWidth: 1,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    priceLineVisible: false,
                    lastValueVisible: true,
                    title: key.toUpperCase()
                });
                series.setData(lineData);
                indicatorSeries[`pivots-${key}`] = series;
            });
        }

        // SuperTrend - ATR-based trend indicator (Standard: 10, 3)
        function addSuperTrend(data, period, multiplier) {
            const supertrend = calculateSuperTrend(data, period, multiplier);
            if (supertrend.length === 0) return;
            
            // Split into bullish and bearish segments
            const bullishData = [];
            const bearishData = [];
            let lastTrend = null;
            
            for (let i = 0; i < supertrend.length; i++) {
                const point = supertrend[i];
                
                if (point.trend === 1) {
                    // Bullish
                    bullishData.push({ time: point.time, value: point.value });
                    // Add connection point when switching from bearish
                    if (lastTrend === -1 && i > 0) {
                        bearishData.push({ time: point.time, value: point.value });
                    }
                } else {
                    // Bearish
                    bearishData.push({ time: point.time, value: point.value });
                    // Add connection point when switching from bullish
                    if (lastTrend === 1 && i > 0) {
                        bullishData.push({ time: point.time, value: point.value });
                    }
                }
                lastTrend = point.trend;
            }
            
            // Bullish line (green - below price in uptrend)
            if (bullishData.length > 0) {
                const upSeries = chart.addLineSeries({
                    color: '#22c55e',
                    lineWidth: 2,
                    priceLineVisible: false,
                    lastValueVisible: true,
                    crosshairMarkerVisible: false
                });
                upSeries.setData(bullishData);
                indicatorSeries['supertrend-up'] = upSeries;
            }
            
            // Bearish line (red - above price in downtrend)
            if (bearishData.length > 0) {
                const downSeries = chart.addLineSeries({
                    color: '#ef4444',
                    lineWidth: 2,
                    priceLineVisible: false,
                    lastValueVisible: true,
                    crosshairMarkerVisible: false
                });
                downSeries.setData(bearishData);
                indicatorSeries['supertrend-down'] = downSeries;
            }
        }

        function removeIndicator(indicator) {
            const keysToRemove = Object.keys(indicatorSeries).filter(k => k.startsWith(indicator));
            keysToRemove.forEach(key => {
                try {
                    // Try to remove from main chart first
                    chart.removeSeries(indicatorSeries[key]);
                } catch (e) {
                    // If not on main chart, try volume chart
                    try {
                        volumeChart.removeSeries(indicatorSeries[key]);
                    } catch (e2) {
                        console.warn('Could not remove series:', key);
                    }
                }
                delete indicatorSeries[key];
            });
        }

        // Technical indicator calculations
        function calculateSMA(data, period) {
            const result = [];
            for (let i = period - 1; i < data.length; i++) {
                let sum = 0;
                for (let j = 0; j < period; j++) {
                    sum += data[i - j].close;
                }
                result.push({ time: data[i].time, value: sum / period });
            }
            return result;
        }

        function calculateEMA(data, period) {
            const result = [];
            const multiplier = 2 / (period + 1);
            let ema = data[0].close;
            
            for (let i = 0; i < data.length; i++) {
                if (i === 0) {
                    result.push({ time: data[i].time, value: ema });
                } else {
                    ema = (data[i].close - ema) * multiplier + ema;
                    result.push({ time: data[i].time, value: ema });
                }
            }
            return result;
        }

        function calculateBollingerBands(data, period, stdDev) {
            const upper = [];
            const middle = [];
            const lower = [];
            
            for (let i = period - 1; i < data.length; i++) {
                let sum = 0;
                for (let j = 0; j < period; j++) {
                    sum += data[i - j].close;
                }
                const sma = sum / period;
                
                let variance = 0;
                for (let j = 0; j < period; j++) {
                    variance += Math.pow(data[i - j].close - sma, 2);
                }
                const std = Math.sqrt(variance / period);
                
                upper.push({ time: data[i].time, value: sma + stdDev * std });
                middle.push({ time: data[i].time, value: sma });
                lower.push({ time: data[i].time, value: sma - stdDev * std });
            }
            
            return { upper, middle, lower };
        }

        // Utility functions
        function formatPrice(price) {
            if (price >= 1000) {
                return '$' + price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            }
            return '$' + price.toFixed(4);
        }

        function showLoading(show) {
            const overlay = document.getElementById('loadingOverlay');
            if (show) {
                overlay.classList.remove('hidden');
            } else {
                overlay.classList.add('hidden');
            }
        }

        // =====================================================
        // SYMBOL SEARCH FUNCTIONALITY
        // =====================================================
        
        function initSymbolSearch() {
            const modal = document.getElementById('symbolSearchModal');
            const input = document.getElementById('symbolSearchInput');
            const categories = document.querySelectorAll('.symbol-category');
            
            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeSymbolSearch();
            });
            
            // Search input
            input.addEventListener('input', (e) => {
                filterSymbols(e.target.value, getCurrentCategory());
            });
            
            // Keyboard navigation
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') closeSymbolSearch();
                if (e.key === 'Enter') {
                    const firstItem = document.querySelector('.symbol-item');
                    if (firstItem) firstItem.click();
                }
            });
            
            // Category filters
            categories.forEach(cat => {
                cat.addEventListener('click', () => {
                    categories.forEach(c => c.classList.remove('active'));
                    cat.classList.add('active');
                    filterSymbols(input.value, cat.dataset.category);
                });
            });
            
            // Initial render
            renderSymbolList(SYMBOLS);
        }
        
        function openSymbolSearch(forCompare = false) {
            isSelectingForCompare = forCompare;
            const modal = document.getElementById('symbolSearchModal');
            const input = document.getElementById('symbolSearchInput');
            modal.classList.add('active');
            input.value = '';
            input.focus();
            filterSymbols('', 'all');
        }
        
        function closeSymbolSearch() {
            document.getElementById('symbolSearchModal').classList.remove('active');
            isSelectingForCompare = false;
        }
        
        function getCurrentCategory() {
            const active = document.querySelector('.symbol-category.active');
            return active ? active.dataset.category : 'all';
        }
        
        function filterSymbols(query, category) {
            const filtered = SYMBOLS.filter(s => {
                const matchQuery = !query || 
                    s.symbol.toLowerCase().includes(query.toLowerCase()) ||
                    s.base.toLowerCase().includes(query.toLowerCase());
                const matchCategory = category === 'all' || s.category.includes(category);
                return matchQuery && matchCategory;
            });
            renderSymbolList(filtered);
        }
        
        function renderSymbolList(symbols) {
            const container = document.getElementById('symbolList');
            container.innerHTML = symbols.map(s => {
                const isSelected = s.symbol === currentSymbol;
                
                return `
                    <div class="symbol-item ${isSelected ? 'selected' : ''}" onclick="selectSymbol('${s.symbol}')">
                        <div class="symbol-info">
                            <span class="symbol-name">${s.symbol}</span>
                            <span class="symbol-base">${s.base}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function selectSymbol(symbol) {
            if (isSelectingForCompare) {
                addToCompare(symbol);
            } else {
                const oldSymbol = currentSymbol;
                currentSymbol = symbol;
                document.getElementById('currentSymbol').textContent = symbol;
                closeSymbolSearch();
                
                // Save to localStorage
                localStorage.setItem('chart_symbol', currentSymbol);
                
                // Reset history scroll flag for new symbol
                noMoreHistory = false;
                
                // Reset pressure price tracking for new symbol
                window._lastPressurePrice = null;
                currentRealPrice = null;
                
                // Initialize symbol with Smart Kline Service (background loading)
                initializeSymbolData(symbol, currentTimeframe);
                
                // Clear orderbook and trades for new symbol
                orderbookAsks.clear();
                orderbookBids.clear();
                recentTrades = [];
                
                // Resubscribe WebSocket to new symbol
                if (bybitWs && bybitWs.readyState === WebSocket.OPEN) {
                    // Unsubscribe from old symbol
                    bybitWs.send(JSON.stringify({
                        op: 'unsubscribe',
                        args: [
                            `kline.${currentTimeframe}.${oldSymbol}`,
                            `tickers.${oldSymbol}`,
                            `orderbook.50.${oldSymbol}`,
                            `publicTrade.${oldSymbol}`
                        ]
                    }));
                    
                    // Subscribe to new symbol
                    bybitWs.send(JSON.stringify({
                        op: 'subscribe',
                        args: [
                            `kline.${currentTimeframe}.${symbol}`,
                            `tickers.${symbol}`,
                            `orderbook.50.${symbol}`,
                            `publicTrade.${symbol}`
                        ]
                    }));
                }
                
                loadCandleData();
            }
        }

        // =====================================================
        // COMPARE MODE FUNCTIONALITY
        // =====================================================
        
        let compareDropdownOpen = false;
        
        function toggleCompareDropdown() {
            compareDropdownOpen = !compareDropdownOpen;
            const panel = document.getElementById('comparePanel');
            const btn = document.getElementById('compareBtn');
            
            if (compareDropdownOpen) {
                panel.classList.add('active');
                btn.classList.add('active');
                // Close on click outside
                setTimeout(() => {
                    document.addEventListener('click', closeCompareDropdownOnClickOutside);
                }, 10);
            } else {
                panel.classList.remove('active');
                if (!compareMode) btn.classList.remove('active');
            }
        }
        
        function closeCompareDropdownOnClickOutside(e) {
            const panel = document.getElementById('comparePanel');
            const btn = document.getElementById('compareBtn');
            if (!panel.contains(e.target) && !btn.contains(e.target)) {
                compareDropdownOpen = false;
                panel.classList.remove('active');
                if (!compareMode) btn.classList.remove('active');
                document.removeEventListener('click', closeCompareDropdownOnClickOutside);
            }
        }
        
        function toggleCompareMode() {
            compareMode = !compareMode;
            const btn = document.getElementById('compareBtn');
            const icon = document.getElementById('compareModeIcon');
            
            if (compareMode) {
                btn.classList.add('active');
                icon.className = 'bi bi-toggle-on';
                icon.style.color = 'var(--accent-green)';
                
                // Store original data and CLEAR series to hide them
                // visible:false doesn't work for CandlestickSeries in lightweight-charts
                try {
                    window._originalCandleData = [...currentCandles];
                    window._originalVolumeData = [...currentVolumes];
                    
                    // Clear data to hide candles
                    candleSeries.setData([]);
                    volumeSeries.setData([]);
                    if (volumeSmaSeries) volumeSmaSeries.setData([]);
                    
                    // console.log('[Compare] Candles hidden, stored', window._originalCandleData.length, 'candles');
                } catch(e) { console.warn('Error hiding series:', e); }
                
                // Hide main price scale, show percent scale
                chart.priceScale('right').applyOptions({ visible: false });
                
                // Add 0% baseline
                addCompareBaseline();
                
                addToCompare(currentSymbol);
            } else {
                icon.className = 'bi bi-toggle-off';
                icon.style.color = '';
                if (!compareDropdownOpen) btn.classList.remove('active');
                
                clearCompare();
                
                // Restore candle series data
                try {
                    if (window._originalCandleData && window._originalCandleData.length > 0) {
                        candleSeries.setData(window._originalCandleData);
                        currentCandles = [...window._originalCandleData];
                        // console.log('[Compare] Restored', window._originalCandleData.length, 'candles');
                    }
                    if (window._originalVolumeData && window._originalVolumeData.length > 0) {
                        volumeSeries.setData(window._originalVolumeData);
                        currentVolumes = [...window._originalVolumeData];
                    }
                } catch(e) { console.warn('Error restoring series:', e); }
                
                // Show main price scale, hide percent scale
                chart.priceScale('right').applyOptions({ visible: true });
                try { chart.priceScale('percent').applyOptions({ visible: false }); } catch(e) {}
                
                // Remove baseline
                removeCompareBaseline();
            }
        }
        
        let compareBaseline = null;
        
        function addCompareBaseline() {
            if (compareBaseline) return;
            compareBaseline = chart.addLineSeries({
                color: '#666',
                lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Dashed,
                priceLineVisible: false,
                lastValueVisible: false,
                priceScaleId: 'percent'
            });
            // Set baseline at 0% across visible range
            const now = Math.floor(Date.now() / 1000);
            const oneYear = 365 * 24 * 60 * 60;
            compareBaseline.setData([
                { time: now - oneYear, value: 0 },
                { time: now + 86400, value: 0 }
            ]);
        }
        
        function removeCompareBaseline() {
            if (compareBaseline) {
                try { chart.removeSeries(compareBaseline); } catch(e) {}
                compareBaseline = null;
            }
        }
        
        function addToCompare(symbol) {
            if (compareSymbols.length >= 6) {
                alert('Maximum 6 symbols for comparison');
                return;
            }
            
            if (compareSymbols.some(c => c.symbol === symbol)) {
                closeSymbolSearch();
                return;
            }
            
            const color = COMPARE_COLORS[compareSymbols.length];
            const series = chart.addLineSeries({
                color: color,
                lineWidth: 2,
                priceLineVisible: true,
                lastValueVisible: true,
                priceFormat: {
                    type: 'custom',
                    formatter: (price) => price.toFixed(2) + '%'
                },
                priceScaleId: 'percent'  // Use separate scale for percent
            });
            
            // Configure percent scale on first comparison
            if (compareSymbols.length === 0) {
                chart.priceScale('percent').applyOptions({
                    scaleMargins: { top: 0.1, bottom: 0.1 },
                    borderVisible: true,
                    borderColor: '#363a45',
                    visible: true,
                    position: 'right'
                });
            }
            
            compareSymbols.push({ symbol, series, color });
            loadCompareData(symbol, series);
            updateCompareChips();
            closeSymbolSearch();
        }
        
        function removeFromCompare(symbol) {
            const idx = compareSymbols.findIndex(c => c.symbol === symbol);
            if (idx !== -1) {
                chart.removeSeries(compareSymbols[idx].series);
                compareSymbols.splice(idx, 1);
                updateCompareChips();
            }
            
            if (compareSymbols.length === 0) {
                toggleCompareMode();
            }
        }
        
        function clearCompare() {
            compareSymbols.forEach(c => {
                try { chart.removeSeries(c.series); } catch(e) {}
            });
            compareSymbols = [];
            removeCompareBaseline();
            updateCompareChips();
        }
        
        function updateCompareChips() {
            const container = document.getElementById('compareChips');
            container.innerHTML = compareSymbols.map(c => `
                <div class="compare-chip" style="background: ${c.color}20; border: 1px solid ${c.color}; color: ${c.color}">
                    <span>${c.symbol}</span>
                    <span class="remove-btn" onclick="removeFromCompare('${c.symbol}')">×</span>
                </div>
            `).join('');
            
            // Show/hide legend using class
            const legend = document.getElementById('compareLegend');
            if (compareSymbols.length > 0) {
                legend.classList.remove('hidden');
                updateCompareLegend();
            } else {
                legend.classList.add('hidden');
            }
        }
        
        function updateCompareLegend() {
            const legend = document.getElementById('compareLegend');
            legend.innerHTML = compareSymbols.map(c => {
                // Get last value from series data
                const lastValue = c.lastValue || 0;
                const valueClass = lastValue >= 0 ? 'positive' : 'negative';
                const sign = lastValue >= 0 ? '+' : '';
                return `
                    <div class="compare-legend-item">
                        <div class="compare-legend-color" style="background: ${c.color}"></div>
                        <span style="color: ${c.color}">${c.symbol}</span>
                        <span class="compare-legend-value ${valueClass}">${sign}${lastValue.toFixed(2)}%</span>
                    </div>
                `;
            }).join('');
        }
        
        async function loadCompareData(symbol, series) {
            try {
                // console.log(`[Compare] Loading data for ${symbol}...`);
                
                // Use Smart Kline Service - reads from RAM cache / DB first
                const response = await fetch(
                    `${MARKET_API}/bybit/klines/smart?symbol=${symbol}&interval=${currentTimeframe}&limit=200`
                );
                
                if (response.ok) {
                    const data = await response.json();
                    // console.log(`[Compare] ${symbol}: Received ${data?.length} candles, first close:`, data[0]?.close);
                    
                    if (data && Array.isArray(data) && data.length > 0) {
                        // Sort by time ascending (oldest first)
                        const sortedData = [...data].sort((a, b) => a.open_time - b.open_time);
                        
                        const basePrice = parseFloat(sortedData[0].close);
                        // console.log(`[Compare] ${symbol}: Base price = ${basePrice}, Last price = ${sortedData[sortedData.length-1].close}`);
                        
                        // Quick normalization - no chunking needed for 200 points
                        const normalized = [];
                        for (let i = 0; i < sortedData.length; i++) {
                            const k = sortedData[i];
                            normalized.push({
                                time: Math.floor(k.open_time / 1000),
                                value: ((parseFloat(k.close) - basePrice) / basePrice) * 100
                            });
                        }
                        
                        const lastValue = normalized[normalized.length - 1]?.value || 0;
                        // console.log(`[Compare] ${symbol}: Normalized ${normalized.length} points, last value: ${lastValue.toFixed(2)}%`);
                        
                        series.setData(normalized);
                        
                        // Store last value for legend
                        const compareItem = compareSymbols.find(c => c.symbol === symbol);
                        if (compareItem) {
                            compareItem.lastValue = lastValue;
                            updateCompareLegend();
                        }
                        return;
                    }
                } else {
                    console.error(`[Compare] ${symbol}: HTTP ${response.status}`);
                }
            } catch(e) {
                console.error(`[Compare] ${symbol}: Error -`, e);
            }
            
            // Show error - no mock data
            console.error(`[Compare] ${symbol}: Failed to load data`);
        }

        // =====================================================
        // BYBIT WEBSOCKET CONNECTION (Real-time data)
        // =====================================================
        
        let bybitWs = null;
        let wsReconnectAttempts = 0;
        let wsReconnectTimeout = null;
        let wsPingInterval = null;
        let wsConnectTimeout = null;  // Timeout for initial connection
    let wsIsConnecting = false;   // Prevent duplicate connectWebSocket calls
        
        const WS_CONFIG = {
            url: 'wss://stream.bybit.com/v5/public/linear',
            maxReconnect: 3,  // Reduced from 10 - fail faster
            baseDelay: 1000,
            maxDelay: 10000,  // Reduced from 30000
            pingInterval: 20000,  // Bybit requires ping every 20s
            connectTimeout: 10000  // 10 second timeout for initial connection
        };
        
        // Map our timeframe to Bybit kline interval
        function getBybitInterval(tf) {
            const map = {
                '1': '1',      // 1 minute
                '5': '5',      // 5 minutes
                '15': '15',    // 15 minutes
                '30': '30',    // 30 minutes
                '60': '60',    // 1 hour
                '240': '240',  // 4 hours
                'D': 'D',      // 1 day
                'W': 'W',      // 1 week
                '1440': 'D',   // 1 day (alternative)
                '10080': 'W'   // 1 week (alternative)
            };
            return map[tf] || '60';
        }
        
        // Convert timeframe to seconds for gap detection
        function getTimeframeSeconds(tf) {
            const map = {
                '1': 60,           // 1 minute
                '5': 300,          // 5 minutes
                '15': 900,         // 15 minutes
                '30': 1800,        // 30 minutes
                '60': 3600,        // 1 hour
                '240': 14400,      // 4 hours
                'D': 86400,        // 1 day
                'W': 604800,       // 1 week
                '1440': 86400,     // 1 day (alternative)
                '10080': 604800    // 1 week (alternative)
            };
            return map[tf] || 3600;
        }
        
        function connectWebSocket() {
            // Prevent re-entrancy / duplicate connections
            if (wsIsConnecting) {
                console.warn('[Bybit WS] connectWebSocket ignored (already connecting)');
                return;
            }
            wsIsConnecting = true;

            updateConnectionStatus('connecting');
            
            // Clear any existing reconnect timeout
            if (wsReconnectTimeout) {
                clearTimeout(wsReconnectTimeout);
                wsReconnectTimeout = null;
            }
            
            // Clear connection timeout
            if (wsConnectTimeout) {
                clearTimeout(wsConnectTimeout);
                wsConnectTimeout = null;
            }

            // Clear ping interval (important when reconnecting)
            if (wsPingInterval) {
                clearInterval(wsPingInterval);
                wsPingInterval = null;
            }
            
            // Close existing connection
            if (bybitWs) {
                try {
                    bybitWs.close();
                } catch (e) {
                    // ignore
                }
                bybitWs = null;
            }
            
            try {
                // console.log('[Bybit WS] Connecting to', WS_CONFIG.url);
                bybitWs = new WebSocket(WS_CONFIG.url);
                
                // Set connection timeout - if not connected in 10s, give up and use mock mode
                wsConnectTimeout = setTimeout(() => {
                    if (bybitWs && bybitWs.readyState !== WebSocket.OPEN) {
                        // console.log('[Bybit WS] Connection timeout');
                        bybitWs.close();
                        bybitWs = null;
                        updateConnectionStatus('error');
                        // Attempt reconnect instead of mock
                        attemptReconnect();
                    }
                }, WS_CONFIG.connectTimeout);
                
                bybitWs.onopen = () => {
                    wsIsConnecting = false;
                    // Clear connection timeout on successful connect
                    if (wsConnectTimeout) {
                        clearTimeout(wsConnectTimeout);
                        wsConnectTimeout = null;
                    }
                    // console.log('[Bybit WS] Connected');
                    wsReconnectAttempts = 0;
                    updateConnectionStatus('connected');
                    
                    // Don't stop mock updates here - wait for real data to arrive
                    // stopMockPriceUpdates() will be called when first kline/ticker data arrives
                    
                    // Subscribe to kline data
                    const interval = getBybitInterval(currentTimeframe);
                    const subscribeMsg = {
                        op: 'subscribe',
                        args: [`kline.${interval}.${currentSymbol}`]
                    };
                    bybitWs.send(JSON.stringify(subscribeMsg));
                    // console.log('[Bybit WS] Subscribed to', subscribeMsg.args);
                    
                    // Subscribe to ticker for price updates
                    bybitWs.send(JSON.stringify({
                        op: 'subscribe',
                        args: [`tickers.${currentSymbol}`]
                    }));

                    // Subscribe to orderbook (50 levels, with throttled updates)
                    bybitWs.send(JSON.stringify({
                        op: 'subscribe',
                        args: [`orderbook.50.${currentSymbol}`]
                    }));
                    // console.log('[Bybit WS] Subscribed to orderbook.50.' + currentSymbol);
                    
                    // Subscribe to public trades (real market trades)
                    bybitWs.send(JSON.stringify({
                        op: 'subscribe',
                        args: [`publicTrade.${currentSymbol}`]
                    }));
                    // console.log('[Bybit WS] Subscribed to publicTrade.' + currentSymbol);
                    
                    // Start ping interval (Bybit requires ping every 20s)
                    if (wsPingInterval) clearInterval(wsPingInterval);
                    wsPingInterval = setInterval(() => {
                        if (bybitWs && bybitWs.readyState === WebSocket.OPEN) {
                            bybitWs.send(JSON.stringify({ op: 'ping' }));
                        }
                    }, WS_CONFIG.pingInterval);
                };
                
                bybitWs.onmessage = (event) => {
                    try {
                        // Diagnostics: track last time we received any WS traffic
                        lastWsMessageTs = Date.now();
                        
                        // Count messages for rate monitoring
                        if (window._wsMessageCount !== undefined) {
                            window._wsMessageCount++;
                        }

                        const msg = JSON.parse(event.data);
                        
                        // Removed verbose logging - uncomment for debugging:
                        if (msg.topic) // console.log('[Bybit WS] Message:', msg.topic);
                        
                        // Handle pong
                        if (msg.op === 'pong' || msg.ret_msg === 'pong') {
                            return;
                        }
                        
                        // Handle subscription confirmation
                        if (msg.success === true) {
                            // console.log('[Bybit WS] Subscription confirmed');
                            return;
                        }
                        
                        // Handle kline data
                        if (msg.topic && msg.topic.startsWith('kline.') && msg.topic.includes(currentSymbol)) {
                            handleBybitKline(msg.data);
                        }
                        
                        // Handle ticker data (for real-time price)
                        if (msg.topic && msg.topic.startsWith('tickers.') && msg.topic.includes(currentSymbol)) {
                            handleBybitTicker(msg.data);
                        }
                        
                        // Handle orderbook data
                        if (msg.topic && msg.topic.startsWith('orderbook.') && msg.topic.includes(currentSymbol)) {
                            handleBybitOrderbook(msg.type, msg.data);
                        }
                        
                        // Handle public trades data
                        if (msg.topic && msg.topic.startsWith('publicTrade.') && msg.topic.includes(currentSymbol)) {
                            handleBybitTrades(msg.data);
                        }
                        
                    } catch (e) {
                        console.error('[Bybit WS] Message parse error:', e);
                    }
                };
                
                bybitWs.onerror = (error) => {
                    wsIsConnecting = false;
                    console.error('[Bybit WS] Error:', error);
                    updateConnectionStatus('error');
                };
                
                bybitWs.onclose = (event) => {
                    wsIsConnecting = false;
                    // console.log(`[Bybit WS] Closed (code: ${event.code})`);
                    updateConnectionStatus('disconnected');
                    
                    // Clear ping interval
                    if (wsPingInterval) {
                        clearInterval(wsPingInterval);
                        wsPingInterval = null;
                    }

                    // Clear connection timeout
                    if (wsConnectTimeout) {
                        clearTimeout(wsConnectTimeout);
                        wsConnectTimeout = null;
                    }
                    
                    // Start mock updates as fallback
                    // startMockPriceUpdates(); // REMOVED: Real Data Policy

                    
                    // Attempt reconnect
                    attemptReconnect();
                };
            } catch(e) {
                wsIsConnecting = false;
                console.error('[Bybit WS] Init failed:', e);
                // startMockPriceUpdates(); // REMOVED: Real Data Policy
            }
        }

        function cleanupWebSocketTimers() {
            if (wsReconnectTimeout) {
                clearTimeout(wsReconnectTimeout);
                wsReconnectTimeout = null;
            }
            if (wsConnectTimeout) {
                clearTimeout(wsConnectTimeout);
                wsConnectTimeout = null;
            }
            if (wsPingInterval) {
                clearInterval(wsPingInterval);
                wsPingInterval = null;
            }
        }
        
        function handleBybitKline(data) {
            const _perfStart = performance.now();
            
            if (!data || !Array.isArray(data) || data.length === 0) return;
            
            // Skip updates in compare mode
            if (compareMode) return;
            
            // Stop mock updates when receiving real data
            // stopMockPriceUpdates(); // REMOVED: Real Data Policy
            
            const kline = data[0];
            const candleTime = Math.floor(kline.start / 1000);  // Convert ms to seconds
            
            // Only update current or newer candles (avoid "Cannot update oldest data" error)
            if (currentCandles.length > 0) {
                const lastCandleTime = currentCandles[currentCandles.length - 1].time;
                if (candleTime < lastCandleTime) {
                    // Skip old candle data
                    return;
                }
            }
            
            const candle = {
                time: candleTime,
                open: parseFloat(kline.open),
                high: parseFloat(kline.high),
                low: parseFloat(kline.low),
                close: parseFloat(kline.close)
            };
            
            try {
                candleSeries.update(candle);
                
                // Update stored data with memory limit
                const MAX_CANDLES = 2000;  // Prevent memory leak
                if (currentCandles.length > 0) {
                    const lastIdx = currentCandles.length - 1;
                    if (currentCandles[lastIdx].time === candle.time) {
                        currentCandles[lastIdx] = candle;
                    } else if (candle.time > currentCandles[lastIdx].time) {
                        currentCandles.push(candle);
                        // Trim old data if exceeds limit
                        if (currentCandles.length > MAX_CANDLES) {
                            currentCandles.splice(0, currentCandles.length - MAX_CANDLES);
                        }
                        // New candle - reset accumulated volume
                        accumulatedVolume = 0;
                    }
                }
                
                // Update volume from kline (authoritative source)
                const volume = {
                    time: candle.time,
                    value: parseFloat(kline.volume),
                    color: candle.close >= candle.open ? '#00c853' : '#ff1744'
                };
                volumeSeries.update(volume);
                
                // Update stored volumes with memory limit
                if (currentVolumes && currentVolumes.length > 0) {
                    const lastVolIdx = currentVolumes.length - 1;
                    if (currentVolumes[lastVolIdx].time === volume.time) {
                        currentVolumes[lastVolIdx] = volume;
                    } else if (volume.time > currentVolumes[lastVolIdx].time) {
                        currentVolumes.push(volume);
                        // Trim old data if exceeds limit
                        if (currentVolumes.length > MAX_CANDLES) {
                            currentVolumes.splice(0, currentVolumes.length - MAX_CANDLES);
                        }
                    }
                }
                
                // Reset accumulated volume (kline provides authoritative volume)
                accumulatedVolume = 0;
                
                // Update volume indicators
                updateVolumeIndicators();
                
                // updatePriceDisplay(candle); // DISABLED: Let Ticker handle "Current Price" to avoid jitter
                document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
                
                // Performance monitoring
                const _perfElapsed = performance.now() - _perfStart;
                if (_perfElapsed > 16) {
                    console.warn('[Perf] handleBybitKline took', _perfElapsed.toFixed(1), 'ms');
                }
            } catch (e) {
                console.error('[Bybit WS] Kline update error:', e);
            }
        }
        
        // =====================================================
        // EFFICIENT TICKER HANDLING WITH requestAnimationFrame
        // =====================================================
        
        // Pending update state - accumulate updates between frames
        let pendingPrice = null;
        let pendingTickerData = null;
        let rafScheduled = false;
        
        // Store accumulated ticker state
        let accumulatedTickerData = {};

        function handleBybitTicker(data) {
            if (!data) return;
            
            // // console.log('[Ticker] Data:', data); // Debug
            
            // Merge new data into accumulated state (handle deltas)
            accumulatedTickerData = { ...accumulatedTickerData, ...data };
            
            // Update price if present in this update
            if (data.lastPrice) {
                const newPrice = parseFloat(data.lastPrice);
                if (!isNaN(newPrice)) {
                    pendingPrice = newPrice;
                    currentRealPrice = newPrice;
                    window._lastHeaderPrice = currentRealPrice;
                }
            } else if (!pendingPrice && accumulatedTickerData.lastPrice) {
                 // Fallback to accumulated price if not yet set
                 pendingPrice = parseFloat(accumulatedTickerData.lastPrice);
            }
            
            // Allow processing even if only stats changed (no price change)
            pendingTickerData = accumulatedTickerData;
            
            // In compare mode, just update header
            if (compareMode) {
                if (pendingPrice) {
                    const priceEl = document.getElementById('currentPrice');
                    if (priceEl) {
                        priceEl.textContent = '$' + formatPrice(pendingPrice);
                        // Update color if we have history
                        if (currentCandles.length > 0) {
                             const lastCandle = currentCandles[currentCandles.length - 1];
                             const isUp = pendingPrice >= lastCandle.open;
                             priceEl.className = 'current-price ' + (isUp ? 'up' : 'down');
                        }
                    }
                }
                return;
            }
            
            // Store latest ticker for price lines
            // Don't need to re-assign latestTickerData here as pendingTickerData covers it?
            // Existing logic uses local 'ticker' variable.
            // We use accumulatedTickerData instead.
            
            const ticker = accumulatedTickerData;

            // Only update high/low lines if values changed significantly (>0.01% change)
            // Note: we can defer this to render loop, but existing logic is fine here
            if (chartSettings.highLowLines) {
                 // ... keep existing logic if possible, or simplifying
                 // For now, let's just trigger render
                 // The render function updates stats.
            }
            
            // Schedule render on next animation frame
            if (!rafScheduled) {
                rafScheduled = true;
                requestAnimationFrame(renderTickerUpdate);
            }
        }

        
        function renderTickerUpdate() {
            rafScheduled = false;
            
            if (!pendingPrice) return;
            
            const price = pendingPrice;
            const ticker = pendingTickerData;
            
            // Update header price with color based on candle direction
            const priceEl = document.getElementById('currentPrice');
            if (priceEl) {
                priceEl.textContent = '$' + price.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
                
                // Color based on current candle direction (close vs open)
                if (currentCandles.length > 0) {
                    const lastCandle = currentCandles[currentCandles.length - 1];
                    const isUp = price >= lastCandle.open;
                    priceEl.className = 'current-price ' + (isUp ? 'up' : 'down');
                }
            }
            
            // Update pressure price immediately with ticker price
            const pressurePriceEl = document.getElementById('pressurePrice');
            const pressureArrowEl = document.getElementById('pressureArrow');
            if (pressurePriceEl && pressureArrowEl) {
                const oldPrice = window._lastPressurePrice || price;
                window._lastPressurePrice = price;
                const isUp = price >= oldPrice;
                
                pressureArrowEl.textContent = isUp ? '↑' : '↓';
                pressureArrowEl.className = 'pressure-arrow ' + (isUp ? 'buy' : 'sell');
                pressurePriceEl.className = 'pressure-price ' + (isUp ? 'buy' : 'sell');
                pressurePriceEl.textContent = formatPrice(price).replace('$', '');
            }
            
            // Update order book (throttled inside)

            
            // Update stats panel with real ticker data
            if (ticker) {
                updateStatsFromTicker(ticker);
            }
            
            // Update chart candle (skip in compare mode)
            if (!compareMode && currentCandles.length > 0) {
                const lastIdx = currentCandles.length - 1;
                const lastCandle = currentCandles[lastIdx];
                
                // --- FIX: Check if ticker price belongs to the current bar ---
                const intervalSec = getTimeframeSeconds(currentTimeframe);
                const nowSec = Math.floor(Date.now() / 1000);
                const currentBarTime = Math.floor(nowSec / intervalSec) * intervalSec;
                
                // Only update if the last candle is actually the current bar
                // This prevents old bars from jumping to current price when history is lagging
                if (lastCandle.time === currentBarTime) {
                    const updatedCandle = {
                        time: lastCandle.time,
                        open: lastCandle.open,
                        high: Math.max(lastCandle.high, price),
                        low: Math.min(lastCandle.low, price),
                        close: price
                    };
                    
                    try {
                        candleSeries.update(updatedCandle);
                        currentCandles[lastIdx] = updatedCandle;
                        updatePriceDisplay(updatedCandle);
                        document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
                    } catch (e) {
                        console.error('[Bybit WS] Ticker update error:', e);
                    }
                } else if (lastCandle.time < currentBarTime) {
                    // History is lagging. Do NOT update the old candle.
                    // Instead, we could create a "gap filler" candle here, but safer to let 
                    // handleBybitKline create the new authoritative candle.
                    // Just update header price (already done above) and skip chart update.
                    // console.log('[Ticker] Skipping chart update - history lag detected');
                }
            }
        }
        
        // Update stats panel with real Bybit ticker data
        function updateStatsFromTicker(ticker) {
            // 24h High
            if (ticker.highPrice24h) {
                const high24h = parseFloat(ticker.highPrice24h);
                document.getElementById('stat24hHigh').textContent = '$' + high24h.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
            }
            
            // 24h Low
            if (ticker.lowPrice24h) {
                const low24h = parseFloat(ticker.lowPrice24h);
                document.getElementById('stat24hLow').textContent = '$' + low24h.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
            }
            
            // 24h Volume
            if (ticker.volume24h) {
                const vol = parseFloat(ticker.volume24h);
                document.getElementById('stat24hVolume').textContent = formatLargeNumber(vol) + ' ' + currentSymbol.replace('USDT', '');
            }
            
            // 24h Turnover (can show as trades value)
            if (ticker.turnover24h) {
                const turnover = parseFloat(ticker.turnover24h);
                document.getElementById('stat24hTrades').textContent = '$' + formatLargeNumber(turnover);
            }
            
            // Open Interest
            if (ticker.openInterestValue) {
                const oi = parseFloat(ticker.openInterestValue);
                document.getElementById('statOI').textContent = '$' + formatLargeNumber(oi);
            }
            
            // Funding Rate
            if (ticker.fundingRate) {
                const rate = parseFloat(ticker.fundingRate) * 100;
                const fundingEl = document.getElementById('statFunding');
                fundingEl.textContent = rate.toFixed(4) + '%';
                // Color: green for negative (shorts pay longs), red for positive
                fundingEl.style.color = rate < 0 ? '#3fb950' : rate > 0 ? '#f85149' : '#8b949e';
            }
        }
        
        // Format large numbers (1.5M, 2.3B, etc.)
        function formatLargeNumber(num) {
            if (num >= 1e12) return (num / 1e12).toFixed(2) + 'T';
            if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
            if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
            if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
            return num.toFixed(2);
        }
        
        function resubscribeWebSocket() {
            if (bybitWs && bybitWs.readyState === WebSocket.OPEN) {
                // Subscribe to new symbol/timeframe
                const interval = getBybitInterval(currentTimeframe);
                bybitWs.send(JSON.stringify({
                    op: 'subscribe',
                    args: [
                        `kline.${interval}.${currentSymbol}`,
                        `tickers.${currentSymbol}`,
                        `orderbook.50.${currentSymbol}`,
                        `publicTrade.${currentSymbol}`
                    ]
                }));
                // console.log('[Bybit WS] Resubscribed to', currentSymbol, interval, '(kline, ticker, orderbook, trades)');
                
                // Clear old orderbook data for new symbol
                orderbookAsks.clear();
                orderbookBids.clear();
                recentTrades = [];
            }
        }
        
        function attemptReconnect() {
            // Don't stack reconnect timers
            if (wsReconnectTimeout) {
                clearTimeout(wsReconnectTimeout);
                wsReconnectTimeout = null;
            }

            // If we're already trying to connect, don't schedule another
            if (wsIsConnecting) {
                // console.log('[Bybit WS] Reconnect skipped (already connecting)');
                return;
            }

            if (wsReconnectAttempts >= WS_CONFIG.maxReconnect) {
                // console.log('[Bybit WS] Max retries reached, giving up');
                updateConnectionStatus('disconnected');
                return;
            }
            
            wsReconnectAttempts++;
            const delay = Math.min(
                WS_CONFIG.baseDelay * Math.pow(2, wsReconnectAttempts - 1),
                WS_CONFIG.maxDelay
            );
            
            // console.log(`[Bybit WS] Reconnect attempt ${wsReconnectAttempts}/${WS_CONFIG.maxReconnect} in ${delay}ms`);
            wsReconnectTimeout = setTimeout(connectWebSocket, delay);
        }
        
        function updateConnectionStatus(status) {
            const dot = document.getElementById('connectionDot');
            const text = document.getElementById('connectionStatus');
            
            switch(status) {
                case 'connected':
                    dot.style.background = 'var(--accent-green)';
                    text.textContent = 'Bybit Live';
                    break;
                case 'connecting':
                    dot.style.background = 'var(--accent-yellow)';
                    text.textContent = 'Connecting...';
                    break;
                case 'error':
                    dot.style.background = 'var(--accent-red)';
                    text.textContent = 'Connection Error';
                    break;
                default:
                    dot.style.background = 'var(--accent-red)';
                    text.textContent = 'Disconnected';
            }
        }
        
        function handleRealtimeUpdate(data) {
            const candle = {
                time: data.time,
                open: parseFloat(data.open),
                high: parseFloat(data.high),
                low: parseFloat(data.low),
                close: parseFloat(data.close)
            };
            
            candleSeries.update(candle);
            volumeSeries.update({
                time: data.time,
                value: parseFloat(data.volume),
                color: candle.close >= candle.open ? '#00c853' : '#ff1744'
            });
            
            updatePriceDisplay(candle);
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }

        // =====================================================
        // EXPORT FUNCTIONALITY
        // =====================================================
        
        function exportChart() {
            const options = [
                { label: 'Export as PNG', action: exportAsPNG },
                { label: 'Export Data as CSV', action: exportAsCSV },
                { label: 'Export Data as JSON', action: exportAsJSON }
            ];
            
            const choice = prompt(
                'Export options:\n1. PNG Image\n2. CSV Data\n3. JSON Data\n\nEnter 1, 2, or 3:'
            );
            
            switch(choice) {
                case '1': exportAsPNG(); break;
                case '2': exportAsCSV(); break;
                case '3': exportAsJSON(); break;
            }
        }
        
        function exportAsPNG() {
            const canvas = document.querySelector('#chart canvas');
            if (canvas) {
                const link = document.createElement('a');
                link.download = `${currentSymbol}_${currentTimeframe}_chart.png`;
                link.href = canvas.toDataURL();
                link.click();
            }
        }
        
        function exportAsCSV() {
            const data = currentCandles;  // Use stored data
            const csv = ['Time,Open,High,Low,Close'];
            
            data.forEach(d => {
                const date = new Date(d.time * 1000).toISOString();
                csv.push(`${date},${d.open},${d.high},${d.low},${d.close}`);
            });
            
            downloadFile(csv.join('\n'), `${currentSymbol}_${currentTimeframe}_data.csv`, 'text/csv');
        }
        
        function exportAsJSON() {
            const data = currentCandles;  // Use stored data
            const json = JSON.stringify(data, null, 2);
            downloadFile(json, `${currentSymbol}_${currentTimeframe}_data.json`, 'application/json');
        }
        
        function downloadFile(content, filename, type) {
            const blob = new Blob([content], { type });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        // =====================================================
        // INDICATOR PERSISTENCE
        // =====================================================
        
        function loadSavedIndicators() {
            try {
                const saved = localStorage.getItem('chart_indicators');
                if (saved) {
                    const indicators = JSON.parse(saved);
                    indicators.forEach(ind => {
                        activeIndicators.add(ind);
                        document.getElementById(`toggle-${ind}`)?.classList.add('active');
                    });
                    
                    // Wait for chart data to be available before applying indicators
                    const waitForData = () => {
                        if (currentCandles && currentCandles.length > 0 && chart) {
                            // console.log('[Indicators] Data ready, applying', indicators.length, 'saved indicators');
                            indicators.forEach(ind => addIndicator(ind));
                        } else {
                            // console.log('[Indicators] Waiting for data... candles:', currentCandles?.length, 'chart:', !!chart);
                            setTimeout(waitForData, 200);
                        }
                    };
                    waitForData();
                }
            } catch(e) {
                // console.log('No saved indicators or error loading:', e);
            }
        }
        
        function saveIndicators() {
            localStorage.setItem('chart_indicators', JSON.stringify([...activeIndicators]));
        }

        function toggleFullscreen() {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                document.documentElement.requestFullscreen();
            }
        }

        function clearDrawings() {
            if (confirm('Clear all drawings?')) {
                // Would clear all drawing objects
                // console.log('Drawings cleared');
            }
        }

        // =====================================================
        // PRICE ALERTS FUNCTIONALITY
        // =====================================================
        
        // ==================== SETTINGS SYSTEM ====================
        const defaultSettings = {
            gridLines: true,
            volumeChart: true,
            watermark: false,
            lastPriceLine: true,
            crosshair: true,
            supportResistance: false,
            highLowLines: false,
            openPriceLine: false,
            tradeMarkers: false,
            buySellMarkers: false,  // Strategy buy/sell signals
            liquidations: false,
            patternDoji: false,
            patternHammer: false,
            patternEngulfing: false,
            patternStar: false,
            patternSoldiers: false,
            infiniteHistory: true,
            autoScroll: true,
            connectionStatus: true,
            orderBook: true,
            recentTrades: true
        };
        
        let chartSettings = { ...defaultSettings };
        
        // Price line references
        let highPriceLine = null;
        let lowPriceLine = null;
        let openPriceLine = null;
        let supportResistanceLines = [];
        
        function loadSettings() {
            try {
                const saved = localStorage.getItem('chart_settings');
                if (saved) {
                    chartSettings = { ...defaultSettings, ...JSON.parse(saved) };
                }
            } catch (e) {
                console.error('Error loading settings:', e);
                chartSettings = { ...defaultSettings };
            }
            
            // Ensure volumeChart is always true (fix for previous bug)
            if (chartSettings.volumeChart === undefined || chartSettings.volumeChart === false) {
                chartSettings.volumeChart = true;
                saveSettings();
            }
            
            // Apply settings to checkboxes
            Object.keys(chartSettings).forEach(key => {
                let checkbox = document.getElementById(`setting-${key}`);
                
                // Handle pattern checkboxes (patternDoji -> setting-pattern-doji)
                if (!checkbox && key.startsWith('pattern')) {
                    const patternName = key.replace('pattern', '').toLowerCase();
                    checkbox = document.getElementById(`setting-pattern-${patternName}`);
                }
                
                if (checkbox) {
                    checkbox.checked = chartSettings[key];
                }
            });
        }
        
        function saveSettings() {
            try {
                localStorage.setItem('chart_settings', JSON.stringify(chartSettings));
            } catch (e) {
                console.error('Error saving settings:', e);
            }
        }
        
        function applyAllSettings() {
            // Apply all chart settings after chart is initialized
            // console.log('[Settings] Applying all settings...');
            Object.keys(chartSettings).forEach(key => {
                try {
                    applySettingChange(key, chartSettings[key]);
                } catch (e) {
                    console.warn('[Settings] Failed to apply:', key, e);
                }
            });
        }
        
        function updateSetting(key, value) {
            // console.log('[Settings] Updating:', key, '=', value);
            chartSettings[key] = value;
            saveSettings();
            applySettingChange(key, value);
        }
        
        // Volume indicator settings

        
        // Volume indicator series references (volumeSmaSeries already declared above)
        let volumeEmaSeries = null;
        let volumeBBUpperSeries = null;
        let volumeBBLowerSeries = null;
        let vwapSeries = null;
        
        function updateVolumeSetting(key, value) {
            // console.log('[Volume Settings] Updating:', key, '=', value);
            try {
                // Coerce + validate inputs defensively (prevents 'Value is null' crashes)
                if (key.includes('Period')) {
                    const n = parseInt(value, 10);
                    volumeSettings[key] = Number.isFinite(n) ? n : (volumeSettings[key] ?? 0);
                } else if (key === 'opacity') {
                    const n = parseInt(value, 10);
                    volumeSettings[key] = Number.isFinite(n) ? n : (volumeSettings[key] ?? 100);
                } else {
                    // booleans for checkboxes like sma/ema/vwap/bb/obv/delta/highlight
                    volumeSettings[key] = !!value;
                }
            } catch (e) {
                console.warn('[Volume Settings] Failed to update key:', key, e);
                return;
            }
            
            // Save to localStorage
            try {
                localStorage.setItem('volume_settings', JSON.stringify(volumeSettings));
            } catch (e) {
                console.error('Error saving volume settings:', e);
            }
            
            // Apply changes (never allow UI toggle to crash the page)
            // IMPORTANT: only apply if we have chart data loaded. This prevents "Value is null" errors
            // when user toggles settings before data arrives.
            if (Array.isArray(currentCandles) && currentCandles.length > 0 && 
                Array.isArray(currentVolumes) && currentVolumes.length > 0 && 
                chart && volumeChart) {
                try {
                    applyVolumeIndicators();
                } catch (e) {
                    console.warn('[Volume Settings] applyVolumeIndicators failed:', e);
                }
            } else {
                console.warn('[Volume Settings] Skipped applyVolumeIndicators - no chart data yet (candles:', currentCandles?.length, 'volumes:', currentVolumes?.length, 'chart:', !!chart, 'volumeChart:', !!volumeChart, ')');
            }
        }
        
        function loadVolumeSettings() {
            try {
                const saved = localStorage.getItem('volume_settings');
                if (saved) {
                    volumeSettings = { ...volumeSettings, ...JSON.parse(saved) };
                }
                
                // Apply to UI
                document.getElementById('setting-volumeSma').checked = volumeSettings.sma;
                document.getElementById('setting-volumeSmaPeriod').value = volumeSettings.smaPeriod;
                document.getElementById('setting-volumeEma').checked = volumeSettings.ema;
                document.getElementById('setting-volumeEmaPeriod').value = volumeSettings.emaPeriod;
                document.getElementById('setting-vwap').checked = volumeSettings.vwap;
                document.getElementById('setting-volumeBB').checked = volumeSettings.bb;
                document.getElementById('setting-volumeBBPeriod').value = volumeSettings.bbPeriod;
                document.getElementById('setting-obv').checked = volumeSettings.obv;
                document.getElementById('setting-volumeDelta').checked = volumeSettings.delta;
                document.getElementById('setting-highlightVolume').checked = volumeSettings.highlight;
                document.getElementById('setting-volumeOpacity').value = volumeSettings.opacity;
            } catch (e) {
                console.error('Error loading volume settings:', e);
            }
        }
        
        function applyVolumeIndicators() {
            if (!volumeChart || !currentVolumes || currentVolumes.length === 0) return;
            
            const volumes = currentVolumes.map(v => v.value);
            const times = currentVolumes.map(v => v.time);

            // Helper: convert indicator array (same length as `volumes`) into safe, aligned series points.
            // LightweightCharts rejects null/undefined/NaN values.
            function buildAlignedPoints(indicatorValues, offset = 0) {
                if (!Array.isArray(indicatorValues) || indicatorValues.length === 0) return [];

                const points = [];
                const maxI = Math.min(indicatorValues.length, times.length - offset);
                for (let i = 0; i < maxI; i++) {
                    const t = times[i + offset];
                    const v = indicatorValues[i];
                    if (t == null) continue;
                    if (v == null) continue;
                    const num = typeof v === 'number' ? v : parseFloat(v);
                    if (!Number.isFinite(num)) continue;
                    points.push({ time: t, value: num });
                }
                return points;
            }
            
            // SMA
            if (volumeSettings.sma && volumeSettings.smaPeriod > 0) {
                const smaData = calculateSMA(volumes, volumeSettings.smaPeriod);
                // `calculateSMA` returns values starting at index (period-1); align times accordingly.
                const smaPoints = buildAlignedPoints(smaData, Math.max(0, volumeSettings.smaPeriod - 1));
                
                if (!volumeSmaSeries) {
                    volumeSmaSeries = volumeChart.addLineSeries({
                        color: '#2196F3',
                        lineWidth: 2,
                        priceScaleId: 'volume',
                        lastValueVisible: false,
                        priceLineVisible: false,
                    });
                }
                safeSetData(volumeSmaSeries, smaPoints, 'volumeSmaSeries');
            } else if (volumeSmaSeries) {
                volumeChart.removeSeries(volumeSmaSeries);
                volumeSmaSeries = null;
            }
            
            // EMA
            if (volumeSettings.ema && volumeSettings.emaPeriod > 0) {
                const emaData = calculateEMA(volumes, volumeSettings.emaPeriod);
                // EMA output is typically same length as input; still protect against invalid values.
                const emaPoints = buildAlignedPoints(emaData, 0);
                
                if (!volumeEmaSeries) {
                    volumeEmaSeries = volumeChart.addLineSeries({
                        color: '#FF9800',
                        lineWidth: 2,
                        priceScaleId: 'volume',
                        lastValueVisible: false,
                        priceLineVisible: false,
                    });
                }
                safeSetData(volumeEmaSeries, emaPoints, 'volumeEmaSeries');
            } else if (volumeEmaSeries) {
                volumeChart.removeSeries(volumeEmaSeries);
                volumeEmaSeries = null;
            }
            
            // Bollinger Bands for volume
            if (volumeSettings.bb && volumeSettings.bbPeriod > 0 && currentVolumes.length > 0) {
                // `calculateBollingerBands` in this file expects candle objects with `.close`.
                // For volume BB, feed synthetic candles where close=volume.
                const volumeCandles = currentVolumes.map(v => ({ time: v.time, close: v.value }));
                const bbData = calculateBollingerBands(volumeCandles, volumeSettings.bbPeriod, 2);
                const upperPoints = Array.isArray(bbData?.upper)
                    ? bbData.upper
                        .filter(p => p && p.time != null && p.value != null)
                        .map(p => ({ time: p.time, value: (typeof p.value === 'number' ? p.value : parseFloat(p.value)) }))
                        .filter(p => Number.isFinite(p.value))
                    : [];
                const lowerPoints = Array.isArray(bbData?.lower)
                    ? bbData.lower
                        .filter(p => p && p.time != null && p.value != null)
                        .map(p => ({ time: p.time, value: (typeof p.value === 'number' ? p.value : parseFloat(p.value)) }))
                        .filter(p => Number.isFinite(p.value))
                    : [];
                
                if (!volumeBBUpperSeries) {
                    volumeBBUpperSeries = volumeChart.addLineSeries({
                        color: 'rgba(156, 39, 176, 0.7)',
                        lineWidth: 1,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        priceScaleId: 'volume',
                        lastValueVisible: false,
                        priceLineVisible: false,
                    });
                    volumeBBLowerSeries = volumeChart.addLineSeries({
                        color: 'rgba(156, 39, 176, 0.7)',
                        lineWidth: 1,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        priceScaleId: 'volume',
                        lastValueVisible: false,
                        priceLineVisible: false,
                    });
                }
                safeSetData(volumeBBUpperSeries, upperPoints, 'volumeBBUpperSeries');
                safeSetData(volumeBBLowerSeries, lowerPoints, 'volumeBBLowerSeries');
            } else {
                if (volumeBBUpperSeries) {
                    volumeChart.removeSeries(volumeBBUpperSeries);
                    volumeChart.removeSeries(volumeBBLowerSeries);
                    volumeBBUpperSeries = null;
                    volumeBBLowerSeries = null;
                }
            }
            
            // VWAP (on main chart)
            if (volumeSettings.vwap && chart && currentCandles.length > 0 && currentVolumes.length > 0) {
                // Prefer rawVolumes (non-normalized) when available; fall back to currentVolumes.
                const volumeData = (rawVolumes && rawVolumes.length) ? rawVolumes : currentVolumes;
                
                // Only proceed if we actually have volume data.
                if (volumeData.length > 0) {
                    const vwapData = calculateVWAP(currentCandles, volumeData);
                    
                    // Only create series if calculateVWAP returned valid data.
                    if (Array.isArray(vwapData) && vwapData.length > 0) {
                        if (!vwapSeries) {
                            vwapSeries = chart.addLineSeries({
                                color: '#E91E63',
                                lineWidth: 2,
                                lastValueVisible: true,
                                priceLineVisible: false,
                                title: 'VWAP',
                            });
                        }
                        const r = safeSetData(vwapSeries, vwapData, 'vwapSeries');
                        if (!r.ok) {
                            // Keep UI toggle on, but avoid crashing chart internals.
                            try {
                                chart.removeSeries(vwapSeries);
                            } catch (_) {}
                            vwapSeries = null;
                        }
                    }
                }
            } else if (vwapSeries) {
                try {
                    chart.removeSeries(vwapSeries);
                } catch (_) {}
                vwapSeries = null;
            }
            
            // OBV (On-Balance Volume) - displayed as line on volume chart
            if (volumeSettings.obv && volumeChart && currentCandles.length > 0) {
                const obvData = calculateOBV(currentCandles, currentVolumes);
                
                if (!obvSeries) {
                    obvSeries = volumeChart.addLineSeries({
                        color: '#00BCD4',
                        lineWidth: 2,
                        priceScaleId: 'obv',
                        lastValueVisible: false,
                        priceLineVisible: false,
                    });
                    // Add separate scale for OBV
                    volumeChart.priceScale('obv').applyOptions({
                        scaleMargins: { top: 0.1, bottom: 0.1 },
                        visible: false,
                    });
                }
                safeSetData(obvSeries, obvData, 'obvSeries');
            } else if (obvSeries) {
                volumeChart.removeSeries(obvSeries);
                obvSeries = null;
            }
            
            // Volume Delta - colored histogram showing buy vs sell pressure
            if (volumeSettings.delta && volumeChart && currentCandles.length > 0) {
                const deltaData = calculateVolumeDelta(currentCandles, currentVolumes);
                
                if (!volumeDeltaSeries) {
                    volumeDeltaSeries = volumeChart.addHistogramSeries({
                        priceScaleId: 'delta',
                        priceFormat: { type: 'volume' },
                        lastValueVisible: false,
                        priceLineVisible: false,
                    });
                    volumeChart.priceScale('delta').applyOptions({
                        scaleMargins: { top: 0.7, bottom: 0 },
                        visible: false,
                    });
                }
                // Histogram points include color; safeSetData preserves it.
                safeSetData(volumeDeltaSeries, deltaData, 'volumeDeltaSeries');
            } else if (volumeDeltaSeries) {
                volumeChart.removeSeries(volumeDeltaSeries);
                volumeDeltaSeries = null;
            }
            
            // Highlight High Volume - update volume bar colors
            if (volumeSettings.highlight && volumeSeries && currentVolumes.length > 0) {
                highlightHighVolumeBars();
            } else if (volumeSeries && currentVolumes.length > 0) {
                // Apply opacity without highlight
                applyVolumeOpacity();
            }
            
            // Update label
            updateVolumeLabel();
        }
        
        function loadVolumeSettings() {
            const saved = localStorage.getItem('chart_volume_settings');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    volumeSettings = { ...volumeSettings, ...parsed };
                    
                    // Update UI elements
                    const smaCheck = document.getElementById('volSmaEnabled');
                    const smaInput = document.getElementById('volSmaPeriod');
                    const opacityInput = document.getElementById('volOpacity');
                    const opacityVal = document.getElementById('volOpacityValue');
                    
                    if (smaCheck) smaCheck.checked = volumeSettings.smaEnabled;
                    if (smaInput) smaInput.value = volumeSettings.smaPeriod;
                    if (opacityInput) opacityInput.value = volumeSettings.opacity;
                    if (opacityVal) opacityVal.textContent = volumeSettings.opacity + '%';
                } catch(e) {
                    console.error('[Settings] Failed to parse volume settings:', e);
                }
            }
        }
        
        function updateVolumeIndicators() {
            if (!volumeSmaSeries || !currentVolumes) return;
            
            if (volumeSettings.smaEnabled) {
                // Calculate SMA
                const volumes = currentVolumes.map(v => ({ time: v.time, close: v.value })); // Mapping value to close for generic SMA func
                const smaData = calculateSMA(volumes, volumeSettings.smaPeriod);
                
                // Update series
                volumeSmaSeries.applyOptions({
                    visible: true,
                    lineWidth: 1
                });
                safeSetData(volumeSmaSeries, smaData, 'volumeSmaSeries(updateVolumeIndicators)');
            } else {
                volumeSmaSeries.applyOptions({ visible: false });
                try { volumeSmaSeries.setData([]); } catch (_) {}
            }
            
            applyVolumeOpacity();
        }
        
        // Additional series references
        let obvSeries = null;
        let volumeDeltaSeries = null;
        
        function applyVolumeOpacity() {
            const opacity = volumeSettings.opacity / 100;
            
            const updatedVolumes = currentVolumes.map((v, i) => {
                const candle = currentCandles[i];
                const isUp = candle && candle.close >= candle.open;
                
                // Apply opacity to colors
                const r = isUp ? 0 : 255;
                const g = isUp ? 200 : 23;
                const b = isUp ? 83 : 68;
                
                return {
                    ...v,
                    color: `rgba(${r}, ${g}, ${b}, ${opacity})`
                };
            });
            
            // Histogram points include color; safeSetData preserves it.
            safeSetData(volumeSeries, updatedVolumes, 'volumeSeries(applyVolumeOpacity)');
        }
        
        function highlightHighVolumeBars() {
            const opacity = volumeSettings.opacity / 100;
            
            // Calculate average volume
            const volumes = currentVolumes.map(v => v.value);
            const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
            const threshold = avgVolume * 1.5;  // 50% above average
            
            // Create updated volume data with highlight colors
            const highlightedVolumes = currentVolumes.map((v, i) => {
                const candle = currentCandles[i];
                const isUp = candle && candle.close >= candle.open;
                const isHighVolume = v.value > threshold;
                
                let color;
                if (isHighVolume) {
                    // Brighter colors for high volume (full opacity)
                    color = isUp ? `rgba(0, 230, 118, ${Math.min(opacity + 0.2, 1)})` : `rgba(255, 82, 82, ${Math.min(opacity + 0.2, 1)})`;
                } else {
                    // Normal colors with opacity
                    color = isUp ? `rgba(0, 200, 83, ${opacity})` : `rgba(255, 23, 68, ${opacity})`;
                }
                
                return { ...v, color };
            });
            
            safeSetData(volumeSeries, highlightedVolumes, 'volumeSeries(highlightHighVolumeBars)');
        }
        
        function calculateOBV(candles, volumes) {
            const result = [];
            let obv = 0;
            
            for (let i = 0; i < candles.length; i++) {
                const volume = volumes[i]?.value || 0;
                
                if (i === 0) {
                    obv = volume;
                } else {
                    const prevClose = candles[i - 1].close;
                    const currClose = candles[i].close;
                    
                    if (currClose > prevClose) {
                        obv += volume;
                    } else if (currClose < prevClose) {
                        obv -= volume;
                    }
                    // If equal, OBV stays the same
                }
                
                result.push({
                    time: candles[i].time,
                    value: obv
                });
            }
            return result;
        }
        
        function calculateVolumeDelta(candles, volumes) {
            const result = [];
            
            for (let i = 0; i < candles.length; i++) {
                const candle = candles[i];
                const volume = volumes[i]?.value || 0;
                
                // Estimate buy/sell based on candle body position
                const bodySize = Math.abs(candle.close - candle.open);
                const range = candle.high - candle.low;
                const bodyRatio = range > 0 ? bodySize / range : 0.5;
                
                // If close > open, more buying pressure
                const isUp = candle.close >= candle.open;
                const delta = isUp ? volume * bodyRatio : -volume * bodyRatio;
                
                result.push({
                    time: candle.time,
                    value: delta,
                    color: delta >= 0 ? 'rgba(0, 230, 118, 0.6)' : 'rgba(255, 82, 82, 0.6)'
                });
            }
            return result;
        }
        
        function updateVolumeLabel() {
            const labelParts = ['Объём'];
            if (volumeSettings.sma) labelParts.push(`SMA ${volumeSettings.smaPeriod}`);
            if (volumeSettings.ema) labelParts.push(`EMA ${volumeSettings.emaPeriod}`);
            if (volumeSettings.bb) labelParts.push(`BB ${volumeSettings.bbPeriod}`);
            if (volumeSettings.obv) labelParts.push('OBV');
            if (volumeSettings.delta) labelParts.push('Delta');
            if (volumeSettings.highlight) labelParts.push('HL');
            
            const labelEl = document.querySelector('.volume-label');
            if (labelEl) {
                labelEl.innerHTML = labelParts.join(' | ');
            }
        }
        
        function applySettingChange(key, value) {
            // console.log('[Settings] Applying:', key, '=', value, 'chart:', !!chart, 'candleSeries:', !!candleSeries);
            
            // Some settings don't require chart
            const noChartNeeded = ['orderBook', 'recentTrades', 'connectionStatus', 'tradeMarkers', 'liquidations', 'infiniteHistory'];
            
            if (!noChartNeeded.includes(key) && (!chart || !candleSeries)) {
                console.warn('[Settings] Chart not ready for:', key);
                return;
            }
            
            try {
                switch (key) {
                    case 'gridLines':
                        chart.applyOptions({
                            grid: {
                                vertLines: { visible: value, color: 'rgba(42, 46, 57, 0.6)' },
                                horzLines: { visible: value, color: 'rgba(42, 46, 57, 0.6)' }
                            }
                    });
                    break;
                    
                case 'volumeChart':
                    // Show/hide entire volume panel including resizer
                    const volumePanel = document.getElementById('indicatorsPanel');
                    const volumeResizer = document.getElementById('chartResizer');
                    if (volumePanel) {
                        volumePanel.style.display = value ? 'block' : 'none';
                    }
                    if (volumeResizer) {
                        volumeResizer.style.display = value ? 'block' : 'none';
                    }
                    break;
                    
                case 'watermark':
                    chart.applyOptions({
                        watermark: {
                            visible: value,
                            text: currentSymbol,
                            fontSize: 48,
                            color: 'rgba(100, 100, 100, 0.15)',
                            fontFamily: 'Inter, sans-serif',
                            fontWeight: 'bold'
                        }
                    });
                    break;
                    
                case 'crosshair':
                    chart.applyOptions({
                        crosshair: {
                            mode: value ? LightweightCharts.CrosshairMode.Normal : LightweightCharts.CrosshairMode.Hidden,
                            vertLine: {
                                visible: value,
                                color: 'rgba(255, 255, 255, 0.4)',
                                width: 1,
                                style: LightweightCharts.LineStyle.Dashed,
                                labelVisible: value
                            },
                            horzLine: {
                                visible: value,
                                color: 'rgba(255, 255, 255, 0.4)',
                                width: 1,
                                style: LightweightCharts.LineStyle.Dashed,
                                labelVisible: value
                            }
                        }
                    });
                    break;
                    
                case 'lastPriceLine':
                    candleSeries.applyOptions({
                        lastValueVisible: value,
                        priceLineVisible: value
                    });
                    break;
                    
                case 'highLowLines':
                    updateHighLowLines(value);
                    break;
                    
                case 'openPriceLine':
                    updateOpenPriceLine(value);
                    break;
                    
                case 'orderBook':
                    // Hide/show right panel Order Book tab content
                    const orderbookPanel = document.getElementById('orderbookPanel');
                    const orderbookTab = document.querySelector('.panel-tab[data-panel="orderbook"]');
                    if (orderbookPanel) {
                        orderbookPanel.style.display = value ? 'block' : 'none';
                    }
                    if (orderbookTab) {
                        orderbookTab.style.display = value ? 'block' : 'none';
                    }
                    break;
                    
                case 'recentTrades':
                    // Hide/show right panel Trades tab content
                    const tradesPanel = document.getElementById('tradesPanel');
                    const tradesTab = document.querySelector('.panel-tab[data-panel="trades"]');
                    if (tradesPanel) {
                        tradesPanel.style.display = value ? 'block' : 'none';
                    }
                    if (tradesTab) {
                        tradesTab.style.display = value ? 'block' : 'none';
                    }
                    break;
                    
                case 'connectionStatus':
                    // Hide/show connection status in footer
                    const connectionDot = document.getElementById('connectionDot');
                    const connectionText = document.getElementById('connectionStatus');
                    if (connectionDot) connectionDot.style.display = value ? 'inline-block' : 'none';
                    if (connectionText) connectionText.style.display = value ? 'inline' : 'none';
                    break;
                    
                case 'supportResistance':
                    updateSupportResistance(value);
                    break;
                    
                case 'patternDoji':
                case 'patternHammer':
                case 'patternEngulfing':
                case 'patternStar':
                case 'patternSoldiers':
                    // Update pattern markers when any pattern setting changes
                    const anyPatternEnabled = chartSettings.patternDoji || chartSettings.patternHammer || 
                                              chartSettings.patternEngulfing || chartSettings.patternStar || 
                                              chartSettings.patternSoldiers;
                    if (anyPatternEnabled) {
                        updatePatternMarkers();
                    } else {
                        clearPatternMarkers();
                    }
                    break;
                    
                case 'tradeMarkers':
                    // Toggle trade markers on chart (buy/sell signals from strategy)
                    // console.log('[Settings] Trade markers:', value ? 'enabled' : 'disabled');
                    renderTradeMarkers(value);
                    break;
                    
                case 'liquidations':
                    // Toggle liquidation markers
                    // console.log('[Settings] Liquidations:', value ? 'enabled' : 'disabled');
                    // Will be implemented with liquidation data feed
                    break;
                    
                case 'infiniteHistory':
                    // Toggle auto-load more data when scrolling left
                    // console.log('[Settings] Infinite history:', value ? 'enabled' : 'disabled');
                    break;
                    
                case 'autoScroll':
                    // Toggle auto-scroll to latest candle
                    // console.log('[Settings] Auto-scroll:', value ? 'enabled' : 'disabled');
                    if (value && chart) {
                        chart.timeScale().scrollToRealTime();
                    }
                    break;

                case 'customScrollbar':
                    updateScrollbar(value);
                    break;
                case 'pulse':
                    updatePulse(value);
                    break;
                case 'countdown':
                    updateCountdown(value);
                    break;
            }
            } catch (e) {
                console.error('[Settings] Error applying setting:', key, e);
            }
        }
        
        // ---- Visual Enhancement Implementations ----
        

        function updateScrollbar(enabled) {
            if (enabled) {
                document.body.classList.add('custom-scrollbar');
            } else {
                document.body.classList.remove('custom-scrollbar');
            }
        }

        let pulseInterval = null;
        function updatePulse(enabled) {
            const container = document.getElementById('pricePulse');
            if (!container) return;
            
            if (enabled) {
                container.style.display = 'block';
                // Start tracking price updates to move the dot
                if (!pulseInterval) {
                     // Check position every 100ms
                    pulseInterval = setInterval(updatePulsePosition, 100);
                }
            } else {
                container.style.display = 'none';
                if (pulseInterval) {
                    clearInterval(pulseInterval);
                    pulseInterval = null;
                }
            }
        }
        
        function updatePulsePosition() {
             if (!chart || !candleSeries || !currentCandles.length) return;
             
             const lastCandle = currentCandles[currentCandles.length - 1];
             const price = lastCandle.close;
             
             // Convert time/price to coordinates
             const coordinate = candleSeries.priceToCoordinate(price);
             if (coordinate === null) return;
             
             const container = document.getElementById('pricePulse');
             // Adjust vertical position (relative to chart container)
             // We need to account that chart container might be resized
             // But simplest is 'top' style
             container.style.top = `${coordinate}px`;
             
             // If up/down, change color
             const isUp = lastCandle.close >= lastCandle.open;
             const ring = container.querySelector('.pulse-ring');
             const dot = container.querySelector('.pulse-dot');
             
             const color = isUp ? 'var(--accent-green)' : 'var(--accent-red)';
             if (ring) ring.style.backgroundColor = color;
             if (dot) dot.style.backgroundColor = color;
        }

        let countdownInterval = null;
        function updateCountdown(enabled) {
             const el = document.getElementById('candleCountdown');
             if (!el) return;
             
             if (enabled) {
                 el.style.display = 'block';
                 if (!countdownInterval) {
                     countdownInterval = setInterval(refreshCountdown, 1000);
                     refreshCountdown(); // Immediate
                 }
             } else {
                 el.style.display = 'none';
                 if (countdownInterval) {
                     clearInterval(countdownInterval);
                     countdownInterval = null;
                 }
             }
        }
        
        function refreshCountdown() {
             // Logic to find time remaining in current candle
             // We know 'currentTimeframe' (e.g. '60' -> 60 minutes)
             // We need current time vs next candle open time
             const now = new Date();
             const nowSec = Math.floor(now.getTime() / 1000);
             
             let periodSec = 60; // default 1m
             const tf = currentTimeframe;
             if (tf === 'D') periodSec = 86400;
             else if (tf === 'W') periodSec = 604800;
             else periodSec = parseInt(tf) * 60;
             
             // Align to period
             // Next candle starts at: floor(now / period) * period + period
             const nextCandleTime = (Math.floor(nowSec / periodSec) + 1) * periodSec;
             let diff = nextCandleTime - nowSec;
             
             if (diff < 0) diff = 0;
             
             // Format MM:SS or HH:MM:SS
             const h = Math.floor(diff / 3600);
             const m = Math.floor((diff % 3600) / 60);
             const s = diff % 60;
             
             let text = '';
             if (h > 0) {
                 text = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
             } else {
                 text = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
             }
             
             const el = document.getElementById('candleCountdown');
             if (el) {
                 el.textContent = text;
                 // Add nearing-close class if < 10% or < 30 sec
                 if (diff < 30) el.classList.add('nearing-close');
                 else el.classList.remove('nearing-close');
             }
        }

        function renderTradeMarkers(enabled) {
            if (!candleSeries) return;

            if (enabled) {
                 // Mock markers - last 5 "trades"
                 const markers = [];
                 if (currentCandles.length > 50) {
                     for (let i = 0; i < 5; i++) {
                         const idx = currentCandles.length - 1 - (i * 15);
                         if (idx < 0) continue;
                         const c = currentCandles[idx];
                         const isBuy = Math.random() > 0.5;
                         markers.push({
                             time: c.time,
                             position: isBuy ? 'belowBar' : 'aboveBar',
                             color: isBuy ? '#00E676' : '#FF5252',
                             shape: isBuy ? 'arrowUp' : 'arrowDown',
                             text: isBuy ? 'BUY' : 'SELL',
                             size: 1
                         });
                     }
                 }
                 candleSeries.setMarkers(markers);
            } else {
                 candleSeries.setMarkers([]); 
                 // If patterns enabled, re-run updatePatternMarkers()
                 const anyPatternEnabled = chartSettings.patternDoji || chartSettings.patternHammer;
                 if (anyPatternEnabled) {
                     updatePatternMarkers();
                 }
            }
        }

        // Fetch 24h ticker data from Bybit REST API
        async function fetch24hTicker() {
            try {
                const response = await fetch(`https://api.bybit.com/v5/market/tickers?category=linear&symbol=${currentSymbol}`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.result?.list?.[0]) {
                        const ticker = data.result.list[0];
                        // Map Bybit API fields to our format
                        latestTickerData = {
                            lastPrice: ticker.lastPrice,
                            highPrice24h: ticker.highPrice24h,
                            lowPrice24h: ticker.lowPrice24h,
                            prevPrice24h: ticker.prevPrice24h,
                            price24hPcnt: ticker.price24hPcnt,
                            volume24h: ticker.volume24h,
                            turnover24h: ticker.turnover24h
                        };
                        // console.log('[24h] Ticker loaded:', latestTickerData.highPrice24h, latestTickerData.lowPrice24h);
                        return true;
                    }
                }
            } catch (e) {
                console.warn('[24h] Failed to fetch ticker:', e);
            }
            return false;
        }
        
        // Synchronous version for WebSocket updates (data already available)
        function updateHighLowLinesSync() {
            if (!candleSeries || !latestTickerData) return;
            
            try {
                // Always remove existing lines first
                if (highPriceLine) {
                    try { candleSeries.removePriceLine(highPriceLine); } catch(e) {}
                    highPriceLine = null;
                }
                if (lowPriceLine) {
                    try { candleSeries.removePriceLine(lowPriceLine); } catch(e) {}
                    lowPriceLine = null;
                }
                
                const high24h = parseFloat(latestTickerData.highPrice24h);
                const low24h = parseFloat(latestTickerData.lowPrice24h);
                
                if (!isNaN(high24h) && high24h > 0) {
                    highPriceLine = candleSeries.createPriceLine({
                        price: high24h,
                        color: '#26a69a',
                        lineWidth: 1,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        axisLabelVisible: true,
                        title: '24h High'
                    });
                }
            
                if (!isNaN(low24h) && low24h > 0) {
                    lowPriceLine = candleSeries.createPriceLine({
                        price: low24h,
                        color: '#ef5350',
                        lineWidth: 1,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        axisLabelVisible: true,
                        title: '24h Low'
                    });
                }
            } catch (e) {
                console.warn('Error updating high/low lines sync:', e);
            }
        }
        
        async function updateHighLowLines(show) {
            if (!candleSeries) return;
            
            try {
                // Always remove existing lines first
                if (highPriceLine) {
                    try { candleSeries.removePriceLine(highPriceLine); } catch(e) {}
                    highPriceLine = null;
                }
                if (lowPriceLine) {
                    try { candleSeries.removePriceLine(lowPriceLine); } catch(e) {}
                    lowPriceLine = null;
                }
                
                if (show) {
                    // Fetch 24h data if not available
                    if (!latestTickerData?.highPrice24h) {
                        await fetch24hTicker();
                    }
                    
                    if (latestTickerData) {
                        const high24h = parseFloat(latestTickerData.highPrice24h);
                        const low24h = parseFloat(latestTickerData.lowPrice24h);
                        
                        if (!isNaN(high24h) && high24h > 0) {
                            highPriceLine = candleSeries.createPriceLine({
                                price: high24h,
                                color: '#26a69a',
                                lineWidth: 1,
                                lineStyle: LightweightCharts.LineStyle.Dashed,
                                axisLabelVisible: true,
                                title: '24h High'
                            });
                            // console.log('[24h] High line created at', high24h);
                        }
                    
                        if (!isNaN(low24h) && low24h > 0) {
                            lowPriceLine = candleSeries.createPriceLine({
                                price: low24h,
                                color: '#ef5350',
                                lineWidth: 1,
                                lineStyle: LightweightCharts.LineStyle.Dashed,
                                axisLabelVisible: true,
                                title: '24h Low'
                            });
                            // console.log('[24h] Low line created at', low24h);
                        }
                    }
                }
            } catch (e) {
                console.warn('Error updating high/low lines:', e);
            }
        }
        
        async function updateOpenPriceLine(show) {
            if (!candleSeries) return;
            
            try {
                if (openPriceLine) {
                    try { candleSeries.removePriceLine(openPriceLine); } catch(e) {}
                    openPriceLine = null;
                }
                
                if (show) {
                    // Fetch 24h data if not available
                    if (!latestTickerData?.prevPrice24h) {
                        await fetch24hTicker();
                    }
                    
                    if (latestTickerData) {
                        const prevPrice24h = parseFloat(latestTickerData.prevPrice24h);
                        if (!isNaN(prevPrice24h) && prevPrice24h > 0) {
                            openPriceLine = candleSeries.createPriceLine({
                                price: prevPrice24h,
                                color: '#7b68ee',
                                lineWidth: 1,
                                lineStyle: LightweightCharts.LineStyle.Dotted,
                                axisLabelVisible: true,
                                title: 'Open 24h'
                            });
                            // console.log('[24h] Open line created at', prevPrice24h);
                        }
                    }
                }
            } catch (e) {
                console.warn('Error updating open price line:', e);
            }
        }
        
        // Support/Resistance Detection
        function updateSupportResistance(show) {
            if (!candleSeries) return;
            
            try {
                // Remove existing S/R lines
                supportResistanceLines.forEach(line => {
                    try { candleSeries.removePriceLine(line); } catch(e) {}
                });
                supportResistanceLines = [];
                
                if (show && currentCandles && currentCandles.length > 20) {
                    const levels = detectSupportResistance(currentCandles);
                    
                    // Separate counters for support and resistance
                    let supportCount = 0;
                    let resistanceCount = 0;
                    
                    levels.forEach((level) => {
                        const isResistance = level.type === 'resistance';
                        const label = isResistance ? 'R' + (++resistanceCount) : 'S' + (++supportCount);
                        
                        const line = candleSeries.createPriceLine({
                            price: level.price,
                            color: isResistance ? '#ef5350' : '#26a69a',
                            lineWidth: 1,
                            lineStyle: LightweightCharts.LineStyle.Solid,
                            axisLabelVisible: true,
                            title: label
                        });
                        supportResistanceLines.push(line);
                    });
                    
                    if (levels.length > 0) {
                        // console.log('[S/R] Added', supportCount, 'supports,', resistanceCount, 'resistances');
                    }
                }
            } catch (e) {
                console.warn('Error updating S/R lines:', e);
            }
        }
        
        function detectSupportResistance(candles, sensitivity = 3) {
            const levels = [];
            const pricePoints = [];
            
            // Collect swing highs and lows
            for (let i = sensitivity; i < candles.length - sensitivity; i++) {
                let isSwingHigh = true;
                let isSwingLow = true;
                
                for (let j = 1; j <= sensitivity; j++) {
                    if (candles[i].high <= candles[i - j].high || candles[i].high <= candles[i + j].high) {
                        isSwingHigh = false;
                    }
                    if (candles[i].low >= candles[i - j].low || candles[i].low >= candles[i + j].low) {
                        isSwingLow = false;
                    }
                }
                
                if (isSwingHigh) pricePoints.push({ price: candles[i].high, type: 'resistance' });
                if (isSwingLow) pricePoints.push({ price: candles[i].low, type: 'support' });
            }
            
            // Cluster nearby levels (within 0.3%)
            const clustered = [];
            const tolerance = 0.003;
            
            pricePoints.forEach(point => {
                const existing = clustered.find(c => 
                    Math.abs(c.price - point.price) / point.price < tolerance
                );
                if (existing) {
                    existing.touches++;
                } else {
                    clustered.push({ ...point, touches: 1 });
                }
            });
            
            // Filter by minimum touches
            const filtered = clustered.filter(c => c.touches >= 2);
            
            // Get current price for sorting relative to it
            const currentPrice = candles[candles.length - 1]?.close || 0;
            
            // Separate resistances (above current price) and supports (below)
            const resistances = filtered
                .filter(c => c.price > currentPrice)
                .sort((a, b) => a.price - b.price)  // Nearest first (ascending)
                .slice(0, 3);  // Max 3 resistance levels
                
            const supports = filtered
                .filter(c => c.price <= currentPrice)
                .sort((a, b) => b.price - a.price)  // Nearest first (descending)
                .slice(0, 3);  // Max 3 support levels
            
            // Return resistances first, then supports
            return [...resistances, ...supports];
        }
        
        // Pattern Detection Markers
        let patternMarkers = [];
        
        function updatePatternMarkers() {
            if (!candleSeries || !currentCandles || currentCandles.length < 5) return;
            
            // console.log('[Patterns] Running detection, settings:', chartSettings);
            
            try {
                const markers = [];
                const candles = currentCandles;
                
                for (let i = 2; i < candles.length; i++) {
                    const c = candles[i];
                    const prev = candles[i - 1];
                    const prev2 = candles[i - 2];
                    
                    const body = Math.abs(c.close - c.open);
                    const range = c.high - c.low;
                    const upperWick = c.high - Math.max(c.open, c.close);
                    const lowerWick = Math.min(c.open, c.close) - c.low;
                    
                    // Doji
                    if (chartSettings.patternDoji && body / range < 0.1 && range > 0) {
                        markers.push({
                            time: c.time,
                            position: 'aboveBar',
                            color: '#ffeb3b',
                            shape: 'circle',
                            text: 'D'
                        });
                    }
                    
                    // Hammer / Hanging Man
                    if (chartSettings.patternHammer && lowerWick > body * 2 && upperWick < body * 0.5) {
                        const isBullish = c.close < prev.close; // Hammer at bottom
                        markers.push({
                            time: c.time,
                            position: isBullish ? 'belowBar' : 'aboveBar',
                            color: isBullish ? '#26a69a' : '#ef5350',
                            shape: 'arrowUp',
                            text: 'H'
                        });
                    }
                    
                    // Engulfing Pattern
                    if (chartSettings.patternEngulfing && i > 0) {
                        const currBody = Math.abs(c.close - c.open);
                        const prevBody = Math.abs(prev.close - prev.open);
                        
                        const prevBearish = prev.close < prev.open;
                        const prevBullish = prev.close > prev.open;
                        const currBearish = c.close < c.open;
                        const currBullish = c.close > c.open;
                        
                        // Bullish Engulfing: prev bearish (red), curr bullish (green)
                        // Current candle's body completely covers previous candle's body
                        if (prevBearish && currBullish) {
                            // For bullish engulf: curr open below prev close, curr close above prev open
                            if (c.open <= prev.close && c.close >= prev.open) {
                                markers.push({
                                    time: c.time,
                                    position: 'belowBar',
                                    color: '#26a69a',
                                    shape: 'arrowUp',
                                    text: 'BE'
                                });
                            }
                        }
                        
                        // Bearish Engulfing: prev bullish (green), curr bearish (red)
                        if (prevBullish && currBearish) {
                            // For bearish engulf: curr open above prev close, curr close below prev open
                            if (c.open >= prev.close && c.close <= prev.open) {
                                markers.push({
                                    time: c.time,
                                    position: 'aboveBar',
                                    color: '#ef5350',
                                    shape: 'arrowDown',
                                    text: 'SE'
                                });
                            }
                        }
                    }
                    
                    // Morning/Evening Star (3-candle pattern)
                    if (chartSettings.patternStar && i >= 2) {
                        const first = prev2;
                        const middle = prev;
                        const third = c;
                        
                        const firstBody = Math.abs(first.close - first.open);
                        const middleBody = Math.abs(middle.close - middle.open);
                        const thirdBody = Math.abs(third.close - third.open);
                        
                        // Morning Star
                        if (first.close < first.open && firstBody > middleBody * 2 &&
                            third.close > third.open && thirdBody > middleBody * 2 &&
                            third.close > (first.open + first.close) / 2) {
                            markers.push({
                                time: c.time,
                                position: 'belowBar',
                                color: '#26a69a',
                                shape: 'arrowUp',
                                text: 'MS'
                            });
                        }
                        
                        // Evening Star
                        if (first.close > first.open && firstBody > middleBody * 2 &&
                            third.close < third.open && thirdBody > middleBody * 2 &&
                            third.close < (first.open + first.close) / 2) {
                            markers.push({
                                time: c.time,
                                position: 'aboveBar',
                                color: '#ef5350',
                                shape: 'arrowDown',
                                text: 'ES'
                            });
                        }
                    }
                    
                    // Three White Soldiers / Three Black Crows (3-candle pattern)
                    if (chartSettings.patternSoldiers && i >= 2) {
                        const first = prev2;
                        const second = prev;
                        const third = c;
                        
                        const firstBody = first.close - first.open;
                        const secondBody = second.close - second.open;
                        const thirdBody = third.close - third.open;
                        
                        const avgBody = (Math.abs(firstBody) + Math.abs(secondBody) + Math.abs(thirdBody)) / 3;
                        const minBodySize = avgBody * 0.5; // Each body should be at least 50% of average
                        
                        // Three White Soldiers (bullish)
                        // All three candles are bullish, each closes higher than previous
                        // Each candle opens within previous candle's body
                        if (firstBody > minBodySize && secondBody > minBodySize && thirdBody > minBodySize &&
                            first.close > first.open && second.close > second.open && third.close > third.open &&
                            second.close > first.close && third.close > second.close &&
                            second.open >= first.open && second.open <= first.close &&
                            third.open >= second.open && third.open <= second.close) {
                            markers.push({
                                time: c.time,
                                position: 'belowBar',
                                color: '#26a69a',
                                shape: 'arrowUp',
                                text: '3WS'
                            });
                        }
                        
                        // Three Black Crows (bearish)
                        // All three candles are bearish, each closes lower than previous
                        // Each candle opens within previous candle's body
                        if (-firstBody > minBodySize && -secondBody > minBodySize && -thirdBody > minBodySize &&
                            first.close < first.open && second.close < second.open && third.close < third.open &&
                            second.close < first.close && third.close < second.close &&
                            second.open <= first.open && second.open >= first.close &&
                            third.open <= second.open && third.open >= second.close) {
                            markers.push({
                                time: c.time,
                                position: 'aboveBar',
                                color: '#ef5350',
                                shape: 'arrowDown',
                                text: '3BC'
                            });
                        }
                    }
                }
                
                // Set markers on chart
                candleSeries.setMarkers(markers);
                patternMarkers = markers;
                
                if (markers.length > 0) {
                    // console.log('[Patterns] Found', markers.length, 'patterns');
                }
            } catch (e) {
                console.warn('Error updating pattern markers:', e);
            }
        }
        
        function clearPatternMarkers() {
            if (candleSeries) {
                candleSeries.setMarkers([]);
                patternMarkers = [];
            }
        }
        
        function applyAllSettings() {
            Object.keys(chartSettings).forEach(key => {
                applySettingChange(key, chartSettings[key]);
            });
        }
        
        function resetSettings() {
            if (!confirm('Reset all settings to defaults?')) return;
            
            chartSettings = { ...defaultSettings };
            saveSettings();
            
            // Update checkboxes
            Object.keys(chartSettings).forEach(key => {
                let checkbox = document.getElementById(`setting-${key}`);
                
                // Handle pattern checkboxes
                if (!checkbox && key.startsWith('pattern')) {
                    const patternName = key.replace('pattern', '').toLowerCase();
                    checkbox = document.getElementById(`setting-pattern-${patternName}`);
                }
                
                if (checkbox) {
                    checkbox.checked = chartSettings[key];
                }
            });
            
            // Apply all settings
            applyAllSettings();
            clearPatternMarkers();
            
            showToast('Settings reset to defaults', 'info');
        }

        // ---- Toast / notifications (safe fallback) ----
        // Some code paths call showToast(), but older builds didn't include an implementation.
        // Keep this lightweight and dependency-free.
        function showToast(message, type) {
            try {
                const text = String(message ?? '');
                const t = String(type ?? 'info');

                let container = document.getElementById('toastContainer');
                if (!container) {
                    container = document.createElement('div');
                    container.id = 'toastContainer';
                    container.style.position = 'fixed';
                    container.style.right = '16px';
                    container.style.bottom = '16px';
                    container.style.zIndex = '99999';
                    container.style.display = 'flex';
                    container.style.flexDirection = 'column';
                    container.style.gap = '8px';
                    document.body.appendChild(container);
                }

                const el = document.createElement('div');
                el.className = `toast toast-${t}`;
                el.textContent = text;

                // Minimal styling (doesn't rely on app CSS).
                el.style.padding = '10px 12px';
                el.style.borderRadius = '8px';
                el.style.fontFamily = 'Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';
                el.style.fontSize = '13px';
                el.style.boxShadow = '0 6px 30px rgba(0,0,0,0.35)';
                el.style.border = '1px solid rgba(255,255,255,0.08)';
                el.style.background = 'rgba(20, 20, 20, 0.92)';
                el.style.color = '#fff';

                if (t === 'error') el.style.borderColor = 'rgba(255, 82, 82, 0.5)';
                if (t === 'success') el.style.borderColor = 'rgba(0, 230, 118, 0.5)';
                if (t === 'warning') el.style.borderColor = 'rgba(255, 193, 7, 0.5)';

                container.appendChild(el);

                // Auto-remove
                setTimeout(() => {
                    try {
                        el.remove();
                        if (container && container.childElementCount === 0) container.remove();
                    } catch (_) {}
                }, 2500);
            } catch (e) {
                // Last resort: do not crash UI.
                try { console.log('[Toast]', message, type); } catch (_) {}
            }
        }
        
        function openSettingsModal() {
            // console.log('[Settings] Opening modal...');
            loadSettings(); // Reload from storage
            const modal = document.getElementById('settingsModal');
            // console.log('[Settings] Modal element:', modal);
            // console.log('[Settings] Modal classList before:', modal?.classList.toString());
            if (modal) {
                modal.classList.remove('hidden');
                // console.log('[Settings] Modal classList after:', modal.classList.toString());
                
                // Initialize draggable on first open
                const modalContent = modal.querySelector('.modal');
                if (modalContent && !modalContent.dataset.dragInit) {
                    initDraggableModal(modalContent);
                    modalContent.dataset.dragInit = 'true';
                }
            } else {
                console.error('[Settings] Modal element not found!');
            }
        }
        
        // Make settings modal draggable
        function initDraggableModal(modalElement) {
            const header = modalElement.querySelector('.modal-header');
            if (!header) return;
            
            let isDragging = false;
            let startX, startY, startLeft, startTop;
            
            // Set initial position if not set
            if (!modalElement.style.top) {
                modalElement.style.top = '60px';
                modalElement.style.right = '20px';
            }
            
            header.addEventListener('mousedown', (e) => {
                // Don't drag if clicking close button
                if (e.target.closest('.close-btn')) return;
                
                isDragging = true;
                modalElement.classList.add('dragging');
                
                // Get current position
                const rect = modalElement.getBoundingClientRect();
                startX = e.clientX;
                startY = e.clientY;
                startLeft = rect.left;
                startTop = rect.top;
                
                // Switch from right positioning to left positioning for dragging
                modalElement.style.left = rect.left + 'px';
                modalElement.style.top = rect.top + 'px';
                modalElement.style.right = 'auto';
                
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                let newLeft = startLeft + dx;
                let newTop = startTop + dy;
                
                // Keep within viewport bounds
                const maxLeft = window.innerWidth - modalElement.offsetWidth - 10;
                const maxTop = window.innerHeight - modalElement.offsetHeight - 10;
                
                newLeft = Math.max(10, Math.min(newLeft, maxLeft));
                newTop = Math.max(10, Math.min(newTop, maxTop));
                
                modalElement.style.left = newLeft + 'px';
                modalElement.style.top = newTop + 'px';
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    modalElement.classList.remove('dragging');
                }
            });
        }
        
        function closeSettingsModal() {
            document.getElementById('settingsModal').classList.add('hidden');
        }
        
        function switchSettingsTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.settings-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });
            
            // Update panels
            document.querySelectorAll('.settings-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === `settings-${tabName}`);
            });
        }
        
        // ==================== PRICE ALERTS SYSTEM ====================
        let priceAlerts = [];
        let alertIdCounter = 0;
        
        function openAlertsModal() {
            document.getElementById('alertsModal').classList.remove('hidden');
            // Set default price to current price
            const priceEl = document.getElementById('currentPrice');
            if (priceEl) {
                const price = parseFloat(priceEl.textContent.replace(/[$,]/g, ''));
                document.getElementById('alertPrice').value = price.toFixed(2);
            }
            renderAlertsList();
        }
        
        function closeAlertsModal() {
            document.getElementById('alertsModal').classList.add('hidden');
        }
        
        function createAlert() {
            const condition = document.getElementById('alertCondition').value;
            const price = parseFloat(document.getElementById('alertPrice').value);
            const message = document.getElementById('alertMessage').value;
            
            if (isNaN(price) || price <= 0) {
                alert('Please enter a valid price');
                return;
            }
            
            const alert = {
                id: ++alertIdCounter,
                symbol: currentSymbol,
                condition,
                price,
                message: message || `${currentSymbol} ${condition} $${price.toFixed(2)}`,
                triggered: false,
                createdAt: new Date().toISOString()
            };
            
            priceAlerts.push(alert);
            saveAlerts();
            renderAlertsList();
            updateAlertBadge();
            
            // Clear form
            document.getElementById('alertMessage').value = '';
            
            // Add price line to chart
            addAlertPriceLine(alert);
        }
        
        function deleteAlert(id) {
            const index = priceAlerts.findIndex(a => a.id === id);
            if (index !== -1) {
                removeAlertPriceLine(priceAlerts[index]);
                priceAlerts.splice(index, 1);
                saveAlerts();
                renderAlertsList();
                updateAlertBadge();
            }
        }
        
        function renderAlertsList() {
            const container = document.getElementById('alertsList');
            if (priceAlerts.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">No alerts set. Add your first alert above.</div>';
                return;
            }
            
            container.innerHTML = priceAlerts.map(alert => {
                const conditionText = {
                    'above': '↑ Above',
                    'below': '↓ Below',
                    'cross_up': '↗ Crosses Up',
                    'cross_down': '↘ Crosses Down'
                }[alert.condition];
                
                return `
                    <div class="alert-item ${alert.triggered ? 'triggered' : ''}">
                        <div class="alert-item-info">
                            <div class="alert-item-condition">
                                ${alert.symbol} ${conditionText} ${formatPrice(alert.price)}
                            </div>
                            <div class="alert-item-message">${alert.message}</div>
                        </div>
                        <button class="btn-danger" onclick="deleteAlert(${alert.id})">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                `;
            }).join('');
        }
        
        function addAlertPriceLine(alert) {
            // Add horizontal line at alert price
            if (candleSeries && candleSeries.createPriceLine) {
                const lineColor = alert.condition.includes('above') || alert.condition.includes('up') 
                    ? '#3fb950' : '#f85149';
                    
                alert.priceLine = candleSeries.createPriceLine({
                    price: alert.price,
                    color: lineColor,
                    lineWidth: 1,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    axisLabelVisible: true,
                    title: `Alert: ${alert.condition}`
                });
            }
        }
        
        function removeAlertPriceLine(alert) {
            if (alert.priceLine && candleSeries) {
                candleSeries.removePriceLine(alert.priceLine);
            }
        }
        
        function checkAlerts(currentPrice) {
            priceAlerts.forEach(alert => {
                if (alert.triggered || alert.symbol !== currentSymbol) return;
                
                let shouldTrigger = false;
                
                switch (alert.condition) {
                    case 'above':
                        shouldTrigger = currentPrice >= alert.price;
                        break;
                    case 'below':
                        shouldTrigger = currentPrice <= alert.price;
                        break;
                    case 'cross_up':
                    case 'cross_down':
                        // Would need previous price for crossing detection
                        break;
                }
                
                if (shouldTrigger) {
                    triggerAlert(alert);
                }
            });
        }
        
        function triggerAlert(alert) {
            alert.triggered = true;
            saveAlerts();
            
            // Show notification
            showAlertNotification(alert);
            
            // Play sound if available
            try {
                const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2teleAgAOIZodJaCckAVPYuoyuFGRggAUzxhfJSJe1kkL3iYsdDcX04MADdNZ4ORgnleMjZwkKvDzGBQDQArS2WAj4l9ZkQ2a4ifrsC7Wk8QACdNaIONhnhdQDZsiKO5yLNYThAAKU5ngIuIfGZDNWuJo7jLt1lPEAApT2d/ioZ7YUA1a4misci4Wk8QAClPZ3+KhXpfQDVriaGxybdaTxAAKU9nf4qFel9ANWuJobHJt1pPEAA=');
                audio.play();
            } catch (e) {}
            
            // Update badge
            updateAlertBadge();
            renderAlertsList();
        }
        
        function showAlertNotification(alert) {
            const notification = document.createElement('div');
            notification.className = `trade-notification ${alert.condition.includes('up') ? 'buy' : 'sell'}`;
            notification.innerHTML = `
                <i class="bi bi-bell-fill"></i>
                <div>
                    <strong>Alert Triggered!</strong>
                    <div style="font-size: 12px;">${alert.message}</div>
                </div>
            `;
            document.body.appendChild(notification);
            
            setTimeout(() => notification.remove(), 5000);
        }
        
        function updateAlertBadge() {
            const activeAlerts = priceAlerts.filter(a => !a.triggered).length;
            const badge = document.getElementById('alertBadge');
            if (activeAlerts > 0) {
                badge.textContent = activeAlerts;
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
            }
        }
        
        function saveAlerts() {
            const alertsToSave = priceAlerts.map(a => ({
                ...a,
                priceLine: undefined // Don't serialize priceLine object
            }));
            localStorage.setItem('chart_alerts', JSON.stringify(alertsToSave));
        }
        
        function loadAlerts() {
            try {
                const saved = localStorage.getItem('chart_alerts');
                if (saved) {
                    priceAlerts = JSON.parse(saved);
                    alertIdCounter = Math.max(0, ...priceAlerts.map(a => a.id));
                    updateAlertBadge();
                    // Recreate price lines
                    priceAlerts.forEach(alert => {
                        if (!alert.triggered) {
                            addAlertPriceLine(alert);
                        }
                    });
                }
            } catch (e) {
                // console.log('No saved alerts');
            }
        }

        // =====================================================
        // KEYBOARD SHORTCUTS
        // =====================================================
        
        function openShortcutsModal() {
            document.getElementById('shortcutsModal').classList.remove('hidden');
        }
        
        function closeShortcutsModal() {
            document.getElementById('shortcutsModal').classList.add('hidden');
        }
        
        document.addEventListener('keydown', (e) => {
            // Ignore if typing in input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                return;
            }
            
            const key = e.key.toLowerCase();
            
            switch (key) {
                case 'i':
                    e.preventDefault();
                    openIndicatorsModal();
                    break;
                case 's':
                    e.preventDefault();
                    openSymbolSearch(false);
                    break;
                case 'a':
                    e.preventDefault();
                    openAlertsModal();
                    break;
                case 'f':
                    e.preventDefault();
                    toggleFullscreen();
                    break;
                case 'c':
                    e.preventDefault();
                    toggleCompareMode();
                    break;
                case 'e':
                    e.preventDefault();
                    exportChart();
                    break;
                case 'r':
                    e.preventDefault();
                    chart.timeScale().resetTimeScale();
                    break;
                case '+':
                case '=':
                    e.preventDefault();
                    chart.timeScale().scrollToPosition(-10, true);
                    break;
                case '-':
                    e.preventDefault();
                    chart.timeScale().scrollToPosition(10, true);
                    break;
                case '?':
                    e.preventDefault();
                    openShortcutsModal();
                    break;
                case ',':
                    e.preventDefault();
                    openSettingsModal();
                    break;
                case 'escape':
                    closeIndicatorsModal();
                    closeAlertsModal();
                    closeShortcutsModal();
                    closeSymbolSearch();
                    closeSettingsModal();
                    break;
                case '1':
                    selectTimeframe('1');
                    break;
                case '2':
                    selectTimeframe('5');
                    break;
                case '3':
                    selectTimeframe('15');
                    break;
                case '4':
                    selectTimeframe('60');
                    break;
                case '5':
                    selectTimeframe('240');
                    break;
                case '6':
                    selectTimeframe('D');
                    break;
                case '7':
                    selectTimeframe('W');
                    break;
            }
        });
        
        function selectTimeframe(tf) {
            document.querySelectorAll('.tf-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tf === tf);
            });
            currentTimeframe = tf;
            noMoreHistory = false;  // Reset history scroll flag
            loadCandleData();
        }

        // =====================================================
        // ADDITIONAL INDICATOR CALCULATIONS
        // =====================================================
        
        function calculateStochastic(data, kPeriod = 14, dPeriod = 3, smooth = 3) {
            const result = { k: [], d: [] };
            const kValues = [];
            
            for (let i = kPeriod - 1; i < data.length; i++) {
                let highestHigh = -Infinity;
                let lowestLow = Infinity;
                
                for (let j = 0; j < kPeriod; j++) {
                    highestHigh = Math.max(highestHigh, data[i - j].high);
                    lowestLow = Math.min(lowestLow, data[i - j].low);
                }
                
                const k = ((data[i].close - lowestLow) / (highestHigh - lowestLow)) * 100;
                kValues.push({ time: data[i].time, value: k });
            }
            
            // Smooth K values
            for (let i = smooth - 1; i < kValues.length; i++) {
                let sum = 0;
                for (let j = 0; j < smooth; j++) {
                    sum += kValues[i - j].value;
                }
                result.k.push({ time: kValues[i].time, value: sum / smooth });
            }
            
            // Calculate D (SMA of K)
            for (let i = dPeriod - 1; i < result.k.length; i++) {
                let sum = 0;
                for (let j = 0; j < dPeriod; j++) {
                    sum += result.k[i - j].value;
                }
                result.d.push({ time: result.k[i].time, value: sum / dPeriod });
            }
            
            return result;
        }
        
        function calculateATR(data, period = 14) {
            const result = [];
            const trueRanges = [];
            
            for (let i = 1; i < data.length; i++) {
                const high = data[i].high;
                const low = data[i].low;
                const prevClose = data[i - 1].close;
                
                const tr = Math.max(
                    high - low,
                    Math.abs(high - prevClose),
                    Math.abs(low - prevClose)
                );
                trueRanges.push({ time: data[i].time, value: tr });
            }
            
            // EMA of TR
            if (trueRanges.length >= period) {
                let atr = trueRanges.slice(0, period).reduce((sum, tr) => sum + tr.value, 0) / period;
                result.push({ time: trueRanges[period - 1].time, value: atr });
                
                for (let i = period; i < trueRanges.length; i++) {
                    atr = ((atr * (period - 1)) + trueRanges[i].value) / period;
                    result.push({ time: trueRanges[i].time, value: atr });
                }
            }
            
            return result;
        }
        
        function calculateRSI(data, period = 14) {
            const result = [];
            let gains = 0;
            let losses = 0;
            
            // First RSI calculation
            for (let i = 1; i <= period && i < data.length; i++) {
                const change = data[i].close - data[i - 1].close;
                if (change > 0) gains += change;
                else losses -= change;
            }
            
            let avgGain = gains / period;
            let avgLoss = losses / period;
            
            if (data.length > period) {
                const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                const rsi = 100 - (100 / (1 + rs));
                result.push({ time: data[period].time, value: rsi });
                
                for (let i = period + 1; i < data.length; i++) {
                    const change = data[i].close - data[i - 1].close;
                    const gain = change > 0 ? change : 0;
                    const loss = change < 0 ? -change : 0;
                    
                    avgGain = ((avgGain * (period - 1)) + gain) / period;
                    avgLoss = ((avgLoss * (period - 1)) + loss) / period;
                    
                    const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                    const rsi = 100 - (100 / (1 + rs));
                    result.push({ time: data[i].time, value: rsi });
                }
            }
            
            return result;
        }
        
        function calculateMACD(data, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
            const fastEMA = calculateEMA(data, fastPeriod);
            const slowEMA = calculateEMA(data, slowPeriod);
            
            const macdLine = [];
            const offset = slowPeriod - fastPeriod;
            
            for (let i = 0; i < slowEMA.length; i++) {
                const fastValue = fastEMA[i + offset]?.value;
                const slowValue = slowEMA[i]?.value;
                
                if (fastValue !== undefined && slowValue !== undefined) {
                    macdLine.push({
                        time: slowEMA[i].time,
                        value: fastValue - slowValue
                    });
                }
            }
            
            // Signal line (EMA of MACD)
            const signalLine = [];
            if (macdLine.length >= signalPeriod) {
                const multiplier = 2 / (signalPeriod + 1);
                let ema = macdLine.slice(0, signalPeriod).reduce((sum, d) => sum + d.value, 0) / signalPeriod;
                signalLine.push({ time: macdLine[signalPeriod - 1].time, value: ema });
                
                for (let i = signalPeriod; i < macdLine.length; i++) {
                    ema = (macdLine[i].value - ema) * multiplier + ema;
                    signalLine.push({ time: macdLine[i].time, value: ema });
                }
            }
            
            // Histogram
            const histogram = [];
            const signalOffset = macdLine.length - signalLine.length;
            for (let i = 0; i < signalLine.length; i++) {
                histogram.push({
                    time: signalLine[i].time,
                    value: macdLine[i + signalOffset].value - signalLine[i].value,
                    color: macdLine[i + signalOffset].value - signalLine[i].value >= 0 ? '#3fb950' : '#f85149'
                });
            }
            
            return { macd: macdLine, signal: signalLine, histogram };
        }

        // VWAP Indicator calculation - resets at start of each trading day
        function calculateVWAPIndicator(data) {
            const result = [];
            let cumulativeTPV = 0;
            let cumulativeVolume = 0;
            let lastDate = null;
            
            for (let i = 0; i < data.length; i++) {
                const candle = data[i];
                
                // Get date from timestamp (reset VWAP daily)
                const candleDate = new Date(candle.time * 1000).toDateString();
                if (lastDate !== candleDate) {
                    // New day - reset VWAP
                    cumulativeTPV = 0;
                    cumulativeVolume = 0;
                    lastDate = candleDate;
                }
                
                // Use actual volume if available, otherwise estimate
                const volume = candle.volume || (Math.abs(candle.high - candle.low) * 1000000);
                const typicalPrice = (candle.high + candle.low + candle.close) / 3;
                
                cumulativeTPV += typicalPrice * volume;
                cumulativeVolume += volume;
                
                if (cumulativeVolume > 0) {
                    result.push({
                        time: candle.time,
                        value: cumulativeTPV / cumulativeVolume
                    });
                }
            }
            return result;
        }

        // Backward-compatible wrapper used by some UI update paths.
        // The main VWAP implementation in this file is calculateVWAPIndicator(data).
        // Some code paths call calculateVWAP(candles, volumes); keep that working by
        // computing proper VWAP using the provided volumes array.
        function calculateVWAP(candles, volumes) {
            if (!Array.isArray(candles) || candles.length === 0) return [];

            // Build a time->volume map (current volumes are {time,value}), and fall back to
            // any candle.volume if present.
            const volByTime = new Map();
            if (Array.isArray(volumes)) {
                for (const v of volumes) {
                    if (!v) continue;
                    const t = v.time;
                    const val = v.value;
                    if (t == null || val == null) continue;
                    const num = typeof val === 'number' ? val : parseFloat(val);
                    if (!Number.isFinite(num) || num <= 0) continue;
                    volByTime.set(t, num);
                }
            }

            const result = [];
            let cumulativeTPV = 0;
            let cumulativeVolume = 0;
            let lastDate = null;

            for (const candle of candles) {
                if (!candle || candle.time == null) continue;

                const o = typeof candle.open === 'number' ? candle.open : parseFloat(candle.open);
                const h = typeof candle.high === 'number' ? candle.high : parseFloat(candle.high);
                const l = typeof candle.low === 'number' ? candle.low : parseFloat(candle.low);
                const c = typeof candle.close === 'number' ? candle.close : parseFloat(candle.close);
                if (![o, h, l, c].every(Number.isFinite)) continue;

                const candleDate = new Date(candle.time * 1000).toDateString();
                if (lastDate !== candleDate) {
                    cumulativeTPV = 0;
                    cumulativeVolume = 0;
                    lastDate = candleDate;
                }

                // Prefer explicit volume series data; otherwise attempt candle.volume.
                let vol = volByTime.get(candle.time);
                if (vol == null && candle.volume != null) {
                    const cv = typeof candle.volume === 'number' ? candle.volume : parseFloat(candle.volume);
                    if (Number.isFinite(cv) && cv > 0) vol = cv;
                }
                if (vol == null || !Number.isFinite(vol) || vol <= 0) continue;

                const typicalPrice = (h + l + c) / 3;
                const tpv = typicalPrice * vol;
                if (!Number.isFinite(tpv)) continue;

                cumulativeTPV += tpv;
                cumulativeVolume += vol;

                const vwap = cumulativeTPV / cumulativeVolume;
                if (!Number.isFinite(vwap)) continue;
                result.push({ time: candle.time, value: vwap });
            }

            return result;
        }

        // Ichimoku Cloud calculation - Standard Parameters (9, 26, 52)
        function calculateIchimoku(data) {
            const tenkanPeriod = 9;   // Conversion Line
            const kijunPeriod = 26;   // Base Line
            const senkouBPeriod = 52; // Leading Span B
            const displacement = 26;  // Cloud displacement
            
            const tenkan = [];
            const kijun = [];
            const senkouA = [];
            const senkouB = [];
            const chikou = [];
            
            function getHighLow(endIdx, period) {
                let high = -Infinity, low = Infinity;
                const startIdx = Math.max(0, endIdx - period + 1);
                for (let i = startIdx; i <= endIdx; i++) {
                    high = Math.max(high, data[i].high);
                    low = Math.min(low, data[i].low);
                }
                return { high, low };
            }
            
            for (let i = 0; i < data.length; i++) {
                // Tenkan-sen (Conversion Line) - (9-period high + 9-period low) / 2
                if (i >= tenkanPeriod - 1) {
                    const hl = getHighLow(i, tenkanPeriod);
                    tenkan.push({ time: data[i].time, value: (hl.high + hl.low) / 2 });
                }
                
                // Kijun-sen (Base Line) - (26-period high + 26-period low) / 2
                if (i >= kijunPeriod - 1) {
                    const hl = getHighLow(i, kijunPeriod);
                    kijun.push({ time: data[i].time, value: (hl.high + hl.low) / 2 });
                }
                
                // Chikou Span (Lagging Span) - close plotted 26 periods back
                if (i >= displacement) {
                    chikou.push({ time: data[i - displacement].time, value: data[i].close });
                }
            }
            
            // Senkou Span A - (Tenkan + Kijun) / 2, plotted 26 periods ahead
            for (let i = 0; i < Math.min(tenkan.length, kijun.length); i++) {
                const dataIdx = i + Math.max(tenkanPeriod, kijunPeriod) - 1;
                if (dataIdx + displacement < data.length) {
                    senkouA.push({
                        time: data[dataIdx + displacement].time,
                        value: (tenkan[i].value + kijun[i].value) / 2
                    });
                }
            }
            
            // Senkou Span B - (52-period high + 52-period low) / 2, plotted 26 periods ahead
            for (let i = senkouBPeriod - 1; i < data.length; i++) {
                const hl = getHighLow(i, senkouBPeriod);
                if (i + displacement < data.length) {
                    senkouB.push({
                        time: data[i + displacement].time,
                        value: (hl.high + hl.low) / 2
                    });
                }
            }
            
            return { tenkan, kijun, senkouA, senkouB, chikou };
        }

        // Pivot Points calculation - Classic Floor Trader Pivots
        function calculatePivotPoints(data) {
            if (data.length < 50) return null;
            
            // Find previous day's high, low, close by looking at daily aggregation
            // For intraday data, aggregate to find daily H/L/C
            let prevDayHigh = -Infinity;
            let prevDayLow = Infinity;
            let prevDayClose = 0;
            let currentDayStart = null;
            
            // Get the last complete trading period for pivot calculation
            // Use last 24 candles as "previous day" for simplicity
            const lookback = Math.min(96, Math.floor(data.length / 2)); // ~24 hours of 15min candles
            const startIdx = data.length - lookback - 1;
            const endIdx = data.length - 1;
            
            for (let i = startIdx; i < endIdx; i++) {
                prevDayHigh = Math.max(prevDayHigh, data[i].high);
                prevDayLow = Math.min(prevDayLow, data[i].low);
            }
            prevDayClose = data[endIdx - 1].close;
            
            // Classic Pivot Point formula
            const pivot = (prevDayHigh + prevDayLow + prevDayClose) / 3;
            
            // Resistance levels
            const r1 = (2 * pivot) - prevDayLow;
            const r2 = pivot + (prevDayHigh - prevDayLow);
            const r3 = r1 + (prevDayHigh - prevDayLow);
            
            // Support levels
            const s1 = (2 * pivot) - prevDayHigh;
            const s2 = pivot - (prevDayHigh - prevDayLow);
            const s3 = s1 - (prevDayHigh - prevDayLow);
            
            // Create horizontal lines across current data range
            const result = {
                pivot: [],
                r1: [], r2: [], r3: [],
                s1: [], s2: [], s3: []
            };
            
            // Only show pivots for recent data
            const showFrom = Math.max(0, data.length - 100);
            for (let i = showFrom; i < data.length; i++) {
                const time = data[i].time;
                result.pivot.push({ time, value: pivot });
                result.r1.push({ time, value: r1 });
                result.r2.push({ time, value: r2 });
                result.r3.push({ time, value: r3 });
                result.s1.push({ time, value: s1 });
                result.s2.push({ time, value: s2 });
                result.s3.push({ time, value: s3 });
            }
            
            return result;
        }

        // SuperTrend calculation - Standard (10, 3)
        function calculateSuperTrend(data, period = 10, multiplier = 3) {
            const result = [];
            if (data.length < period) return result;
            
            // Calculate ATR
            const trueRanges = [];
            for (let i = 0; i < data.length; i++) {
                if (i === 0) {
                    trueRanges.push(data[i].high - data[i].low);
                } else {
                    const tr = Math.max(
                        data[i].high - data[i].low,
                        Math.abs(data[i].high - data[i - 1].close),
                        Math.abs(data[i].low - data[i - 1].close)
                    );
                    trueRanges.push(tr);
                }
            }
            
            // Calculate ATR using RMA (Wilder's smoothing)
            const atr = [];
            let atrSum = 0;
            for (let i = 0; i < data.length; i++) {
                if (i < period) {
                    atrSum += trueRanges[i];
                    if (i === period - 1) {
                        atr.push(atrSum / period);
                    } else {
                        atr.push(null);
                    }
                } else {
                    const newAtr = (atr[i - 1] * (period - 1) + trueRanges[i]) / period;
                    atr.push(newAtr);
                }
            }
            
            // Calculate SuperTrend
            let trend = 1; // 1 = bullish, -1 = bearish
            let upperBand = 0, lowerBand = 0;
            let prevUpperBand = 0, prevLowerBand = 0;
            let prevClose = 0;
            let prevSuperTrend = 0;
            
            for (let i = period - 1; i < data.length; i++) {
                if (atr[i] === null) continue;
                
                const hl2 = (data[i].high + data[i].low) / 2;
                const basicUpperBand = hl2 + multiplier * atr[i];
                const basicLowerBand = hl2 - multiplier * atr[i];
                
                // Final Upper Band
                if (i === period - 1) {
                    upperBand = basicUpperBand;
                    lowerBand = basicLowerBand;
                } else {
                    upperBand = (basicUpperBand < prevUpperBand || prevClose > prevUpperBand) 
                        ? basicUpperBand : prevUpperBand;
                    lowerBand = (basicLowerBand > prevLowerBand || prevClose < prevLowerBand) 
                        ? basicLowerBand : prevLowerBand;
                }
                
                // Determine trend direction
                let superTrend;
                if (i === period - 1) {
                    trend = data[i].close > upperBand ? 1 : -1;
                    superTrend = trend === 1 ? lowerBand : upperBand;
                } else {
                    if (prevSuperTrend === prevUpperBand) {
                        trend = data[i].close > upperBand ? 1 : -1;
                    } else {
                        trend = data[i].close < lowerBand ? -1 : 1;
                    }
                    superTrend = trend === 1 ? lowerBand : upperBand;
                }
                
                result.push({
                    time: data[i].time,
                    value: superTrend,
                    trend: trend
                });
                
                prevUpperBand = upperBand;
                prevLowerBand = lowerBand;
                prevClose = data[i].close;
                prevSuperTrend = superTrend;
            }
            
            return result;
        }

        // NOTE: loadAlerts() is called from consolidated DOMContentLoaded handler above

        // =====================================================
        // =====================================================
        // INITIALIZATION & UI HANDLERS (Restored & consolidated)
        // =====================================================
        
        function setupEventListeners() {
            // console.log('[Init] Setting up event listeners...');
            
            // Settings Button
            const settingsBtn = document.getElementById('settingsBtn');
            if (settingsBtn) {
                settingsBtn.addEventListener('click', () => {
                    // console.log('[UI] Settings button clicked');
                    openSettingsModal();
                });
            } else {
                console.warn('[UI] Settings button not found!');
            }
            
            // Alerts Button
            const alertsBtn = document.getElementById('alertsBtn');
            if (alertsBtn) {
                alertsBtn.addEventListener('click', () => {
                    // console.log('[UI] Alerts button clicked');
                    openAlertsModal();
                });
            }
            
            // Shortcuts Button (Keyboard icon)
            const shortcutsBtn = document.querySelector('button[title*="Shortcuts"]') || document.getElementById('shortcutsBtn');
            if (shortcutsBtn) {
                shortcutsBtn.addEventListener('click', () => {
                    openShortcutsModal();
                });
            }

            // Export Button
            const exportBtn = document.getElementById('exportBtn');
            if (exportBtn) {
                exportBtn.addEventListener('click', () => {
                    exportChart();
                });
            }
            
            // Fullscreen Button
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', () => {
                    toggleFullscreen();
                });
            }
            
            // Timeframe Buttons
            document.querySelectorAll('.tf-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const tf = e.target.dataset.tf;
                    if (tf) selectTimeframe(tf); // Use selectTimeframe which is defined at line 7344
                });
            });

            // console.log('[Init] Event listeners attached');
        }

        function initSymbolSearch() {
            // Basic symbol search initialization
            const searchInput = document.getElementById('symbolSearchInput');
            if (searchInput) {
                searchInput.addEventListener('input', (e) => {
                    const term = e.target.value.toUpperCase();
                    // Filter logic would go here
                    // For now, just logging
                    // console.log('Search:', term);
                });
            }
        }

        // NOTE: loadVolumeSettings, saveVolumeSettings, updateVolumeSetting, updateVolumeIndicators
        // are defined earlier in the file (around line 5771-5850)
        // Removed duplicate definitions that were overriding the proper ones

        function openSettingsModal() {
            const modal = document.getElementById('settingsModal');
            if (modal) {
                modal.classList.remove('hidden');
                loadSettings(); 
            }
        }

        function closeSettingsModal() {
            const modal = document.getElementById('settingsModal');
            if (modal) modal.classList.add('hidden');
        }

        function switchSettingsTab(tabName) {
            document.querySelectorAll('.settings-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });
            document.querySelectorAll('.settings-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            const target = document.getElementById(`settings-${tabName}`);
            if (target) target.classList.add('active');
        }
        
        function updateSetting(key, value) {
            if (value === 'true') value = true;
            if (value === 'false') value = false;
            chartSettings[key] = value;
            saveSettings();
            applySettingChange(key, value);
        }

        function openAlertsModal() {
            const modal = document.getElementById('alertsModal');
            if(modal) modal.classList.remove('hidden');
        }
        
        function closeAlertsModal() {
            const modal = document.getElementById('alertsModal');
            if(modal) modal.classList.add('hidden');
        }
        
        function openShortcutsModal() {
            const modal = document.getElementById('shortcutsModal');
            if(modal) modal.classList.remove('hidden');
        }
        
        function closeShortcutsModal() {
            const modal = document.getElementById('shortcutsModal');
            if(modal) modal.classList.add('hidden');
        }
        
        function openSymbolSearch() {
            const modal = document.getElementById('searchModal');
            if (modal) {
                 modal.classList.remove('hidden');
                 document.getElementById('symbolSearchInput')?.focus();
            }
        }
        
        function closeSearchModal() {
             const modal = document.getElementById('searchModal');
             if (modal) modal.classList.add('hidden');
        }
        
            
            // console.log('[Script] UI Handlers loaded successfully');

    </script>
    <!-- Bootstrap JS (local) -->
    <script src="libs/bootstrap.bundle.min.js"></script>
    <script type="module" src="/frontend/js/pages/market_chart.js"></script>
</body>
</html>
