<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Security Headers -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://cdn.jsdelivr.net https://unpkg.com; style-src 'self' https://cdn.jsdelivr.net https://fonts.googleapis.com 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' https://cdn.jsdelivr.net https://fonts.gstatic.com; connect-src 'self' https://api.bybit.com wss://stream.bybit.com ws://localhost:* http://localhost:*; frame-src 'none'; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta name="referrer" content="strict-origin-when-cross-origin">

    <title>Dashboard - Bybit Strategy Tester v2</title>
    <link rel="icon" href="/frontend/favicon.ico" type="image/x-icon">
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"
        integrity="sha384-9nhczxUqK87bcKHh20fSQcTGD4qq5GhayNYSYWqwBkINBhOfQLg/P5HG5lF1urn4"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"
        integrity="sha384-cVMg8E3QFwTvGCDuK+ET4PD341jF3W8nO1auiXfuZNQkzbUUiBGLsIQUE+b1mxws"
        crossorigin="anonymous"></script>
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css"
      integrity="sha384-4LISF5TTJX/fLmGSxO53rV4miRxdg84mZsxmO8Rx5jGtp/LbrixFETvWa5a6sESd"
      crossorigin="anonymous">
    <!-- External CSS (Phase 1) -->
    <link rel="stylesheet" href="/frontend/css/variables.css">
    <link rel="stylesheet" href="/frontend/css/components.css">
    <link rel="stylesheet" href="/frontend/css/common.css">
    <link rel="stylesheet" href="/frontend/css/dashboard.css">

    </head>
<body>
    <!-- Keyboard Shortcuts Modal -->
    <div class="shortcuts-modal" id="shortcutsModal">
        <div class="shortcuts-content">
            <h3><i class="bi bi-keyboard"></i> Keyboard Shortcuts</h3>
            <div class="shortcut-group">
                <h4>Navigation</h4>
                <div class="shortcut-item">
                    <span>Go to Dashboard</span>
                    <span class="shortcut-key">D</span>
                </div>
                <div class="shortcut-item">
                    <span>Go to Strategies</span>
                    <span class="shortcut-key">S</span>
                </div>
                <div class="shortcut-item">
                    <span>Go to Trading</span>
                    <span class="shortcut-key">T</span>
                </div>
                <div class="shortcut-item">
                    <span>Go to Charts</span>
                    <span class="shortcut-key">C</span>
                </div>
                <div class="shortcut-item">
                    <span>Go to Analytics</span>
                    <span class="shortcut-key">A</span>
                </div>
            </div>
            <div class="shortcut-group">
                <h4>Actions</h4>
                <div class="shortcut-item">
                    <span>Refresh Dashboard</span>
                    <span class="shortcut-key">R</span>
                </div>
                <div class="shortcut-item">
                    <span>New Strategy</span>
                    <span class="shortcut-key">N</span>
                </div>
                <div class="shortcut-item">
                    <span>Toggle Theme</span>
                    <span class="shortcut-key">L</span>
                </div>
                <div class="shortcut-item">
                    <span>Show Notifications</span>
                    <span class="shortcut-key">I</span>
                </div>
                <div class="shortcut-item">
                    <span>Open Settings</span>
                    <span class="shortcut-key">O</span>
                </div>
            </div>
            <div class="shortcut-group">
                <h4>General</h4>
                <div class="shortcut-item">
                    <span>Show Shortcuts</span>
                    <span class="shortcut-key">?</span>
                </div>
                <div class="shortcut-item">
                    <span>Close Modal</span>
                    <span class="shortcut-key">Esc</span>
                </div>
            </div>
            <button onclick="hideShortcuts()" class="close-modal-btn">Close</button>
        </div>
    </div>

    <!-- Live Price Ticker -->
    <div class="live-ticker" id="liveTicker">
        <div class="ticker-track" id="tickerTrack">
            <!-- Filled by JavaScript -->
        </div>
    </div>

    <div class="container">
        <!-- Header -->
        <header>
            <h1>
                <span class="logo">üìä</span>
                Bybit Strategy Tester
            </h1>
            <nav class="nav-links">
                <a href="dashboard.html" class="active">Dashboard</a>
                
                <div class="nav-dropdown">
                    <button class="nav-dropdown-btn">Trading <i class="bi bi-chevron-down"></i></button>
                    <div class="nav-dropdown-menu">
                        <a href="trading.html"><i class="bi bi-graph-up-arrow"></i> Live Trading</a>
                        <a href="market-chart.html"><i class="bi bi-bar-chart"></i> Charts</a>
                        <a href="tick-chart.html"><i class="bi bi-activity"></i> Tick Chart</a>
                        <a href="portfolio.html"><i class="bi bi-wallet2"></i> Portfolio</a>
                    </div>
                </div>
                
                <div class="nav-dropdown">
                    <button class="nav-dropdown-btn">Strategies <i class="bi bi-chevron-down"></i></button>
                    <div class="nav-dropdown-menu">
                        <a href="strategies.html"><i class="bi bi-list"></i> My Strategies</a>
                        <a href="strategy-builder.html"><i class="bi bi-puzzle"></i> Strategy Builder</a>
                        <a href="backtests.html"><i class="bi bi-clock-history"></i> Backtests</a>
                        <a href="optimizations.html"><i class="bi bi-sliders"></i> Optimizations</a>
                    </div>
                </div>
                
                <div class="nav-dropdown">
                    <button class="nav-dropdown-btn">Analytics <i class="bi bi-chevron-down"></i></button>
                    <div class="nav-dropdown-menu">
                        <a href="analytics.html"><i class="bi bi-pie-chart"></i> Analytics</a>
                        <a href="ml-models.html"><i class="bi bi-robot"></i> ML Models</a>
                        <a href="risk-management.html"><i class="bi bi-shield-check"></i> Risk Management</a>
                    </div>
                </div>
                
                <a href="notifications.html" title="Notifications"><i class="bi bi-bell"></i></a>
                <a href="settings.html" title="Settings"><i class="bi bi-gear"></i></a>
                
                <div class="theme-toggle" onclick="toggleTheme()" title="Toggle Theme (L)">
                    <span class="toggle-icon active" id="darkModeIcon"><i class="bi bi-moon-fill"></i></span>
                    <span class="toggle-icon" id="lightModeIcon"><i class="bi bi-sun-fill"></i></span>
                </div>
            </nav>
        </header>

        <!-- Market Overview -->
        <div class="market-overview" id="marketOverview">
            <!-- Filled by JavaScript -->
        </div>

        <!-- Period Selector & Refresh -->
        <div class="dashboard-toolbar">
            <div class="toolbar-left">
                <div class="period-selector">
                    <button class="period-btn" data-period="1h">1H</button>
                    <button class="period-btn active" data-period="24h">24H</button>
                    <button class="period-btn" data-period="7d">7D</button>
                    <button class="period-btn" data-period="30d">30D</button>
                    <button class="period-btn" data-period="all">All</button>
                </div>
                
                <!-- Custom Date Range -->
                <div class="date-range-picker" id="customDateRange">
                    <span class="date-icon">üìÖ</span>
                    <input type="date" id="dateFrom" title="Start date">
                    <span class="date-separator">‚Üí</span>
                    <input type="date" id="dateTo" title="End date">
                    <button class="apply-btn" onclick="applyCustomDateRange()">Apply</button>
                </div>
            </div>
            
            <div class="toolbar-left">
                <!-- WebSocket Status -->
                <div class="ws-status" id="wsStatus">
                    <div class="dot"></div>
                    <span>Connecting...</span>
                </div>
                
                <div class="refresh-indicator" id="refreshIndicator">
                    <div class="spinner"></div>
                    <span id="lastUpdate">Last updated: --</span>
                    <button class="refresh-btn" onclick="refreshDashboard()" title="Refresh">üîÑ</button>
                </div>
            </div>
        </div>

        <!-- Stats Cards -->
        <div class="stats-grid" id="statsGrid">
            <div class="stat-card blue">
                <div class="icon">üìà</div>
                <div class="title">Total Backtests</div>
                <div class="value" id="totalBacktests">--</div>
                <div class="subtext">
                    <span id="runningBacktests">0</span> running ‚Ä¢ <span id="completedBacktests">0</span> completed
                </div>
            </div>

            <div class="stat-card green">
                <div class="icon">üéØ</div>
                <div class="title">Success Rate</div>
                <div class="value" id="successRate">--%</div>
                <div class="subtext" id="failedBacktests">0 failed</div>
            </div>

            <div class="stat-card purple">
                <div class="icon">üìã</div>
                <div class="title">Active Strategies</div>
                <div class="value" id="activeStrategies">--</div>
                <div class="subtext"><span id="totalStrategies">0</span> total strategies</div>
            </div>

            <div class="stat-card yellow">
                <div class="icon">‚öôÔ∏è</div>
                <div class="title">Optimizations</div>
                <div class="value" id="totalOptimizations">--</div>
                <div class="subtext"><span id="runningOptimizations">0</span> running</div>
            </div>

            <div class="stat-card green">
                <div class="icon">üíπ</div>
                <div class="title">Trades Analyzed</div>
                <div class="value" id="totalTrades">--</div>
                <div class="subtext">In selected period</div>
            </div>

            <div class="stat-card blue">
                <div class="icon">‚è±Ô∏è</div>
                <div class="title">Avg Backtest Time</div>
                <div class="value" id="avgDuration">--s</div>
                <div class="subtext">Per completed backtest</div>
            </div>
        </div>

        <!-- Charts Section -->
        <div class="charts-grid">
            <!-- Performance Over Time -->
            <div class="panel">
                <div class="panel-header">
                    <h3>üìà Performance Over Time</h3>
                    <label for="chartMetricSelect" class="visually-hidden">Select chart metric</label>
                    <select id="chartMetricSelect" title="Select chart metric" class="metric-select">
                        <option value="returns">Returns</option>
                        <option value="sharpe">Sharpe Ratio</option>
                        <option value="trades">Trade Count</option>
                    </select>
                </div>
                <div class="panel-body">
                    <div class="chart-container">
                        <canvas id="performanceChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Returns Distribution -->
            <div class="panel">
                <div class="panel-header">
                    <h3>üìä Returns Distribution</h3>
                </div>
                <div class="panel-body">
                    <div class="chart-container">
                        <canvas id="distributionChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Win Rate by Strategy Type -->
            <div class="panel">
                <div class="panel-header">
                    <h3>üéØ Win Rate by Strategy</h3>
                </div>
                <div class="panel-body">
                    <div class="chart-container">
                        <canvas id="winRateChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Backtests Timeline -->
            <div class="panel">
                <div class="panel-header">
                    <h3>‚è≥ Backtests Activity</h3>
                </div>
                <div class="panel-body">
                    <div class="chart-container">
                        <canvas id="activityChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Dashboard Grid -->
        <div class="dashboard-grid">
            <!-- Left Column: Top Performers -->
            <div class="panel">
                <div class="panel-header">
                    <h3>üèÜ Top Performers</h3>
                    <label for="performerMetric" class="visually-hidden">Sort by metric</label>
                    <select id="performerMetric" title="Sort performers by metric" class="metric-select">
                        <option value="sharpe_ratio">Sharpe Ratio</option>
                        <option value="total_return">Total Return</option>
                        <option value="win_rate">Win Rate</option>
                    </select>
                </div>
                <div class="panel-body">
                    <table class="performers-table">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Strategy</th>
                                <th>Symbol</th>
                                <th>Sharpe</th>
                                <th>Return</th>
                                <th>Win Rate</th>
                            </tr>
                        </thead>
                        <tbody id="performersBody">
                            <tr>
                                <td colspan="6" class="table-loading">Loading...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Right Column: System Health & Quick Actions -->
            <div class="charts-column">
                <!-- System Health -->
                <div class="panel">
                    <div class="panel-header">
                        <h3>üè• System Health</h3>
                        <span class="badge" id="systemStatus">--</span>
                    </div>
                    <div class="panel-body">
                        <div class="health-grid" id="healthGrid">
                            <div class="health-item">
                                <div class="label">
                                    <span>üóÑÔ∏è</span>
                                    <span>Database</span>
                                </div>
                                <div class="status">
                                    <span id="dbResponseTime">--ms</span>
                                    <div class="status-dot" id="dbStatus"></div>
                                </div>
                            </div>
                            <div class="health-item">
                                <div class="label">
                                    <span>üì¶</span>
                                    <span>Task Queue</span>
                                </div>
                                <div class="status">
                                    <span id="pendingTasks">--</span>
                                    <div class="status-dot" id="queueStatus"></div>
                                </div>
                            </div>
                            <div class="health-item">
                                <div class="label">
                                    <span>üíæ</span>
                                    <span>Database Size</span>
                                </div>
                                <div class="status">
                                    <span id="dbSize">--</span>
                                </div>
                            </div>
                            <div class="health-item">
                                <div class="label">
                                    <span>ü§ñ</span>
                                    <span>AI Agents</span>
                                </div>
                                <div class="status">
                                    <span id="agentsStatus">--</span>
                                    <div class="status-dot" id="agentsDot"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Quick Actions -->
                <div class="panel">
                    <div class="panel-header">
                        <h3>‚ö° Quick Actions</h3>
                    </div>
                    <div class="panel-body">
                        <div class="quick-actions">
                            <a href="strategies.html?action=new" class="action-btn">
                                <span class="icon">‚ûï</span>
                                New Strategy
                            </a>
                            <a href="backtests.html?action=run" class="action-btn">
                                <span class="icon">‚ñ∂Ô∏è</span>
                                Run Backtest
                            </a>
                            <a href="optimizations.html?action=new" class="action-btn">
                                <span class="icon">üîß</span>
                                Optimization
                            </a>
                            <a href="trading.html" class="action-btn">
                                <span class="icon">üíπ</span>
                                Trading
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Watchlist Widget -->
                <div class="panel">
                    <div class="panel-header">
                        <h3>‚≠ê Watchlist</h3>
                        <button class="refresh-btn" onclick="addToWatchlist()" title="Add Symbol">‚ûï</button>
                    </div>
                    <div class="panel-body">
                        <div class="watchlist-widget" id="watchlistWidget">
                            <div class="watchlist-item">
                                <div class="watchlist-left">
                                    <span class="watchlist-star">‚òÖ</span>
                                    <div>
                                        <div class="market-symbol">BTC/USDT</div>
                                        <div class="market-name">Bitcoin</div>
                                    </div>
                                </div>
                                <div class="watchlist-right">
                                    <div class="market-price">$67,250.50</div>
                                    <div class="market-change up">+2.35%</div>
                                </div>
                            </div>
                            <div class="watchlist-item">
                                <div class="watchlist-left">
                                    <span class="watchlist-star">‚òÖ</span>
                                    <div>
                                        <div class="market-symbol">ETH/USDT</div>
                                        <div class="market-name">Ethereum</div>
                                    </div>
                                </div>
                                <div class="watchlist-right">
                                    <div class="market-price">$3,520.80</div>
                                    <div class="market-change up">+1.82%</div>
                                </div>
                            </div>
                            <div class="watchlist-item">
                                <div class="watchlist-left">
                                    <span class="watchlist-star">‚òÖ</span>
                                    <div>
                                        <div class="market-symbol">SOL/USDT</div>
                                        <div class="market-name">Solana</div>
                                    </div>
                                </div>
                                <div class="watchlist-right">
                                    <div class="market-price">$142.35</div>
                                    <div class="market-change down">-0.95%</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- NEW: Watchlist & Risk Heatmap Row -->
        <div class="dashboard-grid spaced">
            <!-- Risk Heatmap -->
            <div class="panel">
                <div class="panel-header">
                    <h3>üî• Risk Heatmap</h3>
                    <span class="badge warning">Portfolio Risk</span>
                </div>
                <div class="panel-body">
                    <div class="risk-heatmap" id="riskHeatmap">
                        <div class="heatmap-cell risk-low">
                            <div class="symbol">BTC</div>
                            <div class="value">Low Risk (15%)</div>
                        </div>
                        <div class="heatmap-cell risk-low">
                            <div class="symbol">ETH</div>
                            <div class="value">Low Risk (22%)</div>
                        </div>
                        <div class="heatmap-cell risk-medium">
                            <div class="symbol">SOL</div>
                            <div class="value">Medium (45%)</div>
                        </div>
                        <div class="heatmap-cell risk-medium">
                            <div class="symbol">BNB</div>
                            <div class="value">Medium (38%)</div>
                        </div>
                        <div class="heatmap-cell risk-high">
                            <div class="symbol">DOGE</div>
                            <div class="value">High Risk (65%)</div>
                        </div>
                        <div class="heatmap-cell risk-extreme">
                            <div class="symbol">SHIB</div>
                            <div class="value">Extreme (85%)</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Mini Calendar -->
            <div class="panel">
                <div class="panel-header">
                    <h3>ÔøΩ Calendar</h3>
                    <div class="calendar-nav">
                        <button onclick="changeMonth(-1)" title="Previous Month">‚óÄ</button>
                        <span id="calendarMonth">January 2025</span>
                        <button onclick="changeMonth(1)" title="Next Month">‚ñ∂</button>
                    </div>
                </div>
                <div class="panel-body">
                    <div class="mini-calendar">
                        <div class="calendar-grid">
                            <div class="calendar-day-header">Su</div>
                            <div class="calendar-day-header">Mo</div>
                            <div class="calendar-day-header">Tu</div>
                            <div class="calendar-day-header">We</div>
                            <div class="calendar-day-header">Th</div>
                            <div class="calendar-day-header">Fr</div>
                            <div class="calendar-day-header">Sa</div>
                            <!-- Days filled by JS -->
                            <div class="calendar-day other-month">29</div>
                            <div class="calendar-day other-month">30</div>
                            <div class="calendar-day other-month">31</div>
                            <div class="calendar-day">1</div>
                            <div class="calendar-day">2</div>
                            <div class="calendar-day">3</div>
                            <div class="calendar-day">4</div>
                            <div class="calendar-day">5</div>
                            <div class="calendar-day">6</div>
                            <div class="calendar-day today">7</div>
                            <div class="calendar-day">8</div>
                            <div class="calendar-day">9</div>
                            <div class="calendar-day has-event">10</div>
                            <div class="calendar-day">11</div>
                            <div class="calendar-day">12</div>
                            <div class="calendar-day">13</div>
                            <div class="calendar-day">14</div>
                            <div class="calendar-day has-event">15</div>
                            <div class="calendar-day">16</div>
                            <div class="calendar-day">17</div>
                            <div class="calendar-day">18</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Second Row: Recent Activity -->
        <div class="panel panel-spaced">
            <div class="panel-header">
                <h3>üìã Recent Activity</h3>
                <span class="badge" id="activityCount">0</span>
            </div>
            <div class="panel-body">
                <ul class="activity-list" id="activityList">
                    <li class="activity-loading">
                        Loading recent activity...
                    </li>
                </ul>
            </div>
        </div>

        <!-- NEW: Portfolio History & AI Recommendations Row -->
        <div class="dashboard-grid spaced">
            <!-- Portfolio History Chart -->
            <div class="panel">
                <div class="panel-header">
                    <h3>üìä Portfolio History</h3>
                    <div class="period-selector" id="portfolioPeriodSelector">
                        <button class="period-btn active" data-days="7">7D</button>
                        <button class="period-btn" data-days="30">30D</button>
                        <button class="period-btn" data-days="90">90D</button>
                    </div>
                </div>
                <div class="panel-body">
                    <div class="chart-container">
                        <canvas id="portfolioHistoryChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- AI Recommendations -->
            <div class="panel">
                <div class="panel-header">
                    <h3>ü§ñ AI Recommendations</h3>
                    <button class="refresh-btn" onclick="loadAIRecommendations()" title="Refresh AI Insights">üîÑ</button>
                </div>
                <div class="panel-body">
                    <div id="aiRecommendations" class="ai-recommendations-container">
                        <div class="ai-loading">
                            <div class="spinner"></div>
                            <span>Analyzing portfolio...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- NEW: Real-time P&L and Strategy Leaderboard Row -->
        <div class="dashboard-grid spaced">
            <!-- Real-time P&L Widget -->
            <div class="panel">
                <div class="panel-header">
                    <h3>üí∞ Real-time P&L</h3>
                    <span class="badge pnl-live" id="pnlLiveStatus">‚óè LIVE</span>
                </div>
                <div class="panel-body">
                    <div class="pnl-display">
                        <div class="pnl-main">
                            <span class="pnl-label">Current P&L</span>
                            <span class="pnl-value" id="currentPnL">$0.00</span>
                        </div>
                        <div class="pnl-stats">
                            <div class="pnl-stat">
                                <span class="label">Today</span>
                                <span class="value" id="pnlToday">$0.00</span>
                            </div>
                            <div class="pnl-stat">
                                <span class="label">This Week</span>
                                <span class="value" id="pnlWeek">$0.00</span>
                            </div>
                            <div class="pnl-stat">
                                <span class="label">This Month</span>
                                <span class="value" id="pnlMonth">$0.00</span>
                            </div>
                            <div class="pnl-stat">
                                <span class="label">Open Positions</span>
                                <span class="value" id="openPositions">0</span>
                            </div>
                        </div>
                        <div class="pnl-chart-mini">
                            <canvas id="pnlMiniChart" height="80"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Strategy Leaderboard -->
            <div class="panel">
                <div class="panel-header">
                    <h3>üèÜ Strategy Leaderboard</h3>
                    <select id="leaderboardPeriod" class="metric-select" title="Leaderboard period">
                        <option value="7d">Last 7 Days</option>
                        <option value="30d">Last 30 Days</option>
                        <option value="all">All Time</option>
                    </select>
                </div>
                <div class="panel-body">
                    <table class="performers-table leaderboard-table">
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Strategy</th>
                                <th>P&L</th>
                                <th>Win Rate</th>
                                <th>Trades</th>
                                <th>Trend</th>
                            </tr>
                        </thead>
                        <tbody id="leaderboardBody">
                            <tr>
                                <td colspan="6" class="table-loading">Loading leaderboard...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <footer>
            <p>Bybit Strategy Tester v2.0 ‚Ä¢ &copy; 2025 ‚Ä¢ 
                <a href="docs/index.html" class="footer-link">Documentation</a> ‚Ä¢ 
                <a href="/api/v1/docs" class="footer-link">API</a>
            </p>
        </footer>
    </div>

    <script>
        // Configuration
        const API_BASE = '/api/v1';
        let currentPeriod = '24h';
        let refreshInterval = null;

        // Period selector
        document.querySelectorAll('.period-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentPeriod = btn.dataset.period;
                refreshDashboard();
            });
        });

        // Metric selector for top performers
        document.getElementById('performerMetric').addEventListener('change', (e) => {
            loadTopPerformers(e.target.value);
        });

        // Main refresh function
        async function refreshDashboard() {
            const indicator = document.getElementById('refreshIndicator');
            indicator.classList.add('loading');

            try {
                await Promise.all([
                    loadMetricsSummary(),
                    loadTopPerformers(),
                    loadSystemHealth()
                ]);
                
                document.getElementById('lastUpdate').textContent = 
                    `Last updated: ${new Date().toLocaleTimeString()}`;
            } catch (error) {
                console.error('Dashboard refresh failed:', error);
                showToast('Dashboard refresh failed. Check your connection.', 'error');
            } finally {
                indicator.classList.remove('loading');
            }
        }

        // Load metrics summary
        async function loadMetricsSummary() {
            try {
                const url = getMetricsUrl();
                const response = await fetch(url);
                if (!response.ok) throw new Error('Failed to load metrics');
                
                const data = await response.json();
                
                // Update stats cards
                document.getElementById('totalBacktests').textContent = data.backtests.total;
                document.getElementById('runningBacktests').textContent = data.backtests.running;
                document.getElementById('completedBacktests').textContent = data.backtests.completed;
                document.getElementById('failedBacktests').textContent = `${data.backtests.failed} failed`;
                
                const successRate = (data.backtests.success_rate * 100).toFixed(1);
                document.getElementById('successRate').textContent = `${successRate}%`;
                
                document.getElementById('activeStrategies').textContent = data.strategies.active;
                document.getElementById('totalStrategies').textContent = data.strategies.total;
                
                document.getElementById('totalOptimizations').textContent = data.optimizations.total;
                document.getElementById('runningOptimizations').textContent = data.optimizations.running;
                
                document.getElementById('totalTrades').textContent = formatNumber(data.performance.total_trades_analyzed);
                document.getElementById('avgDuration').textContent = `${data.performance.avg_backtest_duration_sec.toFixed(1)}s`;
                
            } catch (error) {
                console.error('Metrics summary error:', error);
                showToast('Failed to load metrics summary', 'error');
            }
        }

        // Load top performers
        async function loadTopPerformers(metric = null) {
            metric = metric || document.getElementById('performerMetric').value;
            
            try {
                const response = await fetch(`${API_BASE}/dashboard/metrics/top-performers?limit=10&metric=${metric}`);
                if (!response.ok) throw new Error('Failed to load top performers');
                
                const data = await response.json();
                const tbody = document.getElementById('performersBody');
                
                if (data.top_performers.length === 0) {
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="6" style="text-align: center; color: var(--text-muted);">
                                No completed backtests yet
                            </td>
                        </tr>`;
                    return;
                }
                
                tbody.innerHTML = data.top_performers.map((item, index) => `
                    <tr>
                        <td class="rank">${index + 1}</td>
                        <td class="strategy-name">${escapeHtml(item.strategy_name)}</td>
                        <td>${item.symbol}</td>
                        <td class="metric-value">${item.sharpe_ratio.toFixed(2)}</td>
                        <td class="${item.total_return >= 0 ? 'positive' : 'negative'}">${item.total_return.toFixed(1)}%</td>
                        <td>${(item.win_rate * 100).toFixed(1)}%</td>
                    </tr>
                `).join('');
                
                // Store data for chart updates
                window.lastPerformers = data.top_performers;
                
                // Update charts with new data
                updateChartsWithData(data.top_performers);
                
                // Update activity from top performers
                updateRecentActivity(data.top_performers);
                
            } catch (error) {
                console.error('Top performers error:', error);
                document.getElementById('performersBody').innerHTML = `
                    <tr>
                        <td colspan="6" style="text-align: center; color: var(--error-color);">
                            Failed to load data
                        </td>
                    </tr>`;
            }
        }

        // Load system health
        async function loadSystemHealth() {
            try {
                const response = await fetch(`${API_BASE}/dashboard/metrics/system-health`);
                if (!response.ok) throw new Error('Failed to load system health');
                
                const data = await response.json();
                
                // Update status badge
                const statusBadge = document.getElementById('systemStatus');
                statusBadge.textContent = data.status.charAt(0).toUpperCase() + data.status.slice(1);
                statusBadge.style.background = data.status === 'healthy' ? 'var(--success-color)' : 'var(--error-color)';
                
                // Update health items
                document.getElementById('dbResponseTime').textContent = `${data.database.response_time_ms}ms`;
                const dbStatus = document.getElementById('dbStatus');
                dbStatus.className = 'status-dot ' + (data.database.connected ? 'healthy' : 'unhealthy');
                
                document.getElementById('pendingTasks').textContent = `${data.queue.pending_tasks} pending`;
                const queueStatus = document.getElementById('queueStatus');
                queueStatus.className = 'status-dot ' + (data.queue.pending_tasks > 50 ? 'warning' : 'healthy');
                
                document.getElementById('dbSize').textContent = formatBytes(data.disk.database_size_mb * 1024 * 1024);
                
                // Agent status
                if (data.agents) {
                    const agentInfo = Object.entries(data.agents).map(([name, state]) => 
                        `${name}: ${state.state || 'ok'}`
                    ).join(', ');
                    document.getElementById('agentsStatus').textContent = 
                        Object.keys(data.agents).length > 0 ? `${Object.keys(data.agents).length} active` : 'None';
                    const agentsDot = document.getElementById('agentsDot');
                    agentsDot.className = 'status-dot healthy';
                }
                
            } catch (error) {
                console.error('System health error:', error);
                document.getElementById('systemStatus').textContent = 'Error';
                document.getElementById('systemStatus').style.background = 'var(--error-color)';
                showToast('Failed to load system health status', 'warning');
            }
        }

        // Update recent activity
        function updateRecentActivity(performers) {
            const activityList = document.getElementById('activityList');
            
            if (!performers || performers.length === 0) {
                activityList.innerHTML = `
                    <li style="text-align: center; color: var(--text-muted); padding: 30px;">
                        No recent activity
                    </li>`;
                document.getElementById('activityCount').textContent = '0';
                return;
            }
            
            activityList.innerHTML = performers.slice(0, 5).map(item => `
                <li class="activity-item">
                    <div class="activity-icon backtest">üìà</div>
                    <div class="activity-content">
                        <div class="title">Backtest completed: ${escapeHtml(item.strategy_name)}</div>
                        <div class="details">
                            ${item.symbol} ‚Ä¢ Sharpe: ${item.sharpe_ratio.toFixed(2)} ‚Ä¢ Return: ${item.total_return.toFixed(1)}%
                        </div>
                    </div>
                    <div class="activity-time">${formatDate(item.completed_at)}</div>
                </li>
            `).join('');
            
            document.getElementById('activityCount').textContent = performers.length.toString();
        }

        // Utility functions
        function formatNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            return num.toString();
        }

        function formatBytes(bytes) {
            if (bytes >= 1073741824) return (bytes / 1073741824).toFixed(2) + ' GB';
            if (bytes >= 1048576) return (bytes / 1048576).toFixed(1) + ' MB';
            if (bytes >= 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return bytes + ' B';
        }

        function formatDate(dateString) {
            if (!dateString) return '--';
            const date = new Date(dateString);
            const now = new Date();
            const diff = now - date;
            
            if (diff < 60000) return 'Just now';
            if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
            if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
            return date.toLocaleDateString();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ==========================================
        // CHART.JS CONFIGURATION
        // ==========================================
        
        // Chart color scheme
        const chartColors = {
            primary: '#4ecca3',
            secondary: '#4ecdc4',
            success: '#6bcb77',
            warning: '#ffd93d',
            error: '#ff6b6b',
            purple: '#9b59b6',
            grid: 'rgba(255, 255, 255, 0.1)',
            text: '#888'
        };

        // Chart.js global defaults
        Chart.defaults.color = chartColors.text;
        Chart.defaults.borderColor = chartColors.grid;
        Chart.defaults.font.family = "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif";

        // Chart instances
        let performanceChart = null;
        let distributionChart = null;
        let winRateChart = null;
        let activityChart = null;

        // Initialize all charts
        function initializeCharts() {
            initPerformanceChart();
            initDistributionChart();
            initWinRateChart();
            initActivityChart();
        }

        // Performance Over Time Chart (Line)
        function initPerformanceChart() {
            const ctx = document.getElementById('performanceChart');
            if (!ctx) return;
            
            performanceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Cumulative Return %',
                        data: [],
                        borderColor: chartColors.primary,
                        backgroundColor: 'rgba(78, 204, 163, 0.1)',
                        fill: true,
                        tension: 0.4,
                        pointRadius: 3,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(22, 33, 62, 0.95)',
                            titleColor: '#fff',
                            bodyColor: '#eee',
                            borderColor: chartColors.primary,
                            borderWidth: 1
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: chartColors.grid },
                            ticks: { maxTicksLimit: 8 }
                        },
                        y: {
                            grid: { color: chartColors.grid },
                            ticks: {
                                callback: (value) => value + '%'
                            }
                        }
                    }
                }
            });
        }

        // Returns Distribution Chart (Bar/Histogram)
        function initDistributionChart() {
            const ctx = document.getElementById('distributionChart');
            if (!ctx) return;
            
            distributionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['< -20%', '-20 to -10%', '-10 to 0%', '0 to 10%', '10 to 20%', '> 20%'],
                    datasets: [{
                        label: 'Backtests',
                        data: [0, 0, 0, 0, 0, 0],
                        backgroundColor: [
                            chartColors.error,
                            'rgba(255, 107, 107, 0.6)',
                            'rgba(255, 217, 61, 0.6)',
                            'rgba(107, 203, 119, 0.6)',
                            chartColors.success,
                            chartColors.primary
                        ],
                        borderRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { grid: { display: false } },
                        y: {
                            grid: { color: chartColors.grid },
                            beginAtZero: true,
                            ticks: { stepSize: 1 }
                        }
                    }
                }
            });
        }

        // Win Rate by Strategy Chart (Doughnut)
        function initWinRateChart() {
            const ctx = document.getElementById('winRateChart');
            if (!ctx) return;
            
            winRateChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['SMA Crossover', 'RSI', 'MACD', 'Bollinger', 'Custom'],
                    datasets: [{
                        data: [0, 0, 0, 0, 0],
                        backgroundColor: [
                            chartColors.primary,
                            chartColors.secondary,
                            chartColors.warning,
                            chartColors.purple,
                            chartColors.success
                        ],
                        borderWidth: 0,
                        hoverOffset: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '60%',
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                boxWidth: 12,
                                padding: 15,
                                usePointStyle: true
                            }
                        }
                    }
                }
            });
        }

        // Activity Timeline Chart (Bar)
        function initActivityChart() {
            const ctx = document.getElementById('activityChart');
            if (!ctx) return;
            
            activityChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Backtests',
                        data: [],
                        backgroundColor: chartColors.primary,
                        borderRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { grid: { display: false } },
                        y: {
                            grid: { color: chartColors.grid },
                            beginAtZero: true,
                            ticks: { stepSize: 1 }
                        }
                    }
                }
            });
        }

        // Update charts with data
        function updateChartsWithData(performers) {
            if (!performers || performers.length === 0) return;

            // Performance chart - cumulative returns
            const sortedByDate = [...performers].sort((a, b) => 
                new Date(a.completed_at) - new Date(b.completed_at)
            );
            
            let cumulative = 0;
            const cumulativeData = sortedByDate.map(p => {
                cumulative += p.total_return || 0;
                return {
                    x: new Date(p.completed_at).toLocaleDateString(),
                    y: cumulative
                };
            });

            if (performanceChart) {
                performanceChart.data.labels = cumulativeData.map(d => d.x);
                performanceChart.data.datasets[0].data = cumulativeData.map(d => d.y);
                performanceChart.update('none');
            }

            // Distribution chart
            const distribution = [0, 0, 0, 0, 0, 0];
            performers.forEach(p => {
                const ret = p.total_return || 0;
                if (ret < -20) distribution[0]++;
                else if (ret < -10) distribution[1]++;
                else if (ret < 0) distribution[2]++;
                else if (ret < 10) distribution[3]++;
                else if (ret < 20) distribution[4]++;
                else distribution[5]++;
            });

            if (distributionChart) {
                distributionChart.data.datasets[0].data = distribution;
                distributionChart.update('none');
            }

            // Win rate by strategy type
            const strategyStats = {};
            performers.forEach(p => {
                const type = p.strategy_type || 'Custom';
                if (!strategyStats[type]) strategyStats[type] = { wins: 0, total: 0 };
                strategyStats[type].total++;
                if ((p.win_rate || 0) > 0.5) strategyStats[type].wins++;
            });

            if (winRateChart) {
                const types = Object.keys(strategyStats);
                winRateChart.data.labels = types;
                winRateChart.data.datasets[0].data = types.map(t => strategyStats[t].total);
                winRateChart.update('none');
            }

            // Activity chart - backtests per day
            const activityByDay = {};
            performers.forEach(p => {
                const day = new Date(p.completed_at).toLocaleDateString();
                activityByDay[day] = (activityByDay[day] || 0) + 1;
            });

            const sortedDays = Object.keys(activityByDay).sort((a, b) => 
                new Date(a) - new Date(b)
            ).slice(-14); // Last 14 days

            if (activityChart) {
                activityChart.data.labels = sortedDays;
                activityChart.data.datasets[0].data = sortedDays.map(d => activityByDay[d]);
                activityChart.update('none');
            }
        }

        // ==========================================
        // WEBSOCKET REAL-TIME UPDATES
        // With Exponential Backoff & Jitter
        // ==========================================
        
        let ws = null;
        let wsReconnectAttempts = 0;
        let wsReconnectTimeout = null;
        
        // WebSocket configuration
        const WS_CONFIG = {
            maxReconnect: 10,          // Max attempts before giving up
            baseDelay: 1000,           // Initial delay (1 second)
            maxDelay: 30000,           // Max delay (30 seconds)
            jitterFactor: 0.3,         // Random jitter (¬±30%)
            pingInterval: 30000,       // Ping every 30 seconds
            pongTimeout: 5000          // Wait 5 seconds for pong
        };
        
        let wsPingInterval = null;
        let wsPongTimeout = null;

        function initWebSocket() {
            // Clear any existing reconnect timeout
            if (wsReconnectTimeout) {
                clearTimeout(wsReconnectTimeout);
                wsReconnectTimeout = null;
            }
            
            // Close existing connection if any
            if (ws && ws.readyState !== WebSocket.CLOSED) {
                ws.close();
            }
            
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/api/v1/dashboard/ws`;
            
            try {
                ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    console.log('[WebSocket] Connected successfully');
                    wsReconnectAttempts = 0;
                    updateWsStatus('connected');
                    
                    // Start ping interval to keep connection alive
                    startPingInterval();
                };
                
                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        
                        // Clear pong timeout on any message
                        if (wsPongTimeout) {
                            clearTimeout(wsPongTimeout);
                            wsPongTimeout = null;
                        }
                        
                        handleWsMessage(data);
                    } catch (e) {
                        console.error('[WebSocket] Message parse error:', e);
                    }
                };
                
                ws.onclose = (event) => {
                    console.log(`[WebSocket] Disconnected (code: ${event.code}, reason: ${event.reason || 'none'})`);
                    updateWsStatus('disconnected');
                    stopPingInterval();
                    attemptWsReconnect();
                };
                
                ws.onerror = (error) => {
                    console.error('[WebSocket] Error:', error);
                    updateWsStatus('disconnected');
                };
                
            } catch (e) {
                console.error('[WebSocket] Init error:', e);
                updateWsStatus('disconnected');
                attemptWsReconnect();
            }
        }
        
        function startPingInterval() {
            stopPingInterval();
            wsPingInterval = setInterval(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'ping', timestamp: Date.now() }));
                    
                    // Set timeout for pong response
                    wsPongTimeout = setTimeout(() => {
                        console.warn('[WebSocket] Pong timeout - connection may be dead');
                        ws.close();
                    }, WS_CONFIG.pongTimeout);
                }
            }, WS_CONFIG.pingInterval);
        }
        
        function stopPingInterval() {
            if (wsPingInterval) {
                clearInterval(wsPingInterval);
                wsPingInterval = null;
            }
            if (wsPongTimeout) {
                clearTimeout(wsPongTimeout);
                wsPongTimeout = null;
            }
        }

        function attemptWsReconnect() {
            if (wsReconnectAttempts >= WS_CONFIG.maxReconnect) {
                console.log('[WebSocket] Max reconnect attempts reached, falling back to polling only');
                showToast('Live updates unavailable. Using polling mode.', 'warning');
                return;
            }
            
            wsReconnectAttempts++;
            
            // Calculate exponential backoff with jitter
            const exponentialDelay = Math.min(
                WS_CONFIG.baseDelay * Math.pow(2, wsReconnectAttempts - 1),
                WS_CONFIG.maxDelay
            );
            
            // Add random jitter (¬±30%)
            const jitter = exponentialDelay * WS_CONFIG.jitterFactor * (Math.random() * 2 - 1);
            const delay = Math.round(exponentialDelay + jitter);
            
            console.log(`[WebSocket] Reconnect attempt ${wsReconnectAttempts}/${WS_CONFIG.maxReconnect} in ${delay}ms`);
            
            wsReconnectTimeout = setTimeout(initWebSocket, delay);
        }
        
        // Manual reconnect function (can be called from UI)
        function reconnectWebSocket() {
            console.log('[WebSocket] Manual reconnect requested');
            wsReconnectAttempts = 0;
            initWebSocket();
        }

        function updateWsStatus(status) {
            const wsStatusEl = document.getElementById('wsStatus');
            if (!wsStatusEl) return;
            
            wsStatusEl.className = 'ws-status ' + status;
            const statusText = wsStatusEl.querySelector('span');
            if (statusText) {
                statusText.textContent = status === 'connected' ? 'Live' : 'Offline';
            }
            
            // Make status clickable for manual reconnect
            if (status === 'disconnected') {
                wsStatusEl.style.cursor = 'pointer';
                wsStatusEl.title = 'Click to reconnect';
                wsStatusEl.onclick = reconnectWebSocket;
            } else {
                wsStatusEl.style.cursor = 'default';
                wsStatusEl.title = 'Real-time updates active';
                wsStatusEl.onclick = null;
            }
        }

        function handleWsMessage(data) {
            // Don't log every message to reduce console noise
            if (data.type !== 'pong') {
                console.log('[WebSocket] Message:', data.type);
            }
            
            switch (data.type) {
                case 'connected':
                    // Server confirmed connection
                    console.log('[WebSocket] Connection confirmed:', data.message);
                    break;
                    
                case 'pong':
                    // Ping-pong response - connection is healthy
                    break;
                    
                case 'metrics_update':
                    // Real-time metrics update from server
                    if (data.data) {
                        const metrics = data.data;
                        if (metrics.backtests) {
                            document.getElementById('totalBacktests').textContent = metrics.backtests.total || '--';
                            document.getElementById('runningBacktests').textContent = metrics.backtests.running || 0;
                            // Update success rate if available
                            const successRateEl = document.getElementById('successRate');
                            if (successRateEl && metrics.backtests.success_rate !== undefined) {
                                successRateEl.textContent = (metrics.backtests.success_rate * 100).toFixed(1) + '%';
                            }
                        }
                        if (metrics.strategies) {
                            const activeStratsEl = document.getElementById('activeStrategies');
                            if (activeStratsEl) {
                                activeStratsEl.textContent = metrics.strategies.active || 0;
                            }
                        }
                        // Update charts with new data
                        updateChartsWithData(data.data);
                    }
                    break;
                    
                case 'backtest_completed':
                    // New backtest completed - refresh data
                    showNotification(`Backtest completed: ${data.strategy_name}`, 'success');
                    loadTopPerformers();
                    loadMetricsSummary();
                    break;
                    
                case 'health_update':
                    // System health update
                    if (data.health) {
                        document.getElementById('systemStatus').textContent = data.health.status || '--';
                    }
                    break;
                    
                default:
                    console.log('Unknown WebSocket message type:', data.type);
            }
        }

        function showNotification(message, type = 'info') {
            // Alias to new toast system
            showToast(message, type);
        }

        // ==========================================
        // CUSTOM DATE RANGE
        // ==========================================
        
        let customDateFrom = null;
        let customDateTo = null;

        function applyCustomDateRange() {
            const fromInput = document.getElementById('dateFrom');
            const toInput = document.getElementById('dateTo');
            
            if (!fromInput.value || !toInput.value) {
                alert('Please select both start and end dates');
                return;
            }
            
            customDateFrom = fromInput.value;
            customDateTo = toInput.value;
            
            // Clear period button selection
            document.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
            
            // Set custom period
            currentPeriod = 'custom';
            
            refreshDashboard();
        }

        // Modify the fetch URL to include custom dates
        function getMetricsUrl() {
            if (currentPeriod === 'custom' && customDateFrom && customDateTo) {
                return `${API_BASE}/dashboard/metrics/summary?from=${customDateFrom}&to=${customDateTo}`;
            }
            return `${API_BASE}/dashboard/metrics/summary?period=${currentPeriod}`;
        }

        // Set default dates (last 7 days)
        function initDatePickers() {
            const today = new Date();
            const weekAgo = new Date(today);
            weekAgo.setDate(weekAgo.getDate() - 7);
            
            const dateFrom = document.getElementById('dateFrom');
            const dateTo = document.getElementById('dateTo');
            
            if (dateFrom) dateFrom.value = weekAgo.toISOString().split('T')[0];
            if (dateTo) dateTo.value = today.toISOString().split('T')[0];
        }

        // Chart metric selector
        document.getElementById('chartMetricSelect')?.addEventListener('change', (e) => {
            const metric = e.target.value;
            // Update performance chart based on selected metric
            if (performanceChart && window.lastPerformers) {
                updatePerformanceChartMetric(metric);
            }
        });

        function updatePerformanceChartMetric(metric) {
            const performers = window.lastPerformers || [];
            const sortedByDate = [...performers].sort((a, b) => 
                new Date(a.completed_at) - new Date(b.completed_at)
            );

            let data, label;
            switch (metric) {
                case 'sharpe':
                    data = sortedByDate.map(p => p.sharpe_ratio || 0);
                    label = 'Sharpe Ratio';
                    break;
                case 'trades':
                    data = sortedByDate.map(p => p.total_trades || 0);
                    label = 'Trade Count';
                    break;
                default:
                    let cumulative = 0;
                    data = sortedByDate.map(p => {
                        cumulative += p.total_return || 0;
                        return cumulative;
                    });
                    label = 'Cumulative Return %';
            }

            performanceChart.data.labels = sortedByDate.map(p => 
                new Date(p.completed_at).toLocaleDateString()
            );
            performanceChart.data.datasets[0].data = data;
            performanceChart.data.datasets[0].label = label;
            performanceChart.update('none');
        }

        // NOTE: DOMContentLoaded handler moved to consolidated handler below (line ~3047)
        // This ensures all initialization happens in one place

        // Clean up on page leave
        window.addEventListener('beforeunload', () => {
            // Clear all managed intervals
            IntervalManager.clearAll();
            
            // Stop WebSocket ping and close connection
            stopPingInterval();
            if (ws) {
                ws.onclose = null; // Prevent reconnect on intentional close
                ws.close();
            }
            
            // Clear any pending reconnect timeout
            if (wsReconnectTimeout) {
                clearTimeout(wsReconnectTimeout);
            }
        });

        // Add CSS animation for notifications
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        // =====================================================
        // NEW: Dashboard Improvements - Milestone 4.4
        // =====================================================

        let portfolioHistoryChart = null;
        let pnlMiniChart = null;
        let portfolioDays = 7;

        // Initialize new charts
        function initializeNewCharts() {
            // Portfolio History Chart
            const portfolioCtx = document.getElementById('portfolioHistoryChart');
            if (portfolioCtx) {
                portfolioHistoryChart = new Chart(portfolioCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Portfolio Value',
                            data: [],
                            borderColor: '#4ecca3',
                            backgroundColor: 'rgba(78, 204, 163, 0.1)',
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            x: {
                                grid: { color: 'rgba(255,255,255,0.1)' },
                                ticks: { color: '#888' }
                            },
                            y: {
                                grid: { color: 'rgba(255,255,255,0.1)' },
                                ticks: { 
                                    color: '#888',
                                    callback: v => '$' + v.toLocaleString()
                                }
                            }
                        }
                    }
                });
            }

            // P&L Mini Chart
            const pnlCtx = document.getElementById('pnlMiniChart');
            if (pnlCtx) {
                pnlMiniChart = new Chart(pnlCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            data: [],
                            borderColor: '#6bcb77',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            x: { display: false },
                            y: { display: false }
                        }
                    }
                });
            }
        }

        // Load Portfolio History
        async function loadPortfolioHistory() {
            try {
                const response = await fetch(`${API_BASE}/dashboard/portfolio/history?days=${portfolioDays}`);
                if (!response.ok) throw new Error('Failed to load portfolio history');
                
                const data = await response.json();
                
                if (portfolioHistoryChart && data.history && data.history.length > 0) {
                    portfolioHistoryChart.data.labels = data.history.map(h => 
                        new Date(h.timestamp).toLocaleDateString()
                    );
                    portfolioHistoryChart.data.datasets[0].data = data.history.map(h => h.total_value);
                    portfolioHistoryChart.update('none');
                }
            } catch (error) {
                console.error('Portfolio history error:', error);
                showToast('Failed to load portfolio history', 'warning');
            }
        }

        // Load AI Recommendations
        async function loadAIRecommendations() {
            const container = document.getElementById('aiRecommendations');
            if (!container) return;

            container.innerHTML = `
                <div class="ai-loading">
                    <div class="spinner"></div>
                    <span>Analyzing portfolio...</span>
                </div>
            `;

            try {
                const response = await fetch(`${API_BASE}/dashboard/ai-recommendations`);
                if (!response.ok) throw new Error('Failed to load AI recommendations');
                
                const data = await response.json();
                
                if (data.recommendations && data.recommendations.length > 0) {
                    container.innerHTML = data.recommendations.map(rec => `
                        <div class="ai-recommendation ${rec.priority}-priority">
                            <div class="rec-header">
                                <span class="rec-type">${rec.type}</span>
                                <span class="rec-priority">${rec.priority.toUpperCase()}</span>
                            </div>
                            <div class="rec-title">${rec.title || 'Recommendation'}</div>
                            <div class="rec-message">${rec.description || ''}</div>
                            ${rec.action ? `<div class="rec-action">üí° <a href="${rec.action}">${rec.action}</a></div>` : ''}
                        </div>
                    `).join('');
                } else {
                    container.innerHTML = `
                        <div class="ai-recommendation">
                            <div class="rec-message">‚úÖ No immediate recommendations. Your portfolio is performing well!</div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('AI recommendations error:', error);
                container.innerHTML = `
                    <div class="error-message">
                        Failed to load AI recommendations. <button onclick="loadAIRecommendations()">Retry</button>
                    </div>
                `;
            }
        }

        // Load Current P&L
        async function loadCurrentPnL() {
            try {
                const response = await fetch(`${API_BASE}/dashboard/pnl/current`);
                if (!response.ok) throw new Error('Failed to load P&L');
                
                const data = await response.json();
                
                // Update P&L display
                const pnlValue = document.getElementById('currentPnL');
                if (pnlValue) {
                    const value = data.current_pnl || 0;
                    pnlValue.textContent = (value >= 0 ? '+' : '') + '$' + Math.abs(value).toFixed(2);
                    pnlValue.className = 'pnl-value ' + (value >= 0 ? 'positive' : 'negative');
                }

                // Update stats
                updatePnLStat('pnlToday', data.today_pnl);
                updatePnLStat('pnlWeek', data.week_pnl);
                updatePnLStat('pnlMonth', data.month_pnl);
                
                const openPos = document.getElementById('openPositions');
                if (openPos) openPos.textContent = data.open_positions || 0;

                // Update mini chart
                if (pnlMiniChart && data.hourly_pnl && data.hourly_pnl.length > 0) {
                    pnlMiniChart.data.labels = data.hourly_pnl.map((_, i) => i);
                    pnlMiniChart.data.datasets[0].data = data.hourly_pnl;
                    pnlMiniChart.data.datasets[0].borderColor = 
                        data.current_pnl >= 0 ? '#6bcb77' : '#ff6b6b';
                    pnlMiniChart.update('none');
                }
            } catch (error) {
                console.error('P&L error:', error);
                // Silent fail for P&L - it updates frequently
            }
        }

        function updatePnLStat(id, value) {
            const el = document.getElementById(id);
            if (el) {
                const v = value || 0;
                el.textContent = (v >= 0 ? '+' : '') + '$' + Math.abs(v).toFixed(2);
                el.className = 'value ' + (v >= 0 ? 'positive' : 'negative');
            }
        }

        // Load Strategy Leaderboard
        async function loadStrategyLeaderboard() {
            const tbody = document.getElementById('leaderboardBody');
            if (!tbody) return;

            const period = document.getElementById('leaderboardPeriod')?.value || '7d';

            try {
                const response = await fetch(`${API_BASE}/dashboard/strategy-leaderboard?period=${period}`);
                if (!response.ok) throw new Error('Failed to load leaderboard');
                
                const data = await response.json();
                
                if (data.leaderboard && data.leaderboard.length > 0) {
                    tbody.innerHTML = data.leaderboard.map((s, i) => {
                        const rankClass = i < 3 ? `rank-${i + 1}` : '';
                        const trendIcon = s.trend > 0 ? 'üìà' : (s.trend < 0 ? 'üìâ' : '‚û°Ô∏è');
                        const trendClass = s.trend > 0 ? 'trend-up' : (s.trend < 0 ? 'trend-down' : 'trend-neutral');
                        const pnlClass = s.pnl >= 0 ? 'trend-up' : 'trend-down';
                        
                        return `
                            <tr class="${rankClass}">
                                <td>${i + 1}</td>
                                <td>${s.strategy_name}</td>
                                <td class="${pnlClass}">${s.pnl >= 0 ? '+' : ''}$${Math.abs(s.pnl).toFixed(2)}</td>
                                <td>${(s.win_rate * 100).toFixed(1)}%</td>
                                <td>${s.trade_count}</td>
                                <td class="${trendClass}">${trendIcon}</td>
                            </tr>
                        `;
                    }).join('');
                } else {
                    tbody.innerHTML = '<tr><td colspan="6" class="table-loading">No strategies found</td></tr>';
                }
            } catch (error) {
                console.error('Leaderboard error:', error);
                tbody.innerHTML = '<tr><td colspan="6" class="table-loading">Error loading leaderboard</td></tr>';
                showToast('Failed to load strategy leaderboard', 'warning');
            }
        }

        // Portfolio period selector
        document.querySelectorAll('#portfolioPeriodSelector .period-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('#portfolioPeriodSelector .period-btn').forEach(b => 
                    b.classList.remove('active')
                );
                btn.classList.add('active');
                portfolioDays = parseInt(btn.dataset.days);
                loadPortfolioHistory();
            });
        });

        // Leaderboard period selector
        document.getElementById('leaderboardPeriod')?.addEventListener('change', () => {
            loadStrategyLeaderboard();
        });

        // =====================================================
        // INTERVAL MANAGER - Centralized Update Scheduler
        // =====================================================
        const IntervalManager = {
            intervals: new Map(),
            paused: false,
            debug: false,
            
            // Register a new interval
            register(name, callback, intervalMs, options = {}) {
                if (this.intervals.has(name)) {
                    this.clear(name);
                }
                
                const config = {
                    callback,
                    intervalMs,
                    immediate: options.immediate !== false,
                    runWhenHidden: options.runWhenHidden || false,
                    lastRun: 0,
                    intervalId: null,
                    errorCount: 0,
                    maxErrors: options.maxErrors || 5
                };
                
                this.intervals.set(name, config);
                
                // Run immediately if requested
                if (config.immediate && !this.paused) {
                    this._execute(name);
                }
                
                // Start the interval
                config.intervalId = setInterval(() => this._tick(name), intervalMs);
                
                if (this.debug) console.log(`[IntervalManager] Registered: ${name} (${intervalMs}ms)`);
                return this;
            },
            
            // Internal tick handler
            _tick(name) {
                const config = this.intervals.get(name);
                if (!config) return;
                
                // Skip if paused or page hidden (unless runWhenHidden)
                if (this.paused) return;
                if (document.hidden && !config.runWhenHidden) return;
                
                this._execute(name);
            },
            
            // Execute callback with error handling
            async _execute(name) {
                const config = this.intervals.get(name);
                if (!config) return;
                
                try {
                    config.lastRun = Date.now();
                    await config.callback();
                    config.errorCount = 0; // Reset on success
                } catch (err) {
                    config.errorCount++;
                    console.error(`[IntervalManager] Error in ${name}:`, err);
                    
                    if (config.errorCount >= config.maxErrors) {
                        console.warn(`[IntervalManager] ${name} disabled after ${config.maxErrors} errors`);
                        this.clear(name);
                        showToast(`Auto-update for ${name} disabled due to errors`, 'warning');
                    }
                }
            },
            
            // Clear a specific interval
            clear(name) {
                const config = this.intervals.get(name);
                if (config && config.intervalId) {
                    clearInterval(config.intervalId);
                    this.intervals.delete(name);
                    if (this.debug) console.log(`[IntervalManager] Cleared: ${name}`);
                }
            },
            
            // Clear all intervals
            clearAll() {
                this.intervals.forEach((config, name) => {
                    if (config.intervalId) clearInterval(config.intervalId);
                });
                this.intervals.clear();
                if (this.debug) console.log('[IntervalManager] All intervals cleared');
            },
            
            // Pause all intervals
            pause() {
                this.paused = true;
                if (this.debug) console.log('[IntervalManager] Paused');
            },
            
            // Resume all intervals
            resume() {
                this.paused = false;
                if (this.debug) console.log('[IntervalManager] Resumed');
                // Run all immediate callbacks
                this.intervals.forEach((config, name) => {
                    if (config.immediate) this._execute(name);
                });
            },
            
            // Get status
            status() {
                const status = {
                    paused: this.paused,
                    intervals: []
                };
                this.intervals.forEach((config, name) => {
                    status.intervals.push({
                        name,
                        intervalMs: config.intervalMs,
                        lastRun: config.lastRun ? new Date(config.lastRun).toLocaleTimeString() : 'never',
                        errorCount: config.errorCount
                    });
                });
                return status;
            },
            
            // Force run a specific interval now
            runNow(name) {
                if (this.intervals.has(name)) {
                    this._execute(name);
                }
            },
            
            // Adjust interval timing
            setInterval(name, newIntervalMs) {
                const config = this.intervals.get(name);
                if (config) {
                    clearInterval(config.intervalId);
                    config.intervalMs = newIntervalMs;
                    config.intervalId = setInterval(() => this._tick(name), newIntervalMs);
                    if (this.debug) console.log(`[IntervalManager] ${name} interval changed to ${newIntervalMs}ms`);
                }
            }
        };

        // Page Visibility API - pause updates when tab is hidden
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                IntervalManager.pause();
                console.log('[Dashboard] Tab hidden - updates paused');
            } else {
                IntervalManager.resume();
                console.log('[Dashboard] Tab visible - updates resumed');
            }
        });

        // =====================================================
        // CONSOLIDATED DOMContentLoaded Handler
        // All dashboard initialization in one place
        // =====================================================
        document.addEventListener('DOMContentLoaded', () => {
            // ---- Core Initialization ----
            initDatePickers();
            initializeCharts();
            refreshDashboard();
            
            // Try WebSocket, fall back to polling
            initWebSocket();
            
            // ---- Milestone 4.4 Charts ----
            initializeNewCharts();
            loadPortfolioHistory();
            loadAIRecommendations();
            loadCurrentPnL();
            loadStrategyLeaderboard();
            
            // ---- Dashboard Enhancements ----
            initMarketOverview();
            initLiveTicker();
            initWatchlist();
            initMiniCalendar();
            initRiskHeatmap();
            initKeyboardShortcuts();
            loadTheme();
            initToastContainer();
            
            // ---- Auto-refresh via IntervalManager ----
            // Dashboard metrics every 30 seconds (backup for WebSocket)
            IntervalManager.register('dashboard', refreshDashboard, 30000, { immediate: false });
            
            // P&L every 10 seconds
            IntervalManager.register('pnl', loadCurrentPnL, 10000, { immediate: false });
            
            // Market data every 5 seconds (critical for trading)
            IntervalManager.register('market', updateMarketData, 5000, { immediate: false });
            
            // Watchlist prices every 10 seconds
            IntervalManager.register('watchlist', updateWatchlistPrices, 10000, { immediate: false });
            
            // Portfolio history every 60 seconds
            IntervalManager.register('portfolio', loadPortfolioHistory, 60000, { immediate: false });
            
            // AI Recommendations every 2 minutes
            IntervalManager.register('ai-recommendations', loadAIRecommendations, 120000, { immediate: false });
            
            // Strategy leaderboard every 60 seconds
            IntervalManager.register('leaderboard', loadStrategyLeaderboard, 60000, { immediate: false });
            
            console.log('[Dashboard] Initialized with IntervalManager:', IntervalManager.status());
        });

        // =====================================================
        // NEW: Enhanced Dashboard Features
        // =====================================================

        // Theme Toggle
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('dashboard_theme', newTheme);
            updateThemeIcons(newTheme);
        }

        function loadTheme() {
            const savedTheme = localStorage.getItem('dashboard_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeIcons(savedTheme);
        }

        function updateThemeIcons(theme) {
            const darkIcon = document.getElementById('darkModeIcon');
            const lightIcon = document.getElementById('lightModeIcon');
            if (theme === 'dark') {
                darkIcon?.classList.add('active');
                lightIcon?.classList.remove('active');
            } else {
                darkIcon?.classList.remove('active');
                lightIcon?.classList.add('active');
            }
        }

        // Keyboard Shortcuts
        function initKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Skip if in input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                    return;
                }

                const key = e.key.toLowerCase();

                switch (key) {
                    case '?':
                        showShortcuts();
                        break;
                    case 'escape':
                        hideShortcuts();
                        break;
                    case 'd':
                        window.location.href = 'dashboard.html';
                        break;
                    case 's':
                        window.location.href = 'strategies.html';
                        break;
                    case 't':
                        window.location.href = 'trading.html';
                        break;
                    case 'c':
                        window.location.href = 'market-chart.html';
                        break;
                    case 'a':
                        window.location.href = 'analytics.html';
                        break;
                    case 'r':
                        refreshDashboard();
                        break;
                    case 'n':
                        window.location.href = 'strategies.html?action=new';
                        break;
                    case 'l':
                        toggleTheme();
                        break;
                    case 'i':
                        window.location.href = 'notifications.html';
                        break;
                    case 'o':
                        window.location.href = 'settings.html';
                        break;
                }
            });
        }

        function showShortcuts() {
            document.getElementById('shortcutsModal')?.classList.add('show');
        }

        function hideShortcuts() {
            document.getElementById('shortcutsModal')?.classList.remove('show');
        }

        // Market Overview - Dynamic top by volume from Bybit API
        let marketData = [];

        // Fetch real market data from API - Dynamic top 6 by trading volume
        async function fetchMarketData() {
            try {
                // Fetch top 6 by 24h trading volume (dynamic)
                const response = await fetch('/api/v1/dashboard/market/tickers?top=6');
                const data = await response.json();
                if (data.success && data.tickers) {
                    // Replace marketData with dynamic top from API
                    marketData = data.tickers.map(ticker => ({
                        symbol: ticker.symbol,
                        name: ticker.name,
                        icon: ticker.icon,
                        color: ticker.color,
                        price: ticker.price || 0,
                        change: ticker.change || 0,
                        volume_24h: ticker.volume_24h || 0,
                        turnover_24h: ticker.turnover_24h || 0
                    }));
                    // Re-render market overview with new data
                    renderMarketOverview();
                    updateLiveTicker();
                }
            } catch (err) {
                console.error('Failed to fetch market data:', err);
                // Silent fail for market data - it updates frequently
            }
        }

        function renderMarketOverview() {
            const container = document.getElementById('marketOverview');
            if (!container) return;

            container.innerHTML = marketData.map(m => `
                <div class="market-card" onclick="window.location.href='market-chart.html?symbol=${m.symbol}'">
                    <div class="market-icon" style="background: ${m.color}22; color: ${m.color}">
                        ${m.icon}
                    </div>
                    <div class="market-info">
                        <div class="market-symbol">${m.symbol.replace('USDT', '')}</div>
                        <div class="market-name">${m.name}</div>
                    </div>
                    <div class="market-data">
                        <div class="market-price" id="price-${m.symbol}">$${m.price ? m.price.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: m.price < 1 ? 4 : 2}) : '--'}</div>
                        <div class="market-change ${m.change >= 0 ? 'up' : 'down'}" id="change-${m.symbol}">
                            ${m.change >= 0 ? '+' : ''}${m.change.toFixed(2)}%
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function initMarketOverview() {
            renderMarketOverview();
            // Fetch real data immediately
            fetchMarketData();
            // NOTE: Interval now managed by IntervalManager in DOMContentLoaded
        }

        function updateMarketData() {
            // Now handled by fetchMarketData()
            fetchMarketData();
        }

        // Live Ticker - Top 20 by volume (separate from cards)
        let tickerData = [];

        async function fetchTickerData() {
            try {
                // Fetch top 20 by trading volume for the scrolling ticker
                const response = await fetch('/api/v1/dashboard/market/tickers?top=20');
                const data = await response.json();
                if (data.success && data.tickers) {
                    tickerData = data.tickers;
                    renderLiveTicker();
                }
            } catch (err) {
                console.error('Failed to fetch ticker data:', err);
                // Silent fail for ticker - it updates frequently
            }
        }

        let tickerInitialized = false;

        function renderLiveTicker() {
            const track = document.getElementById('tickerTrack');
            if (!track || tickerData.length === 0) return;

            const tickerItems = tickerData.map(m => ({
                symbol: m.symbol.replace('USDT', '/USDT'),
                price: m.price,
                change: m.change
            }));

            // If already initialized, only update prices without re-rendering
            // This prevents animation reset/jerk
            if (tickerInitialized) {
                // Update existing elements in place
                const items = track.querySelectorAll('.ticker-item');
                tickerItems.forEach((item, idx) => {
                    // Update both copies (original and duplicate)
                    [idx, idx + tickerItems.length].forEach(i => {
                        if (items[i]) {
                            const priceEl = items[i].querySelector('.ticker-price');
                            const changeEl = items[i].querySelector('.ticker-change');
                            if (priceEl) {
                                priceEl.textContent = '$' + (item.price ? item.price.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: item.price < 1 ? 4 : 2 }) : '--');
                            }
                            if (changeEl) {
                                changeEl.textContent = (item.change >= 0 ? '‚ñ≤' : '‚ñº') + ' ' + Math.abs(item.change).toFixed(2) + '%';
                                changeEl.className = 'ticker-change ' + (item.change >= 0 ? 'positive' : 'negative');
                            }
                        }
                    });
                });
                return;
            }

            // Initial render - duplicate for seamless loop
            const html = [...tickerItems, ...tickerItems].map(item => `
                <div class="ticker-item">
                    <span class="ticker-symbol">${item.symbol}</span>
                    <span class="ticker-price">$${item.price ? item.price.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: item.price < 1 ? 4 : 2 }) : '--'}</span>
                    <span class="ticker-change ${item.change >= 0 ? 'positive' : 'negative'}">
                        ${item.change >= 0 ? '‚ñ≤' : '‚ñº'} ${Math.abs(item.change).toFixed(2)}%
                    </span>
                </div>
            `).join('');

            track.innerHTML = html;
            tickerInitialized = true;
        }

        // Legacy function for backward compatibility
        function updateLiveTicker() {
            renderLiveTicker();
        }

        function initLiveTicker() {
            // Fetch top 20 for ticker immediately
            fetchTickerData();
            // Register with IntervalManager for periodic updates
            IntervalManager.register('ticker', fetchTickerData, 15000, { immediate: false });
        }

        // =====================================================
        // Toast Notification System
        // =====================================================
        function initToastContainer() {
            if (document.getElementById('toastContainer')) return;
            
            const container = document.createElement('div');
            container.id = 'toastContainer';
            container.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                z-index: 10000;
                display: flex;
                flex-direction: column;
                gap: 10px;
                max-width: 400px;
            `;
            document.body.appendChild(container);
        }

        function showToast(message, type = 'info', duration = 4000) {
            const container = document.getElementById('toastContainer');
            if (!container) initToastContainer();
            
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            
            const icons = {
                success: '‚úÖ',
                error: '‚ùå',
                warning: '‚ö†Ô∏è',
                info: '‚ÑπÔ∏è'
            };
            
            const colors = {
                success: { bg: 'rgba(39, 174, 96, 0.95)', border: '#27ae60' },
                error: { bg: 'rgba(231, 76, 60, 0.95)', border: '#e74c3c' },
                warning: { bg: 'rgba(241, 196, 15, 0.95)', border: '#f1c40f' },
                info: { bg: 'rgba(52, 152, 219, 0.95)', border: '#3498db' }
            };
            
            const style = colors[type] || colors.info;
            
            toast.style.cssText = `
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 14px 18px;
                background: ${style.bg};
                border-left: 4px solid ${style.border};
                border-radius: 8px;
                color: white;
                font-size: 14px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                animation: toastSlideIn 0.3s ease-out;
                cursor: pointer;
            `;
            
            toast.innerHTML = `
                <span style="font-size: 18px;">${icons[type] || icons.info}</span>
                <span style="flex: 1;">${message}</span>
                <span style="opacity: 0.7; font-size: 16px;" onclick="this.parentElement.remove()">√ó</span>
            `;
            
            toast.addEventListener('click', () => toast.remove());
            
            document.getElementById('toastContainer').appendChild(toast);
            
            // Auto-remove after duration
            setTimeout(() => {
                toast.style.animation = 'toastSlideOut 0.3s ease-in forwards';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        // Add toast animations to document
        (function() {
            const toastStyle = document.createElement('style');
            toastStyle.textContent = `
                @keyframes toastSlideIn {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
                @keyframes toastSlideOut {
                    from { transform: translateX(0); opacity: 1; }
                    to { transform: translateX(100%); opacity: 0; }
                }
            `;
            document.head.appendChild(toastStyle);
        })();

        // =====================================================
        // Watchlist with API Updates
        // =====================================================
        let watchlist = JSON.parse(localStorage.getItem('dashboard_watchlist') || '["BTCUSDT","ETHUSDT","SOLUSDT"]');
        let watchlistPrices = {};

        function initWatchlist() {
            renderWatchlist();
            updateWatchlistPrices();
        }

        async function updateWatchlistPrices() {
            if (watchlist.length === 0) return;
            
            try {
                const symbolsParam = watchlist.join(',');
                const response = await fetch(`/api/v1/dashboard/market/tickers?symbols=${symbolsParam}`);
                const data = await response.json();
                
                if (data.success && data.tickers) {
                    data.tickers.forEach(ticker => {
                        watchlistPrices[ticker.symbol] = {
                            price: ticker.price,
                            change: ticker.change,
                            name: ticker.name || ticker.symbol.replace('USDT', '')
                        };
                    });
                    renderWatchlist();
                }
            } catch (err) {
                console.error('Failed to fetch watchlist prices:', err);
            }
        }

        function renderWatchlist() {
            const container = document.getElementById('watchlistWidget');
            if (!container) return;
            
            if (watchlist.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: #888;">
                        No symbols in watchlist.<br>
                        Click ‚ûï to add symbols.
                    </div>
                `;
                return;
            }
            
            const html = watchlist.map(symbol => {
                const priceData = watchlistPrices[symbol] || {};
                const price = priceData.price ? '$' + priceData.price.toLocaleString(undefined, { 
                    minimumFractionDigits: 2, 
                    maximumFractionDigits: priceData.price < 1 ? 6 : 2 
                }) : '--';
                const change = priceData.change !== undefined ? priceData.change : 0;
                const changeClass = change >= 0 ? 'up' : 'down';
                const changeText = (change >= 0 ? '+' : '') + change.toFixed(2) + '%';
                const name = priceData.name || symbol.replace('USDT', '');
                
                return `
                    <div class="watchlist-item" data-symbol="${symbol}">
                        <div class="watchlist-left">
                            <span class="watchlist-star" onclick="removeFromWatchlist('${symbol}')" title="Remove from watchlist">‚òÖ</span>
                            <div>
                                <div class="market-symbol">${symbol.replace('USDT', '/USDT')}</div>
                                <div class="market-name">${name}</div>
                            </div>
                        </div>
                        <div class="watchlist-right">
                            <div class="market-price">${price}</div>
                            <div class="market-change ${changeClass}">${changeText}</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            container.innerHTML = html;
        }

        function addToWatchlist() {
            const symbol = prompt('Enter symbol (e.g., BTCUSDT):');
            if (symbol) {
                const normalized = symbol.toUpperCase().replace(/[^A-Z]/g, '');
                const finalSymbol = normalized.endsWith('USDT') ? normalized : normalized + 'USDT';
                
                if (watchlist.includes(finalSymbol)) {
                    showToast(`${finalSymbol} is already in your watchlist`, 'warning');
                    return;
                }
                
                watchlist.push(finalSymbol);
                localStorage.setItem('dashboard_watchlist', JSON.stringify(watchlist));
                showToast(`${finalSymbol.replace('USDT', '/USDT')} added to watchlist`, 'success');
                updateWatchlistPrices();
            }
        }

        function removeFromWatchlist(symbol) {
            watchlist = watchlist.filter(s => s !== symbol);
            localStorage.setItem('dashboard_watchlist', JSON.stringify(watchlist));
            showToast(`${symbol.replace('USDT', '/USDT')} removed from watchlist`, 'info');
            renderWatchlist();
        }

        // Mini Calendar
        function initMiniCalendar() {
            // Calendar is already in HTML, just add interactivity
        }

        function renderCalendar(year, month) {
            const calendarGrid = document.querySelector('.calendar-days');
            if (!calendarGrid) return;

            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const today = new Date();

            // Events (example)
            const events = {
                '2025-01-15': 'Backtest scheduled',
                '2025-01-20': 'Strategy review'
            };

            let html = '';
            
            // Previous month days
            for (let i = 0; i < firstDay.getDay(); i++) {
                const prevDate = new Date(year, month, -firstDay.getDay() + i + 1);
                html += `<div class="calendar-day other-month">${prevDate.getDate()}</div>`;
            }

            // Current month days
            for (let day = 1; day <= lastDay.getDate(); day++) {
                const date = new Date(year, month, day);
                const dateStr = date.toISOString().split('T')[0];
                const isToday = date.toDateString() === today.toDateString();
                const hasEvent = events[dateStr];

                html += `<div class="calendar-day${isToday ? ' today' : ''}${hasEvent ? ' has-event' : ''}">${day}</div>`;
            }

            calendarGrid.innerHTML = html;
        }

        // Risk Heatmap
        function initRiskHeatmap() {
            // Risk heatmap is rendered in the panel
        }

        function getRiskClass(risk) {
            if (risk < 25) return 'risk-low';
            if (risk < 50) return 'risk-medium';
            if (risk < 75) return 'risk-high';
            return 'risk-extreme';
        }
    </script>
    <script type="module" src="/frontend/js/pages/dashboard.js"></script>
</body>
</html>
