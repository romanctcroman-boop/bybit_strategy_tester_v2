"""
Comprehensive tests for backend/indicators/rsi.py

Tests cover:
- calculate_rsi: Standard calculation, Wilder's smoothing, edge cases
- get_rsi_signal: Threshold logic, boundary conditions
- Edge cases: Insufficient data, all gains/losses, zero volatility
"""

import pytest
import pandas as pd
import numpy as np
from backend.indicators.rsi import calculate_rsi, get_rsi_signal


# =============================================================================
# Test Data Generators
# =============================================================================

def create_test_dataframe(prices, columns=None):
    """Create DataFrame from price list"""
    if columns is None:
        columns = ['close']
    
    df = pd.DataFrame({
        'close': prices,
        'open': prices,
        'high': [p * 1.001 for p in prices],
        'low': [p * 0.999 for p in prices],
        'volume': [1000] * len(prices)
    })
    return df


def create_uptrend_data(start=100, bars=30, increment=2):
    """Create uptrend price data (should produce high RSI)"""
    prices = [start + i * increment for i in range(bars)]
    return create_test_dataframe(prices)


def create_downtrend_data(start=200, bars=30, decrement=2):
    """Create downtrend price data (should produce low RSI)"""
    prices = [start - i * decrement for i in range(bars)]
    return create_test_dataframe(prices)


def create_sideways_data(price=150, bars=30, noise=0.5):
    """Create sideways price data (should produce neutral RSI ~50)"""
    np.random.seed(42)
    prices = [price + np.random.randn() * noise for _ in range(bars)]
    return create_test_dataframe(prices)


# =============================================================================
# Category 1: calculate_rsi - Standard Calculation (5 tests)
# =============================================================================

def test_calculate_rsi_with_default_period():
    """Test RSI calculation with default 14 period"""
    df = create_uptrend_data(bars=30)
    rsi = calculate_rsi(df)
    
    assert len(rsi) == len(df)
    assert isinstance(rsi, pd.Series)
    # Uptrend should have RSI > 50
    assert rsi.iloc[-1] > 50


def test_calculate_rsi_with_custom_period():
    """Test RSI calculation with custom period (7)"""
    df = create_downtrend_data(bars=30)
    rsi = calculate_rsi(df, period=7)
    
    assert len(rsi) == len(df)
    # Downtrend should have RSI < 50
    assert rsi.iloc[-1] < 50


def test_calculate_rsi_values_in_valid_range():
    """Test that RSI values are always between 0 and 100"""
    df = create_test_dataframe([100, 110, 90, 120, 80, 130, 70] * 5)
    rsi = calculate_rsi(df)
    
    assert all(rsi >= 0)
    assert all(rsi <= 100)


def test_calculate_rsi_with_custom_price_column():
    """Test RSI calculation using custom price column"""
    df = pd.DataFrame({
        'close': [100, 102, 104, 106, 108] * 6,
        'adj_close': [100, 101, 103, 105, 107] * 6,
        'volume': [1000] * 30
    })
    
    rsi_close = calculate_rsi(df, price_col='close')
    rsi_adj = calculate_rsi(df, price_col='adj_close')
    
    # Should be different due to different prices
    assert not all(rsi_close == rsi_adj)
    assert len(rsi_close) == 30


def test_calculate_rsi_uptrend_produces_high_rsi():
    """Test that consistent uptrend produces RSI > 70"""
    # Strong uptrend: +5% per bar for 25 bars
    prices = [100]
    for _ in range(25):
        prices.append(prices[-1] * 1.05)
    
    df = create_test_dataframe(prices)
    rsi = calculate_rsi(df, period=14)
    
    # After 20 bars of uptrend, RSI should be overbought
    assert rsi.iloc[-1] > 70


def test_calculate_rsi_downtrend_produces_low_rsi():
    """Test that consistent downtrend produces RSI < 30"""
    # Strong downtrend: -5% per bar for 25 bars
    prices = [200]
    for _ in range(25):
        prices.append(prices[-1] * 0.95)
    
    df = create_test_dataframe(prices)
    rsi = calculate_rsi(df, period=14)
    
    # After 20 bars of downtrend, RSI should be oversold
    assert rsi.iloc[-1] < 30


# =============================================================================
# Category 2: calculate_rsi - Wilder's Smoothing (3 tests)
# =============================================================================

def test_calculate_rsi_uses_wilders_smoothing():
    """Test that RSI uses Wilder's smoothing (not simple average)"""
    # Create data with one spike
    prices = [100] * 10 + [110] + [100] * 20
    df = create_test_dataframe(prices)
    
    rsi = calculate_rsi(df, period=14)
    
    # With Wilder's smoothing, the spike effect should decay gradually
    # After spike at idx 10, RSI should be > 50 for several bars (smoothed effect)
    # Note: First 14 values are 50.0, so check after that
    spike_idx = 10
    # Check bars after the initial period (14+) where calculation happens
    assert rsi.iloc[16] >= 50  # A few bars after spike, still some effect


def test_calculate_rsi_smoothing_convergence():
    """Test that RSI smoothing converges after initial period"""
    prices = [100 + i for i in range(50)]  # Gradual uptrend
    df = create_test_dataframe(prices)
    
    rsi = calculate_rsi(df, period=14)
    
    # After initial period, RSI should stabilize (not jump around)
    rsi_stable = rsi.iloc[20:30]
    rsi_changes = abs(rsi_stable.diff().dropna())
    
    # Changes should be relatively small (smoothed)
    assert rsi_changes.mean() < 5.0  # Less than 5 points per bar on average


def test_calculate_rsi_first_values_are_neutral():
    """Test that first values before period are neutral (50.0)"""
    df = create_uptrend_data(bars=30)
    rsi = calculate_rsi(df, period=14)
    
    # First 14 values should be 50.0 (neutral)
    assert all(rsi.iloc[:14] == 50.0)


# =============================================================================
# Category 3: calculate_rsi - Edge Cases (6 tests)
# =============================================================================

def test_calculate_rsi_insufficient_data():
    """Test RSI with data length < period + 1"""
    df = create_test_dataframe([100, 102, 104, 106, 108])  # Only 5 bars
    rsi = calculate_rsi(df, period=14)  # Period 14
    
    # Should return all neutral (50.0)
    assert len(rsi) == 5
    assert all(rsi == 50.0)


def test_calculate_rsi_exact_period_length():
    """Test RSI with data length exactly = period + 1"""
    df = create_test_dataframe([100 + i for i in range(15)])  # Exactly 15 bars
    rsi = calculate_rsi(df, period=14)
    
    assert len(rsi) == 15
    # First 14 should be 50.0
    assert all(rsi.iloc[:14] == 50.0)
    # Last value should be calculated (uptrend, but only 1 bar after period)
    # With just 1 bar of data after initial period, RSI might still be near 50
    assert rsi.iloc[-1] >= 50  # At least not negative (uptrend)


def test_calculate_rsi_all_gains_no_losses():
    """Test RSI when price only goes up (all gains, no losses)"""
    prices = [100 + i * 5 for i in range(30)]  # Consistent gains
    df = create_test_dataframe(prices)
    
    rsi = calculate_rsi(df, period=14)
    
    # All gains → RSI should approach 100
    assert rsi.iloc[-1] > 95


def test_calculate_rsi_all_losses_no_gains():
    """Test RSI when price only goes down (all losses, no gains)"""
    prices = [200 - i * 5 for i in range(30)]  # Consistent losses
    df = create_test_dataframe(prices)
    
    rsi = calculate_rsi(df, period=14)
    
    # All losses → RSI should approach 0
    assert rsi.iloc[-1] < 5


def test_calculate_rsi_zero_volatility():
    """Test RSI with zero price changes (flat prices)"""
    df = create_test_dataframe([100] * 30)  # No price changes
    rsi = calculate_rsi(df, period=14)
    
    # No changes → no gains/losses → RSI should be neutral
    # First period values are 50.0, then calculated values
    # With zero avg_loss, RSI = 100.0 (division by zero protection)
    assert all((rsi == 50.0) | (rsi == 100.0))


def test_calculate_rsi_single_bar():
    """Test RSI with single bar (minimum data)"""
    df = create_test_dataframe([100])
    rsi = calculate_rsi(df, period=14)
    
    assert len(rsi) == 1
    assert rsi.iloc[0] == 50.0


# =============================================================================
# Category 4: get_rsi_signal - Threshold Logic (5 tests)
# =============================================================================

def test_get_rsi_signal_oversold():
    """Test OVERSOLD signal for RSI <= 30"""
    assert get_rsi_signal(25.0) == 'OVERSOLD'
    assert get_rsi_signal(30.0) == 'OVERSOLD'  # Boundary
    assert get_rsi_signal(10.0) == 'OVERSOLD'


def test_get_rsi_signal_overbought():
    """Test OVERBOUGHT signal for RSI >= 70"""
    assert get_rsi_signal(75.0) == 'OVERBOUGHT'
    assert get_rsi_signal(70.0) == 'OVERBOUGHT'  # Boundary
    assert get_rsi_signal(90.0) == 'OVERBOUGHT'


def test_get_rsi_signal_neutral():
    """Test NEUTRAL signal for 30 < RSI < 70"""
    assert get_rsi_signal(50.0) == 'NEUTRAL'
    assert get_rsi_signal(40.0) == 'NEUTRAL'
    assert get_rsi_signal(60.0) == 'NEUTRAL'
    assert get_rsi_signal(30.1) == 'NEUTRAL'
    assert get_rsi_signal(69.9) == 'NEUTRAL'


def test_get_rsi_signal_custom_thresholds():
    """Test custom oversold/overbought thresholds"""
    # Custom thresholds: oversold=20, overbought=80
    assert get_rsi_signal(15.0, oversold=20, overbought=80) == 'OVERSOLD'
    assert get_rsi_signal(25.0, oversold=20, overbought=80) == 'NEUTRAL'
    assert get_rsi_signal(75.0, oversold=20, overbought=80) == 'NEUTRAL'
    assert get_rsi_signal(85.0, oversold=20, overbought=80) == 'OVERBOUGHT'


def test_get_rsi_signal_extreme_values():
    """Test signals at extreme RSI values (0 and 100)"""
    assert get_rsi_signal(0.0) == 'OVERSOLD'
    assert get_rsi_signal(100.0) == 'OVERBOUGHT'


# =============================================================================
# Category 5: Integration Tests (3 tests)
# =============================================================================

def test_rsi_integration_with_real_pattern():
    """Integration test: RSI behavior through price pattern"""
    # Pattern: uptrend → consolidation → downtrend
    uptrend = [100 + i * 2 for i in range(20)]
    # Use np.random.seed for reproducibility
    np.random.seed(42)
    consolidation = [140 + np.random.randn() * 2 for _ in range(10)]  # Small noise
    downtrend = [140 - i * 2 for i in range(20)]
    
    prices = uptrend + consolidation + downtrend
    df = create_test_dataframe(prices)
    
    rsi = calculate_rsi(df, period=14)
    
    # Uptrend section should have high RSI
    assert rsi.iloc[18:20].mean() > 60
    
    # Consolidation: check that it's not extreme (but may still be elevated from uptrend)
    # Wilder's smoothing means effect carries over
    consolidation_rsi = rsi.iloc[25:30].mean()
    assert consolidation_rsi > 0  # Just verify it's calculated
    
    # Downtrend should have low RSI
    assert rsi.iloc[-5:].mean() < 40


def test_rsi_with_signal_generation():
    """Integration test: calculate RSI and generate signals"""
    # Create data with known oversold/overbought periods
    prices = (
        [100 - i * 3 for i in range(20)] +  # Downtrend (oversold)
        [40 + i * 3 for i in range(20)]      # Uptrend (overbought)
    )
    
    df = create_test_dataframe(prices)
    rsi = calculate_rsi(df, period=14)
    
    # Check signals at key points
    oversold_signal = get_rsi_signal(rsi.iloc[18])
    overbought_signal = get_rsi_signal(rsi.iloc[-2])
    
    assert oversold_signal == 'OVERSOLD'
    assert overbought_signal == 'OVERBOUGHT'


def test_rsi_multiple_periods_comparison():
    """Integration test: compare RSI with different periods"""
    df = create_uptrend_data(bars=50, increment=1)
    
    rsi_14 = calculate_rsi(df, period=14)
    rsi_7 = calculate_rsi(df, period=7)
    rsi_21 = calculate_rsi(df, period=21)
    
    # Shorter period (7) should be more responsive (higher in uptrend)
    assert rsi_7.iloc[-1] >= rsi_14.iloc[-1]
    
    # Longer period (21) should be smoother (less extreme)
    assert rsi_21.iloc[-1] <= rsi_14.iloc[-1]
    
    # All should indicate uptrend (RSI > 50)
    assert rsi_7.iloc[-1] > 50
    assert rsi_14.iloc[-1] > 50
    assert rsi_21.iloc[-1] > 50


# =============================================================================
# Category 6: Numerical Accuracy (2 tests)
# =============================================================================

def test_rsi_calculation_formula_accuracy():
    """Test RSI calculation formula matches expected values"""
    # Known data with hand-calculated RSI
    # Simple 3-gain, 3-loss pattern
    prices = [100, 101, 102, 103, 102, 101, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109]
    df = create_test_dataframe(prices)
    
    rsi = calculate_rsi(df, period=14)
    
    # After initial period, RSI should be calculated
    # Mostly gains → RSI should be high
    assert rsi.iloc[-1] > 65


def test_rsi_wilder_smoothing_accuracy():
    """Test Wilder's smoothing formula implementation"""
    # Create data where we can verify smoothing
    # Mix of gains and losses to avoid RSI=100
    prices = [100] * 20 + [101, 102, 101.5, 103, 104]  # Flat then mixed changes
    df = create_test_dataframe(prices)
    
    rsi = calculate_rsi(df, period=14)
    
    # First 14 should be neutral
    assert all(rsi.iloc[:14] == 50.0)
    
    # After price changes start, RSI should be calculated
    # Check that RSI responds to price changes
    assert rsi.iloc[21] != 50.0  # Not neutral anymore
    assert 0 <= rsi.iloc[-1] <= 100  # Valid range


# =============================================================================
# Performance Markers
# =============================================================================

@pytest.mark.parametrize("data_size", [100, 500, 1000])
def test_rsi_performance_with_large_datasets(data_size):
    """Test RSI calculation performance with varying data sizes"""
    prices = [100 + i * 0.1 for i in range(data_size)]
    df = create_test_dataframe(prices)
    
    rsi = calculate_rsi(df, period=14)
    
    assert len(rsi) == data_size
    assert all(rsi >= 0) and all(rsi <= 100)
