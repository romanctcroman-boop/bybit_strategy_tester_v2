# Производительность, точность и универсальный движок бэктестера и оптимизаторов

**Дата:** 2026-01-28  
**Тип:** Размышления / Спецификация направления  
**Контекст:** На бэктестер и оптимизаторы ложится большое количество вычислений; нужна высокая производительность без потери точности и максимально универсальный движок.

---

## 1. Исходное противоречие

- **Производительность:** оптимизации 10K–100K+ комбинаций, мульти-ТФ, мульти-период, walk-forward, агентские циклы — объём вычислений растёт.
- **Точность:** «нельзя убить точность» — intrabar SL/TP, equity-based sizing, запрет quick reversals, 147+ метрик, паритет с TradingView.
- **Универсальность:** один движок (или минимум раздвоений), покрывающий DCA, Grid, RSI, MACD, pyramiding, Multi-TP, ATR, Trailing, MTF, Bar Magnifier и т.д.

Сейчас эти три цели **не сходятся в одном движке**: быстрые (Numba, GPU) не поддерживают полный набор фич; полный (Fallback V4) — 1x и тормозит массовые прогоны.

### 1.1 Двухэтапный поток: эталон → оптимизация

- **Этап 1 — эталонные вычисления (старт и уточнение):**  
  Fallback V2 или V4 — для первичного бэктеста, отладки логики, калибровки, сверки с TradingView. Цель: **надёжный результат** и ясность, что именно оптимизировать. Эталон не меняется; по нему верифицируют все быстрые движки.

- **Этап 2 — оптимизация:**  
  Здесь нужны **и точность, и скорость**. Массовый перебор (10K–100K+ комбинаций, мульти-ТФ, walk-forward) не должен жертвовать точностью: быстрый движок (Numba, GPU) обязан давать **паритет с эталоном** по сделкам и метрикам. Иначе оптимизация отбирает «лучшее» по искажённым числам.

Итог: **эталон для старта и уточнения — правильно; оптимизация требует точности и скорости одновременно** — быстрые реализации существуют только как ускоренные варианты того же контракта, что и эталон.

---

## 2. Текущее состояние: движки и оптимизаторы

### 2.1 Движки (`backend/backtesting/engines/`)

| Движок           | Скорость | Точность | Bar Magnifier | Pyramiding | Multi-TP | ATR SL/TP | Trailing | DCA/совместимость |
|------------------|----------|----------|:-------------:|:----------:|:--------:|:---------:|:--------:|:-----------------:|
| **FallbackEngineV2** | 1x       | 100%     |       ✅      |     ❌     |    ❌    |    ❌     |    ❌    |        ❌         |
| **FallbackEngineV3** | 1x       | 100%     |       ✅      |     ✅     |    ❌    |    ❌     |    ❌    |       частично    |
| **FallbackEngineV4** | 1x       | 100%     |       ✅      |     ✅     |    ✅    |    ✅     |    ✅    |        ✅         |
| **NumbaEngineV2**    | ~41x     | 100%*    |       ✅      |     ❌     |    ❌    |    ❌     |    ❌    |        ❌         |
| **GPUEngineV2**      | 10–50x   | 100%*    |       ✅      |     ❌     |    ❌    |    ❌     |    ❌    |        ❌         |

\* 100% паритет с **V2**, не с V4.

Итог:  
- **Полный набор фич (DCA, Grid, Multi-TP, ATR, Trailing)** — только **Fallback V4**, скорость 1x.  
- **Ускорение 10–50x** — только для подмножества V2 (базовые SL/TP, Bar Magnifier, без pyramiding / multi-TP / ATR / trailing).

### 2.2 Оптимизаторы

| Оптимизатор          | Движок / логика         | Стратегии      | Производительность        |
|----------------------|-------------------------|----------------|---------------------------|
| **fast_optimizer**   | Свой Numba (не NumbaEngineV2) | Только RSI     | 1K–100K комбинаций, цели &lt;30 c на 100K |
| **gpu_optimizer**    | CuPy, свой RSI-контур   | Только RSI     | 100K–10M комбинаций       |
| **optimizations** API| `get_engine(engine_type)` | Любая по движкам | Зависит от движка: Numba/GPU — быстрее, Fallback — 1x |
| **MTFOptimizer**     | FallbackEngineV4        | RSI + MTF      | Нет JIT/GPU, ~1x          |
| **WalkForwardOptimizer** | Вызов движка (Fallback и т.п.) | Любая         | N окон × (оптимизация + OOS) |
| **Bayesian (Optuna)**| `engine.run_backtest()` | Любая          | Зависит от движка         |

Итог:  
- **Быстрые массовые оптимизации** — только для **узкого** класса (RSI-сетка в `fast_optimizer` / `gpu_optimizer`).  
- DCA, Grid, Multi-TP, ATR, Trailing, MTF — только через Fallback V3/V4, то есть **без** 10–50x.

### 2.3 Universal Math Engine (`universal_engine/`)

- Отдельный модуль: свой `core`, `trade_executor`, `optimizer`, сигналы, фильтры, `gpu_acceleration`, ML/RL и т.д.
- Заявлено 100%+ покрытие 167+ параметров из `BacktestInput` и AI/ML.
- **Вопрос интеграции:** используется ли в основных `backtests` / `optimizations` API или живёт параллельно — нужно уточнять. Если параллельно — это ещё один «движок» с другим контрактом и своими рисками расхождений по метрикам.

---

## 3. Почему «универсальный быстрый» движок сложен

### 3.1 Что даёт скорость в Numba/GPU

- **Numba:** `@njit`, `prange`, только «numpy-подобные» структуры, минимум Python-объектов в hot path. Типичный паттерн: один bar-loop, один объём позиции, один SL/один TP, предвычисленные индикаторы (в т.ч. ATR).
- **GPU (CuPy/CUDA):** данные параллельны по «внешнему» измерению (много комбинаций, много символов, много баров). Внутри одного бэктеста цикл по барам по сути **последовательный** (equity, размер позиции, выходы зависят от предыдущих баров).

Оба подхода хорошо совместимы с **упрощённой** моделью: один вход/один выход на бар, фиксированные SL/TP.

### 3.2 Что усложняет перенос V4 в Numba/GPU

- **Pyramiding:** несколько входов в одну сторону, средневзвешенная цена, FIFO/LIFO/ALL при закрытии. Нужны массивы «суб-позиций» (цены, размеры, время) и логика обновления. В Numba — через предвыделенные массивы и счётчики; в GPU — либо тот же массив на поток, либо сложная синхронизация.
- **Multi-TP:** до четырёх уровней TP с разными долями; частичное закрытие, оставшийся объём. Состояние: какие уровни уже сработали, какие цены. Реализуемо в Numba массивами фиксированного размера.
- **ATR SL/TP:** SL/TP зависят от `atr[i]` и множителей. Это не усложняет саму модель — ATR можно передать как массив; сложность в том, что сейчас эта ветка есть только в V4.
- **Trailing Stop:** нужно хранить «наивысший/наинизший» с момента входа и признак активации. Ещё один слой state, но конечный и укладывается в массивы.
- **DCA (Safety Orders):** дополнительные входы по мере просадки, свои размеры и шаги. Много параметров и веток, но при фиксированном максимальном числе ордеров — тоже массивы и счётчики.

Общая мысль: **сложность не в математике, а в переносе stateful-логики в «беспоясные» Numba/GPU-ядрa** (никаких `list`, `dict`, `dataclass` в hot path, только `numpy`/`cupy` и примитивы).

### 3.3 Bar Magnifier

- Уже реализован в Numba и GPU: подбаровая проверка SL/TP по 1m. Доп. объём вычислений, но архитектурно не мешает «универсальности».

### 3.4 Верификация и поддержка двух истин

- Сейчас **эталон — Fallback (V2/V3/V4)**. Любой быстрый движок обязан давать **паритет** по выбранному эталону (V2 или V4).
- Универсальный быстрый движок должен либо:
  - целиком повторить контракт V4 и пройти те же тесты, что и V4,  
  - либо явно ограничить подмножество (как сейчас Numba V2 = V2-only) и не претендовать на «полную» универсальность.

---

## 4. Направления к «универсальному» быстрому движку

### 4.1 Расширение Numba: от V2 к «Numba V4» (инкремент)

Идея: пошагово переносить фичи V4 в Numba, сохраняя паритет с Fallback на каждом шаге.

- **Шаг 1 — Pyramiding (Numba V3):**  
  - В `_simulate_*_numba`: `max_entries`, массивы `entry_price[]`, `entry_size[]`, `entry_bar[]`, счётчик `n_entries`.  
  - Закрытие по FIFO/LIFO/ALL — индексы в этих массивах.  
  - Сравнение с `FallbackEngineV3` по тем же `BacktestInput`.  
  - Ожидаемо: 15–30x к Fallback (хуже, чем «один вход» из-за веток и доп. массивов).

- **Шаг 2 — ATR SL/TP:**  
  - Доп. аргументы: `atr: np.ndarray`, `atr_tp_mult`, `atr_sl_mult`, флаг `use_atr`.  
  - В bar-loop: `sl = entry - atr[i]*atr_sl_mult` (long) и т.п.  
  - Сравнение с V4 на сценариях с `sl_mode=ATR` / `tp_mode=ATR`.

- **Шаг 3 — Multi-TP:**  
  - Фиксированные 4 уровня: `tp_prices[4]`, `tp_portions[4]`, `tp_hit[4]` на «позицию».  
  - При pyramiding — на каждую суб-позицию или на агрегат (как в V4 — надо точно повторить семантику).  
  - Частичное закрытие: уменьшение `size`, пересчёт `equity`, обновление `tp_hit`.  
  - Сравнение с V4 на сценариях `tp_mode=MULTI`.

- **Шаг 4 — Trailing:**  
  - Массивы `trail_activated[]`, `trail_best[]`, `trail_stop[]` (или один набор на «позицию» при одном входе).  
  - Обновление в bar-loop по High/Low; при срабатывании — `exit_reason=TRAILING_STOP`.  
  - Сравнение с V4.

- **Шаг 5 — DCA-совместимость:**  
  - Если DCA в V4 реализован через те же механизмы pyramiding + особые правила входа — часть уже в Numba V3.  
  - Специфичные Safety Order — отдельные параметры и ветки в сигналах/входе; ядро симуляции может оставаться общим.

Плюсы: повторное использование `BacktestInput`/`BacktestOutput`, общая среда тестов, пошаговая верификация.  
Минусы: трудоёмко, каждое расширение усложняет `@njit`-функцию и может снижать ускорение.

### 4.2 Вынесение «вариантов» в конфиг и ветки

Сделать один Numba-контур с флагами:

- `has_pyramiding`, `max_entries`  
- `has_multi_tp`, `n_tp_levels`  
- `has_atr_sltp`  
- `has_trailing`  

Внутри — `if has_pyramiding: ... else: ...`. Numba такие ветки по скалярам хорошо сворачивает. Недоступные комбинации либо отключены, либо падают при `get_engine` с ясной ошибкой.  
Цель — **один** универсальный Numba-движок вместо трёх (V2, V3, V4) в Python; Fallback V2/V3/V4 остаются эталоном для тестов.

### 4.3 GPU: «один поток — один бэктест»

- **Модель:** один CUDA-поток (или warp) = один полный бэктест (одна комбинация параметров или один символ).  
- Внутри потока — последовательный bar-loop с той же логикой, что и в Numba (pyramiding, multi-TP, ATR, trailing как массивы и счётчики).  
- Параллелизм — по **комбинациям** (десятки/сотни тысяч потоков), а не по барам одной кривой.

Сложности:  
- Объём state на поток (копии `entry_*`, `tp_*`, `trail_*`) и лимит регистров/локальной памяти.  
- Длина кода и отладка.  
- Полезно только если комбинаций много (10K+), иначе запуск ядра и копирование данных съедают выигрыш.

Имеет смысл после появления **Numba V4**: GPU-ядро можно генерировать по той же спецификации (входы/выходы/ state), чтобы не дублировать логику дважды.

### 4.4 Cython / Rust как единое ядро

- **Идея:** один «core» на Cython или Rust, который реализует полный контракт V4 (bar-loop, pyramiding, multi-TP, ATR, trailing, Bar Magnifier).  
- Экспорт в Python через `*.pyd` / `maturin`/`pyo3`.  
- Ожидаемо: 5–15x к чистому Python при переносе без упрощений.

Плюсы: полный контроль, меньше ограничений, чем у `@njit`; одна кодовая база на C/Rust вместо «Python V4 + Numba V4».  
Минусы: отдельный стек (Cython/Rust), сборка, поддержка; нужна дисциплина, чтобы не разъехаться с Fallback (здесь Fallback может быть постепенно выведен и заменён на C/Rust как единственный эталон, либо остаться «референс на Python» для отладки).

### 4.5 Двухфазная схема (быстрый отсев + точная перепроверка)

Для **оптимизации** нужны точность и скорость. Вариант: быстрый отсев (скорость) + пересчёт топ-кандидатов на эталоне (точность).

- **Фаза 1 — быстрый отсев:**  
  - Упрощённая модель: один TP, один SL, без pyramiding, без trailing (или с сильным упрощением).  
  - Numba/GPU, 10–50x.  
  - Цель: от 100K комбинаций оставить, например, 100–500 «кандидатов» по Sharpe/return.  
- **Фаза 2 — точная:**  
  - Только эти 100–500 прогонять на **Fallback V4** (или на будущем «Numba V4») с полными фичами.  
  - Итоговый рейтинг и выбор — **только по фазе 2** (точность эталона).

Риск: в фазе 1 можно отсеять комбинации, которые хороши именно за счёт pyramiding / multi-TP / trailing.  
Снижение риска:  
- явно помечать сценарии «только basic» и не использовать двухфазную схему для DCA/Grid и т.п.;  
- либо вводить «упрощённый, но pyramiding-aware» быстрый контур (если решимся его делать) и тогда применять двухфазную схему и к ним.

### 4.6 Унификация с Universal Math Engine

- **Вариант A:** Universal Math Engine становится **единственным** движком: в него переносится вся семантика V4, паритет с текущим Fallback верифицируется, а `engines/` (V2–V4, Numba, GPU) поэтапно выводятся.  
- **Вариант B:** Universal — «полигон» для новых фич и стратегий; для метрик и паритета остаётся `engines/` (Fallback V4, Numba, GPU).  
- **Вариант C:** Унификация на уровне **контракта** (`BacktestInput`/`BacktestOutput`) и **тестов**: Universal и `engines/` должны проходить одни и те же паритет-тесты; реализация может отличаться.

Без чёткого выбора A/B/C и без общих тестов на паритет — Universal остаётся отдельным «вторым миром» с риском расхождений и двойной поддержки.

---

## 5. Что не хватает в проекте (сводка)

### 5.1 По движкам

- **Быстрый движок с полным набором фич V4:** Numba и GPU сегодня = только V2. Нет «Numba V4» / «GPU V4».
- **Один универсальный контур с флагами:** вместо трёх Fallback (V2, V3, V4) можно иметь один с `has_pyramiding` / `has_multi_tp` / `has_atr` / `has_trailing`; сейчас логика размазана по трём файлам.
- **Чёткая роль Universal Math Engine:** используется ли в `backtests`/`optimizations`, как сверять с Fallback, кто эталон для 167+ параметров.

### 5.2 По оптимизаторам

- **Быстрый оптимизатор не только под RSI:** `fast_optimizer` и `gpu_optimizer` заточены под RSI (period, overbought, oversold, sl, tp). DCA, Grid, MACD, Multi-TP, ATR — либо через общий `get_engine` (и тогда упёрлись в 1x Fallback), либо для них быстрого пути нет.
- **Единый слой параметризации:** общий `ParamSpace` и «стратегия — это конфиг + тип», чтобы один и тот же оптимизатор мог гонять RSI, DCA, Grid, multi-TP и т.д., меняя только конфиг и движок.

### 5.3 По производительности

- **Профилирование и метрики:** где именно время уходит (bar-loop, метрики, загрузка свечей, сериализация), по каждому движку и оптимизатору. Без этого непонятно, что ускорять в первую очередь.
- **Кэш и данные:** `CandleDataCache` в `fast_optimizer` — хороший шаг. Есть ли общий кэш для `optimizations` API и для Numba/GPU движков; как избежать повторной загрузки при walk-forward и мульти-ТФ.
- **Параллелизм по комбинациям:** `prange` в Numba, пул в GPU — уже есть. Нужна ли распараллеливание по **окнам** walk-forward или по **ТФ** в одном запросе — и как это вписать в API.

### 5.4 По точности и регрессиям

- **Регресс-тесты на производительность:** не только «метрики совпадают», но и «время одного прогона не выросло более чем на X%» при изменениях в движках.
- **Эталонные датасеты:** несколько фиксированных `(candles, BacktestInput)` с сохранёнными `BacktestOutput` (метрики, сделки) для автоматических сравнений при любых правках движков.

---

## 6. Рекомендуемые приоритеты

### Краткосрочно (не теряя точность)

1. **Зафиксировать эталон:** для «полных» фич — **Fallback V4**; для «базовых» — **Fallback V2**. Все изменения в Numba/GPU и в Universal проверять против них.
2. **Определить место Universal Math Engine:** либо он входит в основной пайплайн и проходит те же паритет-тесты, либо явно объявить его экспериментальным и не использовать для финальных метрик.
3. **Профилирование:** замерить время (bar-loop, metrics, I/O) для Fallback V4, Numba V2, `fast_optimizer`, `gpu_optimizer` на типовых объёмах (10K баров, 1K/10K комбинаций) и зафиксировать в `docs/` или в коде.

### Среднесрочно (универсальный быстрый движок — оптимизация с точностью и скоростью)

4. **Numba V3 (pyramiding):** добавить в Numba-ядро поддержку `pyramiding>1`, FIFO/LIFO/ALL, средневзвешенную цену; верификация с Fallback V3. Оценка: 15–25x к Fallback. Для оптимизации критично: **точность как у эталона + скорость**.
5. **Пошагово ATR, Multi-TP, Trailing в Numba** по п. 4.1, с тестами паритета к V4 на каждом шаге. Итог: «Numba V4» как быстрый универсальный движок для сценариев, где нужны эти фичи.
6. **Общий контур с флагами:** рефакторинг Fallback V2/V3/V4 в один модуль с `has_pyramiding`, `has_multi_tp` и т.д. — чтобы не плодить новые «V5» и упростить перенос в Numba.

### Долгосрочно

7. **GPU с полным контрактом V4:** после появления Numba V4 — перенос той же логики в CUDA по схеме «один поток = один бэктест», для 10K+ комбинаций.
8. **Расширение быстрых оптимизаторов:** `fast_optimizer` / `gpu_optimizer` или их преемники — поддержка не только RSI, но и, как минимум, MACD, DCA-подобных правил, multi-TP; через общий `BacktestInput` и выбранный движок (Numba V4 / GPU V4).

---

## 7. Итоговая схема «универсальный движок»

Целевая картинка:

- **Один контракт:** `BacktestInput` → `BacktestOutput` (как сейчас).  
- **Один репозиторий правил:** bar-loop, pyramiding, multi-TP, ATR, trailing, Bar Magnifier — одна спецификация (диаграммы, псевдокод, тесты), от которой отталкиваются реализации.  
- **Три реализации одного контракта:**  
  1. **Fallback (Python)** — эталон для старта и уточнения; отладка, максимальная прозрачность.  
  2. **Numba** — ускорение 15–40x при полном наборе фич (после Numba V4); для **оптимизации: точность + скорость**.  
  3. **GPU** — ускорение для массовых оптимизаций 10K+ при том же контракте; точность через паритет с эталоном.  
- **Один селектор:** `get_engine(..., need_pyramiding=, need_multi_tp=, need_atr=, ...)` — сам решает: Fallback / Numba / GPU в зависимости от фич и наличия библиотек.  
- **Оптимизаторы** (в т.ч. `fast_optimizer`, `gpu_optimizer`, `optimizations`) — по возможности работают через этот контракт и `get_engine`, а не через собственные зашитые «RSI- only» контуры (или явно документируют ограничение).

Тогда «максимально универсальный движок» — это не один файл, а **один контракт + одна спецификация + несколько реализаций с разным trade-off по скорости и зависимостям (Numba/CUDA)**, при жёстком сохранении точности через паритет с эталоном.

---

## 8. Роль Universal Math Engine — факт и варианты

### 8.1 Текущее положение

- **Основной пайплайн** (`backtests`, `optimizations`) использует только `engine_selector.get_engine()` → Fallback V2/V3/V4, Numba V2, GPU V2. **Universal Math Engine в него не встроен.**
- **universal_engine** живёт отдельно: тесты (`test_universal_engine*.py`, `test_v24_features.py`), примеры, adhoc-скрипты. API: `UniversalMathEngine.run(candles, strategy_type, strategy_params, ...)` → `EngineOutput` с `EngineMetrics` — **не** `BacktestInput`/`BacktestOutput` и не 147/166 метрик.
- **Что в universal_engine уже есть и близко к «универсальности»:**
  - **trade_executor:** `ExecutorConfig` с `tp_mode` (FIXED/ATR/MULTI), `sl_mode` (FIXED/ATR), `tp_levels`/`tp_portions`, `trailing_stop_*`, `breakeven_*`, `use_bar_magnifier` — концептуально совпадает с контрактом V4.
  - **gpu_acceleration:** `GPUBackend`, `BatchBacktester`, `VectorizedIndicators`, `GPUOptimizer` — свой GPU-слой, не общий с `gpu_engine_v2` и `gpu_optimizer`.
  - **signal_generator:** RSI, MACD, Bollinger, Stochastic, MA Crossover, SuperTrend; `calculate_rsi_numba` уже переиспользуется в `test_dca_comprehensive`, `test_engine_comprehensive`.
  - **filter_engine, position_manager, risk_manager** — своя модель, не `BacktestInput`.

Итог: universal_engine — **второй контур** с богатым функционалом, но другим контрактом и без паритет-тестов к Fallback.

### 8.2 Варианты места Universal

- **A. Единственный движок:** перенос семантики V4 в universal_engine, маппинг `BacktestInput`→`ExecutorConfig` и т.п., расчёт 147+ метрик через `metrics_calculator`; `engines/` (V2–V4, Numba, GPU) со временем выводятся. Риск: большой объём работы, нужно сохранить паритет по сделкам и метрикам.
- **B. Полигон:** Universal — для экспериментов (RL, опционы, Multi-Exchange, sentiment); для «продакшен»-метрик и паритета остаются `engines/`. Минимум изменений, но дублирование идей (multi-TP, ATR, trailing — и в V4, и в trade_executor).
- **C. Унификация по контракту:** Universal и `engines/` реализуют **один и тот же контракт** `BacktestInput` → `BacktestOutput` (в т.ч. 147+ метрик). В Universal добавляется адаптер `BacktestInput` → `ExecutorConfig` и т.д., а `EngineOutput` → `BacktestOutput`. Один набор паритет-тестов на все реализации. Реализация может отличаться (Python vs Numba vs CuPy), семантика — одна.

Рекомендация из §5–6 сохраняется: **сначала явно выбрать A, B или C**, иначе Universal остаётся «вторым миром» с риском расхождений.

---

## 9. «Максимальная универсальность»: один контракт vs один код

### 9.1 Два смысла «универсальный»

1. **Универсальный по возможностям (scope):** один движок покрывает всё: RSI, MACD, DCA, Grid, pyramiding, Multi-TP, ATR, Trailing, MTF, Bar Magnifier, 147+ метрик. Это достигается **контрактом** (`BacktestInput` с 100+ полями) и **спецификацией** (как обрабатывать каждую комбинацию).
2. **Универсальный по реализации (single codebase):** один и тот же код (один bar-loop, один trade_executor) для всех сценариев — флаги `has_pyramiding`, `has_multi_tp` и т.д. Плюс: меньше расхождений, проще поддержка. Минус: в Numba/GPU «тяжёлые» ветки по редко используемым фичам могут съедать часть ускорения.

Практичный курс: **универсальность по scope — через контракт и спецификацию; универсальность по коду — внутри каждой реализации** (один Fallback с флагами, один Numba с флагами). Не обязательно один общий код на Python and Numba.

### 9.2 Когда двухфазная схема (быстрый отсев + V4) допустима

- **Допустима:** сценарии **только basic** (один SL, один TP, pyramiding=1, без ATR/trailing/multi-TP). Быстрый Numba/GPU даёт топ-100–500, пересчёт на V4 — финальный рейтинг. Риск отсеять «хорошие за счёт pyramiding/multi-TP» отсутствует по построению.
- **Рискованна:** DCA, Grid, multi-TP, ATR, trailing. Упрощённая модель в фазе 1 может отсеять комбинации, которые выигрывают именно за счёт этих механизмов.
- **Смягчение:** если появится «Numba V3» (pyramiding) или «Numba V4» (полный набор), двухфазную схему можно применять и к ним: фаза 1 — Numba V4 на подмножестве комбинаций (или быстрее GPU V4), фаза 2 — Fallback V4 только для аудита/верификации по выборочным комбинациям.

### 9.3 Точность vs производительность: где не жертвовать

- **Intrabar (Bar Magnifier):** порядок проверки SL/TP внутри бара, цена выхода — должны совпадать с эталоном. Иначе расхождения в сделках и в производных метриках.
- **Комиссия 0.07%:** для TradingView parity — обязательно; иначе все сравнительные тесты теряют смысл.
- **Метрики 147/166:** расчёт по одной и той же формуле; допуск — численный (например 1e-6 для нормированных, 0.01 для денежных в валюте).
- **Можно варьировать:** способ хранения промежуточных массивов (Python list vs preallocated numpy), место расчёта индикаторов (предварительно в Python vs внутри Numba), стратегия кэширования свечей. Главное — одинаковый **результат** на выходе.

---

## 10. Что переиспользовать из universal_engine

Не обязательно «встраивать весь Universal» в main. Имеет смысл выборочно брать модули и идеи:

| Компонент | Использование |
|-----------|---------------|
| **trade_executor.ExecutorConfig** | Референс полей для multi-TP, ATR, trailing, breakeven. При «общем контуре с флагами» в Fallback — сверить семантику с `UniversalTradeExecutor.process_bar` и с V4, чтобы не дублировать ошибки. |
| **trade_executor (логика)** | Только после формального маппинга `BacktestInput`→`ExecutorConfig` и паритет-тестов к V4. До этого — только как документация желаемого поведения. |
| **gpu_acceleration.BatchBacktester / GPUOptimizer** | Идея «один поток = один бэктест» и батчи по комбинациям. Реализацию лучше строить поверх **того же контракта**, что и Numba V4 (после его появления), а не поверх `UniversalMathEngine.run()`. |
| **signal_generator (RSI, MACD, …)** | `calculate_rsi_numba` уже в проде в тестах. Остальные индикаторы — кандидаты для Numba V3/V4 и для расширения `fast_optimizer` за пределы RSI: считать индикаторы один раз, передавать в bar-loop. |
| **filter_engine, position_manager, risk_manager** | Связь с `BacktestInput` неочевидна (разные модели). Сначала — маппинг полей из `BacktestInput` (mtf_*, фильтры, position_size, risk) в эти модули; без него подключение в main даст другой результат и нарушит паритет. |

Итого: **универсальный движок в смысле §7** — это контракт + спецификация + реализации (Fallback, Numba, GPU). Universal Math Engine может либо **стать одной из реализаций** (вариант A или C из §8), либо **поставлять только отдельные куски** (сигналы, идеи GPU-батчинга, референс семантики trade_executor) в основной стек, с явными тестами на паритет.

---

## 11. ПРИНЯТОЕ РЕШЕНИЕ: Консолидация до 2 движков

**Дата:** 2026-01-28  
**Статус:** Утверждено

### 11.1 Проблема: слишком много движков

Текущее состояние — 8 подсистем с разным функционалом:

| # | Компонент | Фичи | Проблема |
|---|-----------|------|----------|
| 1 | FallbackEngineV2 | Базовый | Дублирование |
| 2 | FallbackEngineV3 | + pyramiding | Дублирование |
| 3 | FallbackEngineV4 | + multi-TP, ATR, trailing, DCA | Эталон, но 1x |
| 4 | NumbaEngineV2 | Только V2 | Не покрывает V4 |
| 5 | GPUEngineV2 | Только V2 | Не покрывает V4, требует NVIDIA |
| 6 | Universal Math Engine | Свой контракт | Отдельный «мир» |
| 7 | fast_optimizer | RSI-only Numba | Узкий |
| 8 | gpu_optimizer | RSI-only CuPy | Узкий, требует NVIDIA |

**Итог:** путаница, двойная работа, риск расхождений, сложность поддержки.

### 11.2 Решение: 2 движка вместо 8

| Движок | Роль | Фичи |
|--------|------|------|
| **FallbackEngine** | Эталон: старт, отладка, уточнение, верификация | Все (V4) |
| **NumbaEngine** | Оптимизация: точность + скорость | Все (V4) — **расширить** |

**GPU — откладываем или не делаем.**

### 11.3 Обоснование

1. **Numba проще и доступнее:**
   - Установка: `pip install numba`
   - Отладка: можно print, pdb
   - Работает на любом CPU

2. **Для 90% задач Numba достаточен:**
   - До 30K комбинаций — секунды/минуты
   - Walk-forward, мульти-ТФ — укладываемся

3. **GPU даёт выигрыш только на 100K+ комбинаций:**
   - Но требует NVIDIA + CUDA + cupy
   - Сложнее в отладке (async, device memory)
   - Branch divergence на сложных фичах (pyramiding, multi-TP)

4. **Два движка с одинаковым функционалом — двойная работа:**
   - Каждую фичу писать дважды
   - Двойные баги
   - Двойные паритет-тесты

### 11.4 План консолидации

**Фаза 1: Один Fallback с флагами**
- Объединить V2/V3/V4 в один `FallbackEngine`
- Все фичи через флаги из `BacktestInput`
- Удалить V2, V3, V4 как отдельные файлы

**Фаза 2: Numba до V4**
- ✅ NumbaEngine расширен: pyramiding ✓, ATR ✓, multi-TP ✓, trailing ✓
- Паритет-тесты к Fallback на каждом шаге
- Один `NumbaEngine` с теми же флагами

**Фаза 3: Упорядочить оптимизаторы**
- `fast_optimizer` → использует NumbaEngine (или пометить как «RSI-only shortcut»)
- `gpu_optimizer` → deprecated / experimental
- Один API оптимизации через `get_engine()`

**Фаза 4: Universal Engine**
- Роль: экспериментальный полигон (RL, опционы, multi-exchange)
- Не путать с основным пайплайном
- Выборочно брать модули (signal_generator, идеи)

### 11.5 Целевая архитектура

```
BacktestInput (контракт, 100+ полей)
        │
        ▼
┌───────────────────────────────────────┐
│           get_engine()                │
│  ┌─────────────┐  ┌─────────────┐     │
│  │  Fallback   │  │   Numba     │     │
│  │  (эталон)   │  │  (быстрый)  │     │
│  │  1x speed   │  │  20-40x     │     │
│  │  все фичи   │  │  все фичи   │     │
│  └─────────────┘  └─────────────┘     │
│         ▲               ▲             │
│         └───────┬───────┘             │
│                 │                     │
│        паритет-тесты (100%)           │
└───────────────────────────────────────┘
        │
        ▼
BacktestOutput (метрики, сделки, equity)
```

### 11.6 Что удаляем / deprecated

| Компонент | Действие | Статус |
|-----------|----------|--------|
| FallbackEngineV2 | Alias → FallbackEngine | ✅ Done |
| FallbackEngineV3 | Alias → FallbackEngine | ✅ Done |
| FallbackEngineV4 | = FallbackEngine | ✅ Done |
| **GPUEngineV2** | **✅ Deprecated** (V2-only) | ✅ Done |
| **fast_optimizer** | **✅ Deprecated** (RSI-only) | ✅ Done |
| **gpu_optimizer** | **✅ Deprecated** (RSI-only) | ✅ Done |
| **optimizer.py (UniversalOptimizer)** | **✅ Deprecated** (wrapper) | ✅ Done |
| Universal Engine | Experimental, не в main pipeline | — |

---

## 12. Следующие шаги

1. ✅ **Консолидация Fallback** — DONE: FallbackEngine = V4, aliases для V2/V3
2. ✅ **Расширение Numba** — DONE: pyramiding ✓, ATR ✓, multi-TP ✓, trailing ✓
3. ✅ **Паритет-тесты** — DONE: 100% паритет NumbaEngineV2 ↔ FallbackEngineV4
4. ✅ **Deprecated RSI-optimizers** — DONE: fast_optimizer, gpu_optimizer, optimizer.py
5. ✅ **Exports** — DONE: FallbackEngine, NumbaEngine из engines/__init__.py

---

## 13. Итоговая архитектура (2026-01-28)

```
┌─────────────────────────────────────────────────────────────────────┐
│                    PRODUCTION ENGINE ARCHITECTURE                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   from backend.backtesting.engines import FallbackEngine, NumbaEngine
│                                                                     │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │  FallbackEngine (= V4) — ЭТАЛОН                             │   │
│   │  - Все фичи: pyramiding, multi-TP, ATR, trailing, DCA       │   │
│   │  - Скорость: 1x                                             │   │
│   │  - Роль: верификация, отладка, эталонные вычисления         │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                              ▲                                      │
│                              │ паритет 100%                         │
│                              ▼                                      │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │  NumbaEngine (= NumbaEngineV2 с V4 фичами)                  │   │
│   │  - Все фичи V4: pyramiding, multi-TP, ATR, trailing, DCA    │   │
│   │  - Скорость: ~20-40x                                        │   │
│   │  - Роль: оптимизация (точность + скорость)                  │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │  DEPRECATED (работают, выдают DeprecationWarning):          │   │
│   │  - FallbackEngineV2, FallbackEngineV3                       │   │
│   │  - fast_optimizer, gpu_optimizer, UniversalOptimizer        │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

*Решение принято 2026-01-28. Консолидация завершена 2026-01-28.*
