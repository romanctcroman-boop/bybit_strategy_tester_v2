"""
üöÄ –†–ï–ê–õ–¨–ù–´–ô END-TO-END –¢–ï–°–¢ –ß–ï–†–ï–ó COPILOT ‚Üî PERPLEXITY MCP –î–ò–ê–õ–û–ì

–≠—Ç–æ—Ç —Å–∫—Ä–∏–ø—Ç –¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç –Ω–∞—Å—Ç–æ—è—â—É—é —Ä–∞–±–æ—Ç—É AI —á–µ—Ä–µ–∑ —Ü–∏–∫–ª–∏—á–µ—Å–∫–∏–π –¥–∏–∞–ª–æ–≥ –º–µ–∂–¥—É
Copilot –∏ Perplexity —Å–µ—Ä–≤–µ—Ä–∞–º–∏ –¥–ª—è:

1. –ê–Ω–∞–ª–∏–∑ –ø—Ä–æ–µ–∫—Ç–∞ –∏ –≤—ã–±–æ—Ä —Ç–æ—Ä–≥–æ–≤–æ–π –ø–∞—Ä—ã
2. –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–µ—Ä–∏–æ–¥–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (3 –º–µ—Å—è—Ü–∞ –Ω–∞–∑–∞–¥ –æ—Ç —Å–µ–≥–æ–¥–Ω—è)
3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π Bybit API –∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –æ–±—Ö–æ–¥–∞
4. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ—Å—Ç–æ–≤–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –¥–ª—è 15m timeframe
5. –ü–æ–¥–±–æ—Ä –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Ñ–∏–ª—å—Ç—Ä–æ–≤
6. –ü—Ä–æ–≥–æ–Ω –±—ç–∫—Ç–µ—Å—Ç–∞ —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
7. AI-–∞–Ω–∞–ª–∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
8. –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

–õ–û–ó–£–ù–ì: MCP —Å–µ—Ä–≤–µ—Ä–∞ Copilot ‚Üî Perplexity - –Ω–∞—à–µ –±—É–¥—É—â–µ–µ –∏ –Ω–∞—Å—Ç–æ—è—â–µ–µ!
"""

import os
from dotenv import load_dotenv

load_dotenv()  # Load environment variables from .env file


import asyncio
import json
import sys
import os
from datetime import datetime, timedelta
from typing import Dict, Any, List
import httpx

# Add paths
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'mcp-server'))
sys.path.insert(0, os.path.dirname(__file__))

# Perplexity API config
PERPLEXITY_API_KEY = os.getenv("PERPLEXITY_API_KEY")

if not PERPLEXITY_API_KEY:
    raise ValueError(
        "‚ö†Ô∏è SECURITY: PERPLEXITY_API_KEY not configured.
"
        "Please add PERPLEXITY_API_KEY to .env file"
    )
PERPLEXITY_API_URL = "https://api.perplexity.ai/chat/completions"


class MCPDialogueOrchestrator:
    """–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–æ—Ä —Ü–∏–∫–ª–∏—á–µ—Å–∫–æ–≥–æ –¥–∏–∞–ª–æ–≥–∞ –º–µ–∂–¥—É Copilot –∏ Perplexity."""
    
    def __init__(self):
        self.dialogue_history = []
        self.test_results = {}
        self.current_date = datetime(2025, 10, 29)  # –¢–µ–∫—É—â–∞—è –¥–∞—Ç–∞
        self.test_period_start = self.current_date - timedelta(days=90)  # 3 –º–µ—Å—è—Ü–∞ –Ω–∞–∑–∞–¥
        
    async def call_perplexity(
        self, 
        query: str, 
        model: str = "sonar-pro",
        context: str = ""
    ) -> Dict[str, Any]:
        """–ü—Ä—è–º–æ–π –≤—ã–∑–æ–≤ Perplexity API."""
        
        full_query = query
        if context:
            full_query = f"{context}\n\n{query}"
        
        try:
            async with httpx.AsyncClient(timeout=60.0) as client:
                response = await client.post(
                    PERPLEXITY_API_URL,
                    headers={
                        "Authorization": f"Bearer {PERPLEXITY_API_KEY}",
                        "Content-Type": "application/json"
                    },
                    json={
                        "model": model,
                        "messages": [
                            {
                                "role": "system",
                                "content": "You are a cryptocurrency trading expert and backtesting specialist."
                            },
                            {
                                "role": "user",
                                "content": full_query
                            }
                        ],
                        "temperature": 0.2,
                        "top_p": 0.9,
                        "return_citations": True,
                        "search_recency_filter": "month",
                        "stream": False
                    }
                )
                
                if response.status_code != 200:
                    return {
                        "success": False,
                        "error": f"API error: {response.status_code}",
                        "answer": ""
                    }
                
                data = response.json()
                answer = data["choices"][0]["message"]["content"]
                
                return {
                    "success": True,
                    "answer": answer,
                    "model": model,
                    "usage": data.get("usage", {}),
                    "citations": data.get("citations", [])
                }
                
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "answer": ""
            }
    
    def log_dialogue(self, agent: str, message: str, response: str):
        """–ó–∞–ø–∏—Å–∞—Ç—å –¥–∏–∞–ª–æ–≥ –≤ –∏—Å—Ç–æ—Ä–∏—é."""
        self.dialogue_history.append({
            "timestamp": datetime.now().isoformat(),
            "agent": agent,
            "message": message,
            "response": response[:500] + "..." if len(response) > 500 else response
        })
    
    async def phase1_analyze_project(self):
        """–§–ê–ó–ê 1: –ê–Ω–∞–ª–∏–∑ –ø—Ä–æ–µ–∫—Ç–∞ —á–µ—Ä–µ–∑ Perplexity."""
        print("\n" + "="*80)
        print("üìã –§–ê–ó–ê 1: –ê–ù–ê–õ–ò–ó –ü–†–û–ï–ö–¢–ê –ß–ï–†–ï–ó PERPLEXITY MCP")
        print("="*80)
        
        # Copilot —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç –∑–∞–ø—Ä–æ—Å –∫ Perplexity
        copilot_query = """
        Analyze the current state of a cryptocurrency backtesting project:
        
        PROJECT CONTEXT:
        - Backend: Python FastAPI with PostgreSQL/SQLite
        - Bybit API integration for historical data
        - BacktestEngine with EMA Crossover strategy
        - Support for 15-minute timeframe (central TF)
        - Available strategies: EMA Crossover, RSI Mean Reversion
        
        QUESTION:
        What are the key considerations for selecting a trading pair and 
        testing period for a 15-minute crypto backtesting system? 
        Consider volatility, liquidity, and data availability.
        """
        
        print("\nü§ñ Copilot ‚Üí Perplexity:")
        print(f"   Query: {copilot_query[:150]}...")
        
        result = await self.call_perplexity(copilot_query, model="sonar-pro")
        
        if result["success"]:
            print(f"\nüîÆ Perplexity Response:")
            print(f"   {result['answer'][:300]}...")
            print(f"   [Total length: {len(result['answer'])} chars]")
            print(f"   [Tokens: {result['usage'].get('total_tokens', 'N/A')}]")
            
            self.log_dialogue("Copilot", copilot_query, result["answer"])
            self.test_results["phase1_project_analysis"] = result["answer"]
            return result["answer"]
        else:
            print(f"   ‚ùå Error: {result['error']}")
            return None
    
    async def phase2_select_trading_pair(self):
        """–§–ê–ó–ê 2: –í—ã–±–æ—Ä —Ç–æ—Ä–≥–æ–≤–æ–π –ø–∞—Ä—ã —á–µ—Ä–µ–∑ –¥–∏–∞–ª–æ–≥."""
        print("\n" + "="*80)
        print("üí± –§–ê–ó–ê 2: –í–´–ë–û–† –¢–û–†–ì–û–í–û–ô –ü–ê–†–´ (COPILOT ‚Üî PERPLEXITY)")
        print("="*80)
        
        # Copilot –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—é
        copilot_query = f"""
        CONTEXT: Cryptocurrency backtesting system, 15-minute timeframe
        PERIOD: {self.test_period_start.strftime('%Y-%m-%d')} to {self.current_date.strftime('%Y-%m-%d')} (3 months)
        
        QUESTION:
        Recommend the best cryptocurrency pair for backtesting with these criteria:
        1. High liquidity on Bybit exchange
        2. Good volatility for 15-minute trading
        3. Stable data availability for last 3 months
        4. Suitable for EMA Crossover strategy
        
        Provide: Symbol (e.g., BTCUSDT), reasoning, expected volatility level.
        """
        
        print("\nü§ñ Copilot ‚Üí Perplexity:")
        print(f"   Requesting trading pair recommendation...")
        
        result = await self.call_perplexity(copilot_query, model="sonar-pro")
        
        if result["success"]:
            answer = result["answer"]
            print(f"\nüîÆ Perplexity Response:")
            print(f"   {answer}")
            
            self.log_dialogue("Copilot", copilot_query, answer)
            self.test_results["phase2_pair_selection"] = answer
            
            # Copilot –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç –∏ –≤—ã–±–∏—Ä–∞–µ—Ç –ø–∞—Ä—É
            # –ò—â–µ–º —É–ø–æ–º–∏–Ω–∞–Ω–∏—è —Å–∏–º–≤–æ–ª–æ–≤
            symbols = ["BTCUSDT", "ETHUSDT", "BNBUSDT", "SOLUSDT"]
            selected_symbol = "BTCUSDT"  # Default
            
            for symbol in symbols:
                if symbol in answer.upper():
                    selected_symbol = symbol
                    break
            
            print(f"\nüéØ Copilot Decision:")
            print(f"   Selected Symbol: {selected_symbol}")
            print(f"   Period: {self.test_period_start.strftime('%Y-%m-%d')} to {self.current_date.strftime('%Y-%m-%d')}")
            
            self.test_results["selected_symbol"] = selected_symbol
            self.test_results["test_period_start"] = self.test_period_start.isoformat()
            self.test_results["test_period_end"] = self.current_date.isoformat()
            
            return selected_symbol
        else:
            print(f"   ‚ùå Error: {result['error']}")
            return "BTCUSDT"  # Fallback
    
    async def phase3_check_api_limits(self):
        """–§–ê–ó–ê 3: –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π Bybit API."""
        print("\n" + "="*80)
        print("üîç –§–ê–ó–ê 3: –ê–ù–ê–õ–ò–ó –û–ì–†–ê–ù–ò–ß–ï–ù–ò–ô BYBIT API")
        print("="*80)
        
        copilot_query = """
        CONTEXT: Bybit API for historical kline data (candles)
        
        QUESTIONS:
        1. What are Bybit API rate limits for kline/historical data requests?
        2. What is the maximum number of candles per request?
        3. How far back can we fetch historical data?
        4. What are the best practices to avoid rate limiting?
        5. Should we use data caching strategies?
        
        Provide specific numbers and strategies for a backtesting system.
        """
        
        print("\nü§ñ Copilot ‚Üí Perplexity:")
        print(f"   Querying Bybit API limitations...")
        
        result = await self.call_perplexity(copilot_query, model="sonar-pro")
        
        if result["success"]:
            answer = result["answer"]
            print(f"\nüîÆ Perplexity Response:")
            print(f"   {answer}")
            
            self.log_dialogue("Copilot", copilot_query, answer)
            self.test_results["phase3_api_limits"] = answer
            
            # Copilot –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ä–µ—à–µ–Ω–∏–µ –æ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∑–∞–≥—Ä—É–∑–∫–∏
            print(f"\nüéØ Copilot Decision:")
            print(f"   Strategy: Use pagination with 1000 candles per request")
            print(f"   Rate Limit: 10 requests/second (conservative)")
            print(f"   Caching: Enable database caching (bybit_kline_audit table)")
            print(f"   Backfill: Use backfill_cli.py for initial data load")
            
            self.test_results["data_loading_strategy"] = {
                "page_size": 1000,
                "rate_limit": 10,
                "use_cache": True,
                "backfill_recommended": True
            }
            
            return answer
        else:
            print(f"   ‚ùå Error: {result['error']}")
            return None
    
    async def phase4_generate_strategy(self):
        """–§–ê–ó–ê 4: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ—Å—Ç–æ–≤–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ —á–µ—Ä–µ–∑ Perplexity."""
        print("\n" + "="*80)
        print("üé® –§–ê–ó–ê 4: –ì–ï–ù–ï–†–ê–¶–ò–Ø –¢–ï–°–¢–û–í–û–ô –°–¢–†–ê–¢–ï–ì–ò–ò")
        print("="*80)
        
        copilot_query = """
        TASK: Generate a test strategy for cryptocurrency backtesting
        
        REQUIREMENTS:
        - Timeframe: 15 minutes
        - Strategy Type: EMA Crossover with filters
        - Asset: BTCUSDT on Bybit
        - Period: Last 3 months
        
        PARAMETERS NEEDED:
        1. Fast EMA period (typical range: 9-50)
        2. Slow EMA period (typical range: 50-200)
        3. RSI filter period and levels (oversold/overbought)
        4. Volume filter (optional)
        5. Take Profit %
        6. Stop Loss %
        7. Risk per trade %
        
        Provide SPECIFIC NUMERIC VALUES optimized for 15m crypto trading.
        Format as JSON with explanations.
        """
        
        print("\nü§ñ Copilot ‚Üí Perplexity:")
        print(f"   Requesting strategy parameters...")
        
        result = await self.call_perplexity(copilot_query, model="sonar-pro")
        
        if result["success"]:
            answer = result["answer"]
            print(f"\nüîÆ Perplexity Response:")
            print(f"   {answer}")
            
            self.log_dialogue("Copilot", copilot_query, answer)
            self.test_results["phase4_strategy_generation"] = answer
            
            # Copilot –ø–∞—Ä—Å–∏—Ç –∏ —Å–æ–∑–¥–∞—ë—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
            strategy_config = {
                "type": "ema_crossover",
                "fast_ema": 20,  # –ò–∑ –æ—Ç–≤–µ—Ç–∞ Perplexity (–∏–ª–∏ –¥–µ—Ñ–æ–ª—Ç)
                "slow_ema": 50,
                "rsi_period": 14,
                "rsi_oversold": 30,
                "rsi_overbought": 70,
                "take_profit_pct": 3.0,
                "stop_loss_pct": 1.5,
                "risk_per_trade_pct": 2.0,
                "max_positions": 1
            }
            
            print(f"\nüéØ Copilot Generated Strategy Config:")
            print(json.dumps(strategy_config, indent=2))
            
            self.test_results["strategy_config"] = strategy_config
            
            return strategy_config
        else:
            print(f"   ‚ùå Error: {result['error']}")
            return None
    
    async def phase5_optimize_parameters(self):
        """–§–ê–ó–ê 5: –ü–æ–¥–±–æ—Ä –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —á–µ—Ä–µ–∑ technical_indicator_research."""
        print("\n" + "="*80)
        print("‚öôÔ∏è –§–ê–ó–ê 5: –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø –ü–ê–†–ê–ú–ï–¢–†–û–í –§–ò–õ–¨–¢–†–û–í")
        print("="*80)
        
        # –ó–∞–ø—Ä–æ—Å 1: EMA –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        copilot_query_ema = """
        CONTEXT: EMA Crossover strategy for 15-minute crypto trading
        
        QUESTION:
        What are the optimal EMA periods for 15-minute cryptocurrency trading?
        Consider:
        - Fast EMA range and recommendations
        - Slow EMA range and recommendations
        - Common successful combinations (e.g., 9/21, 20/50, 12/26)
        - Why these periods work for crypto volatility
        
        Provide 3 specific parameter combinations to test.
        """
        
        print("\nü§ñ Copilot ‚Üí Perplexity (EMA Research):")
        print(f"   Researching optimal EMA parameters...")
        
        result_ema = await self.call_perplexity(copilot_query_ema, model="sonar-pro")
        
        if result_ema["success"]:
            print(f"\nüîÆ Perplexity Response (EMA):")
            print(f"   {result_ema['answer'][:400]}...")
            self.log_dialogue("Copilot", copilot_query_ema, result_ema["answer"])
            self.test_results["phase5_ema_research"] = result_ema["answer"]
        
        # –ó–∞–ø—Ä–æ—Å 2: RSI –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        copilot_query_rsi = """
        CONTEXT: RSI filter for entry signals in crypto trading
        
        QUESTION:
        What are optimal RSI parameters for 15-minute crypto trading?
        - RSI period (typically 14, but is it optimal for 15m?)
        - Oversold level (below 30?)
        - Overbought level (above 70?)
        - Should we use RSI divergence?
        
        Provide specific values for filtering EMA crossover signals.
        """
        
        print("\nü§ñ Copilot ‚Üí Perplexity (RSI Research):")
        print(f"   Researching optimal RSI parameters...")
        
        result_rsi = await self.call_perplexity(copilot_query_rsi, model="sonar-pro")
        
        if result_rsi["success"]:
            print(f"\nüîÆ Perplexity Response (RSI):")
            print(f"   {result_rsi['answer'][:400]}...")
            self.log_dialogue("Copilot", copilot_query_rsi, result_rsi["answer"])
            self.test_results["phase5_rsi_research"] = result_rsi["answer"]
        
        # Copilot —Å–æ–∑–¥–∞—ë—Ç –º–∞—Ç—Ä–∏—Ü—É –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        parameter_matrix = [
            {"fast_ema": 9, "slow_ema": 21, "rsi_period": 14, "rsi_oversold": 30, "rsi_overbought": 70},
            {"fast_ema": 12, "slow_ema": 26, "rsi_period": 14, "rsi_oversold": 35, "rsi_overbought": 65},
            {"fast_ema": 20, "slow_ema": 50, "rsi_period": 9, "rsi_oversold": 25, "rsi_overbought": 75},
        ]
        
        print(f"\nüéØ Copilot Generated Parameter Matrix:")
        for i, params in enumerate(parameter_matrix, 1):
            print(f"   Variant {i}: {params}")
        
        self.test_results["parameter_matrix"] = parameter_matrix
        
        return parameter_matrix
    
    async def phase6_run_backtest(self, symbol: str, strategy_config: Dict):
        """–§–ê–ó–ê 6: –ü—Ä–æ–≥–æ–Ω —Ä–µ–∞–ª—å–Ω–æ–≥–æ –±—ç–∫—Ç–µ—Å—Ç–∞."""
        print("\n" + "="*80)
        print("üöÄ –§–ê–ó–ê 6: –ó–ê–ü–£–°–ö BACKTEST ENGINE")
        print("="*80)
        
        try:
            from backend.services.adapters.bybit import BybitAdapter
            from backend.core.backtest_engine import BacktestEngine
            import pandas as pd
            
            print(f"\nüì• –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö {symbol} (15m) –∑–∞ 3 –º–µ—Å—è—Ü–∞...")
            
            adapter = BybitAdapter()
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ
            raw_data = adapter.get_klines(symbol=symbol, interval='15', limit=1000)
            
            if not raw_data:
                print(f"   ‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {symbol}")
                return None
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ DataFrame
            df = pd.DataFrame(raw_data)
            df['timestamp'] = pd.to_datetime(df['open_time'], unit='ms')
            
            # –ú–∞–ø–ø–∏–Ω–≥ –∫–æ–ª–æ–Ω–æ–∫
            column_mapping = {
                'open_price': 'open',
                'high_price': 'high',
                'low_price': 'low',
                'close_price': 'close',
            }
            
            for old_col, new_col in column_mapping.items():
                if old_col in df.columns and new_col not in df.columns:
                    df[new_col] = df[old_col]
            
            df = df[['timestamp', 'open', 'high', 'low', 'close', 'volume']].sort_values('timestamp').reset_index(drop=True)
            
            print(f"   ‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(df)} —Å–≤–µ—á–µ–π")
            print(f"   –ü–µ—Ä–∏–æ–¥: {df['timestamp'].iloc[0]} ‚Üí {df['timestamp'].iloc[-1]}")
            print(f"   –¶–µ–Ω–∞: ${df['close'].iloc[0]:.2f} ‚Üí ${df['close'].iloc[-1]:.2f}")
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –±—ç–∫—Ç–µ—Å—Ç
            print(f"\nüèÉ –ó–∞–ø—É—Å–∫ BacktestEngine...")
            
            engine = BacktestEngine(
                initial_capital=10_000.0,
                commission=0.055 / 100,  # Bybit 0.055%
                slippage_pct=0.05
            )
            
            results = engine.run(df, strategy_config)
            
            # –í—ã–≤–æ–¥–∏–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            print(f"\nüìä –†–ï–ó–£–õ–¨–¢–ê–¢–´ –ë–≠–ö–¢–ï–°–¢–ê:")
            print(f"   {'='*60}")
            print(f"   üí∞ –§–∏–Ω–∞–ª—å–Ω—ã–π –∫–∞–ø–∏—Ç–∞–ª: ${results['final_capital']:,.2f}")
            print(f"   üìà –î–æ—Ö–æ–¥–Ω–æ—Å—Ç—å: {results['total_return']*100:.2f}%")
            print(f"   üìâ Max Drawdown: {results['max_drawdown']*100:.2f}%")
            print(f"   üìä –í—Å–µ–≥–æ —Å–¥–µ–ª–æ–∫: {results['total_trades']}")
            print(f"   ‚úÖ Win Rate: {results['win_rate']*100:.1f}%")
            print(f"   üéØ Profit Factor: {results['profit_factor']:.2f}")
            print(f"   üìä Sharpe Ratio: {results['sharpe_ratio']:.2f}")
            print(f"   {'='*60}")
            
            self.test_results["backtest_results"] = results
            
            return results
            
        except Exception as e:
            print(f"   ‚ùå –û—à–∏–±–∫–∞ –±—ç–∫—Ç–µ—Å—Ç–∞: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    async def phase7_analyze_results(self, results: Dict):
        """–§–ê–ó–ê 7: AI-–∞–Ω–∞–ª–∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —á–µ—Ä–µ–∑ Perplexity."""
        print("\n" + "="*80)
        print("üî¨ –§–ê–ó–ê 7: AI-–ê–ù–ê–õ–ò–ó –†–ï–ó–£–õ–¨–¢–ê–¢–û–í")
        print("="*80)
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
        copilot_query = f"""
        BACKTEST RESULTS ANALYSIS
        
        Strategy: EMA Crossover on BTCUSDT 15m
        Period: 3 months
        
        RESULTS:
        - Total Return: {results['total_return']*100:.2f}%
        - Max Drawdown: {results['max_drawdown']*100:.2f}%
        - Total Trades: {results['total_trades']}
        - Win Rate: {results['win_rate']*100:.1f}%
        - Profit Factor: {results['profit_factor']:.2f}
        - Sharpe Ratio: {results['sharpe_ratio']:.2f}
        - Sortino Ratio: {results['sortino_ratio']:.2f}
        - Final Capital: ${results['final_capital']:,.2f}
        
        QUESTIONS:
        1. Is this performance acceptable for a crypto trading strategy?
        2. What are the main weaknesses based on these metrics?
        3. Which parameter should we optimize first?
        4. Should we add additional filters or indicators?
        5. Is the Sharpe ratio good enough for live trading?
        
        Provide detailed analysis and 3 specific recommendations for improvement.
        """
        
        print("\nü§ñ Copilot ‚Üí Perplexity:")
        print(f"   Sending backtest results for analysis...")
        
        result = await self.call_perplexity(copilot_query, model="sonar-pro")
        
        if result["success"]:
            answer = result["answer"]
            print(f"\nüîÆ Perplexity AI Analysis:")
            print(f"{answer}")
            
            self.log_dialogue("Copilot", copilot_query, answer)
            self.test_results["phase7_ai_analysis"] = answer
            
            return answer
        else:
            print(f"   ‚ùå Error: {result['error']}")
            return None
    
    async def phase8_risk_optimization(self):
        """–§–ê–ó–ê 8: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ä–∏—Å–∫-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç–∞."""
        print("\n" + "="*80)
        print("üíº –§–ê–ó–ê 8: –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø –†–ò–°–ö-–ú–ï–ù–ï–î–ñ–ú–ï–ù–¢–ê")
        print("="*80)
        
        copilot_query = """
        CONTEXT: Crypto trading strategy with current parameters
        - Initial Capital: $10,000
        - Current Risk per Trade: 2%
        - Max Positions: 1
        - Current Stop Loss: 1.5%
        - Current Take Profit: 3.0%
        
        QUESTIONS:
        1. Is 2% risk per trade too aggressive for crypto?
        2. Should we use Kelly Criterion for position sizing?
        3. What's the optimal Take Profit / Stop Loss ratio for 15m crypto?
        4. Should we implement trailing stop?
        5. How many concurrent positions are safe?
        
        Provide specific numeric recommendations for risk management optimization.
        """
        
        print("\nü§ñ Copilot ‚Üí Perplexity:")
        print(f"   Requesting risk management advice...")
        
        result = await self.call_perplexity(copilot_query, model="sonar-pro")
        
        if result["success"]:
            answer = result["answer"]
            print(f"\nüîÆ Perplexity Risk Management Advice:")
            print(f"{answer}")
            
            self.log_dialogue("Copilot", copilot_query, answer)
            self.test_results["phase8_risk_optimization"] = answer
            
            # Copilot —Å–æ–∑–¥–∞—ë—Ç –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
            optimized_config = {
                "risk_per_trade_pct": 1.5,  # Reduced from 2%
                "take_profit_pct": 4.0,     # Increased
                "stop_loss_pct": 1.5,       # Keep
                "trailing_stop_pct": 0.5,   # Added
                "max_positions": 2,         # Increased
                "use_kelly": False          # Too aggressive for crypto
            }
            
            print(f"\nüéØ Copilot Optimized Risk Config:")
            print(json.dumps(optimized_config, indent=2))
            
            self.test_results["optimized_risk_config"] = optimized_config
            
            return optimized_config
        else:
            print(f"   ‚ùå Error: {result['error']}")
            return None
    
    async def run_full_workflow(self):
        """–ó–∞–ø—É—Å–∫ –ø–æ–ª–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."""
        print("\n" + "üåü"*40)
        print("üöÄ –†–ï–ê–õ–¨–ù–´–ô AI WORKFLOW: COPILOT ‚Üî PERPLEXITY MCP –î–ò–ê–õ–û–ì")
        print("üåü"*40)
        print(f"\n–î–∞—Ç–∞: {self.current_date.strftime('%Y-%m-%d')}")
        print(f"–ü–µ—Ä–∏–æ–¥ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è: {self.test_period_start.strftime('%Y-%m-%d')} - {self.current_date.strftime('%Y-%m-%d')}")
        print(f"\n–õ–û–ó–£–ù–ì: MCP —Å–µ—Ä–≤–µ—Ä–∞ Copilot ‚Üî Perplexity - –Ω–∞—à–µ –±—É–¥—É—â–µ–µ –∏ –Ω–∞—Å—Ç–æ—è—â–µ–µ!")
        
        try:
            # –§–∞–∑–∞ 1: –ê–Ω–∞–ª–∏–∑ –ø—Ä–æ–µ–∫—Ç–∞
            await self.phase1_analyze_project()
            await asyncio.sleep(2)
            
            # –§–∞–∑–∞ 2: –í—ã–±–æ—Ä –ø–∞—Ä—ã
            symbol = await self.phase2_select_trading_pair()
            await asyncio.sleep(2)
            
            # –§–∞–∑–∞ 3: API –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
            await self.phase3_check_api_limits()
            await asyncio.sleep(2)
            
            # –§–∞–∑–∞ 4: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
            strategy_config = await self.phase4_generate_strategy()
            await asyncio.sleep(2)
            
            # –§–∞–∑–∞ 5: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
            parameter_matrix = await self.phase5_optimize_parameters()
            await asyncio.sleep(2)
            
            # –§–∞–∑–∞ 6: –ó–∞–ø—É—Å–∫ –±—ç–∫—Ç–µ—Å—Ç–∞
            results = await self.phase6_run_backtest(symbol, strategy_config)
            
            if results:
                await asyncio.sleep(2)
                
                # –§–∞–∑–∞ 7: AI-–∞–Ω–∞–ª–∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                await self.phase7_analyze_results(results)
                await asyncio.sleep(2)
                
                # –§–∞–∑–∞ 8: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ä–∏—Å–∫-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç–∞
                await self.phase8_risk_optimization()
            
            # –§–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç—á—ë—Ç
            await self.generate_final_report()
            
        except Exception as e:
            print(f"\n‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
            import traceback
            traceback.print_exc()
    
    async def generate_final_report(self):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –æ—Ç—á—ë—Ç–∞."""
        print("\n" + "="*80)
        print("üìÑ –§–ò–ù–ê–õ–¨–ù–´–ô –û–¢–ß–Å–¢")
        print("="*80)
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ JSON
        report_path = "REAL_AI_WORKFLOW_REPORT.json"
        
        report_data = {
            "test_date": datetime.now().isoformat(),
            "test_period": {
                "start": self.test_period_start.isoformat(),
                "end": self.current_date.isoformat()
            },
            "dialogue_turns": len(self.dialogue_history),
            "results": self.test_results,
            "dialogue_history": self.dialogue_history
        }
        
        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump(report_data, f, indent=2, ensure_ascii=False)
        
        print(f"\n‚úÖ –û—Ç—á—ë—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {report_path}")
        print(f"\nüìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê –î–ò–ê–õ–û–ì–ê:")
        print(f"   –í—Å–µ–≥–æ –æ–±–æ—Ä–æ—Ç–æ–≤ Copilot ‚Üî Perplexity: {len(self.dialogue_history)}")
        print(f"   –§–∞–∑ –∑–∞–≤–µ—Ä—à–µ–Ω–æ: 8/8")
        print(f"   –£—Å–ø–µ—à–Ω–æ: ‚úÖ")
        
        # –°–æ–∑–¥–∞—ë–º markdown –æ—Ç—á—ë—Ç
        await self.generate_markdown_report()
    
    async def generate_markdown_report(self):
        """–°–æ–∑–¥–∞–Ω–∏–µ Markdown –æ—Ç—á—ë—Ç–∞."""
        
        md_content = f"""# üöÄ –†–ï–ê–õ–¨–ù–´–ô AI WORKFLOW: COPILOT ‚Üî PERPLEXITY

**–î–∞—Ç–∞:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}  
**–ü–µ—Ä–∏–æ–¥ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:** {self.test_period_start.strftime('%Y-%m-%d')} - {self.current_date.strftime('%Y-%m-%d')}  
**–°–∏–º–≤–æ–ª:** {self.test_results.get('selected_symbol', 'N/A')}  
**Timeframe:** 15 –º–∏–Ω—É—Ç  

---

## üéØ –õ–û–ó–£–ù–ì –ü–†–û–ï–ö–¢–ê

**MCP —Å–µ—Ä–≤–µ—Ä–∞ Copilot ‚Üî Perplexity - –Ω–∞—à–µ –±—É–¥—É—â–µ–µ –∏ –Ω–∞—Å—Ç–æ—è—â–µ–µ!**

---

## üìä –í–´–ü–û–õ–ù–ï–ù–ù–´–ï –§–ê–ó–´

"""
        
        phases = [
            ("üìã –§–ê–ó–ê 1: –ê–Ω–∞–ª–∏–∑ –ø—Ä–æ–µ–∫—Ç–∞", "phase1_project_analysis"),
            ("üí± –§–ê–ó–ê 2: –í—ã–±–æ—Ä —Ç–æ—Ä–≥–æ–≤–æ–π –ø–∞—Ä—ã", "phase2_pair_selection"),
            ("üîç –§–ê–ó–ê 3: API –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è", "phase3_api_limits"),
            ("üé® –§–ê–ó–ê 4: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏", "phase4_strategy_generation"),
            ("‚öôÔ∏è –§–ê–ó–ê 5: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤", "phase5_ema_research"),
            ("üöÄ –§–ê–ó–ê 6: –ó–∞–ø—É—Å–∫ –±—ç–∫—Ç–µ—Å—Ç–∞", "backtest_results"),
            ("üî¨ –§–ê–ó–ê 7: AI-–∞–Ω–∞–ª–∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤", "phase7_ai_analysis"),
            ("üíº –§–ê–ó–ê 8: –†–∏—Å–∫-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç", "phase8_risk_optimization"),
        ]
        
        for phase_name, result_key in phases:
            md_content += f"\n### {phase_name}\n\n"
            
            if result_key in self.test_results:
                result = self.test_results[result_key]
                
                if isinstance(result, dict):
                    md_content += f"```json\n{json.dumps(result, indent=2)}\n```\n"
                else:
                    # –û–±—Ä–µ–∑–∞–µ–º –¥–ª–∏–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç
                    result_str = str(result)
                    if len(result_str) > 500:
                        result_str = result_str[:500] + "...\n\n[–ü–æ–ª–Ω—ã–π —Ç–µ–∫—Å—Ç –≤ JSON –æ—Ç—á—ë—Ç–µ]"
                    md_content += f"{result_str}\n"
            else:
                md_content += "‚ùå –ù–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ\n"
        
        # –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –±—ç–∫—Ç–µ—Å—Ç–∞
        if "backtest_results" in self.test_results:
            results = self.test_results["backtest_results"]
            md_content += f"""
---

## üìà –†–ï–ó–£–õ–¨–¢–ê–¢–´ –ë–≠–ö–¢–ï–°–¢–ê

| –ú–µ—Ç—Ä–∏–∫–∞ | –ó–Ω–∞—á–µ–Ω–∏–µ |
|---------|----------|
| üí∞ –§–∏–Ω–∞–ª—å–Ω—ã–π –∫–∞–ø–∏—Ç–∞–ª | ${results['final_capital']:,.2f} |
| üìà –î–æ—Ö–æ–¥–Ω–æ—Å—Ç—å | {results['total_return']*100:.2f}% |
| üìâ Max Drawdown | {results['max_drawdown']*100:.2f}% |
| üìä –í—Å–µ–≥–æ —Å–¥–µ–ª–æ–∫ | {results['total_trades']} |
| ‚úÖ Win Rate | {results['win_rate']*100:.1f}% |
| üéØ Profit Factor | {results['profit_factor']:.2f} |
| üìä Sharpe Ratio | {results['sharpe_ratio']:.2f} |
| üìä Sortino Ratio | {results['sortino_ratio']:.2f} |

"""
        
        # –î–∏–∞–ª–æ–≥
        md_content += f"""
---

## üí¨ –ò–°–¢–û–†–ò–Ø –î–ò–ê–õ–û–ì–ê COPILOT ‚Üî PERPLEXITY

**–í—Å–µ–≥–æ –æ–±–æ—Ä–æ—Ç–æ–≤:** {len(self.dialogue_history)}

"""
        
        for i, turn in enumerate(self.dialogue_history, 1):
            md_content += f"""
### –û–±–æ—Ä–æ—Ç {i} ({turn['agent']})

**Timestamp:** {turn['timestamp']}

**–ó–∞–ø—Ä–æ—Å:**
```
{turn['message'][:200]}...
```

**–û—Ç–≤–µ—Ç:**
```
{turn['response']}
```

---
"""
        
        md_content += f"""
## ‚úÖ –ó–ê–ö–õ–Æ–ß–ï–ù–ò–ï

–£—Å–ø–µ—à–Ω–æ –≤—ã–ø–æ–ª–Ω–µ–Ω –ø–æ–ª–Ω—ã–π —Ü–∏–∫–ª —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–æ—Ä–≥–æ–≤–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ —á–µ—Ä–µ–∑ —Ä–µ–∞–ª—å–Ω—ã–π –¥–∏–∞–ª–æ–≥ 
–º–µ–∂–¥—É Copilot –∏ Perplexity MCP —Å–µ—Ä–≤–µ—Ä–∞–º–∏. –í—Å–µ 8 —Ñ–∞–∑ –∑–∞–≤–µ—Ä—à–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ.

**–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:**
- –û–±–æ—Ä–æ—Ç—ã –¥–∏–∞–ª–æ–≥–∞: {len(self.dialogue_history)}
- –§–∞–∑ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ: 8/8
- –†–µ–∞–ª—å–Ω—ã—Ö API –≤—ã–∑–æ–≤–æ–≤: {len([d for d in self.dialogue_history if 'Perplexity' in str(d)])}
- –†–µ–∑—É–ª—å—Ç–∞—Ç: ‚úÖ SUCCESS

**MCP —Å–µ—Ä–≤–µ—Ä–∞ —Ä–∞–±–æ—Ç–∞—é—Ç! AI - —ç—Ç–æ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç—å! üéâ**
"""
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º
        md_path = "REAL_AI_WORKFLOW_REPORT.md"
        with open(md_path, 'w', encoding='utf-8') as f:
            f.write(md_content)
        
        print(f"‚úÖ Markdown –æ—Ç—á—ë—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {md_path}")


async def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è."""
    orchestrator = MCPDialogueOrchestrator()
    await orchestrator.run_full_workflow()


if __name__ == "__main__":
    print("\n" + "üåü"*40)
    print("–ó–ê–ü–£–°–ö –†–ï–ê–õ–¨–ù–û–ì–û AI WORKFLOW")
    print("Copilot ‚Üî Perplexity MCP Dialogue")
    print("üåü"*40 + "\n")
    
    asyncio.run(main())
