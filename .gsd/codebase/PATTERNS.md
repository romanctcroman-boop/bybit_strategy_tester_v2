# Code Patterns & Conventions

> Auto-generated by GSD Bootstrap — 2026-02-18

## Strategy Pattern

All strategies follow this inheritance chain:

```python
BaseStrategy  (backend/backtesting/strategies/base.py)
    └── LibraryStrategy  (backend/services/strategies/base.py)
        ├── ATRBreakoutStrategy
        ├── DonchianBreakoutStrategy
        ├── DCAStrategy
        ├── GridTradingStrategy
        ├── RSIMeanReversionStrategy
        ├── BollingerBandsStrategy
        ├── RSIMomentumStrategy
        ├── StochasticMomentumStrategy
        ├── EMACrossoverStrategy
        ├── MACDTrendStrategy
        └── TripleEMAStrategy
```

**Contract:**

```python
class MyStrategy(BaseStrategy):
    def __init__(self, params: dict):
        super().__init__(params)
        self.required_params = ['period', 'threshold']
        self._validate_params()

    def generate_signals(self, data: pd.DataFrame) -> pd.DataFrame:
        signals = data.copy()
        # Compute indicators using pandas_ta
        # Add 'signal' column: 1=long, -1=short, 0=no action
        return signals
```

**Invariants:**

- `strategy_params` dict carries all configurable parameters
- `required_params` list validated in `__init__`
- Signal values: `{1, -1, 0}` only
- Input DataFrame must have OHLCV columns

## Router Pattern

```python
from fastapi import APIRouter, HTTPException
from loguru import logger

router = APIRouter(prefix="/api/v1/feature", tags=["Feature"])

@router.post("/action")
async def action(request: RequestModel) -> ResponseModel:
    try:
        # Business logic via service layer
        result = await some_service.do_work(request)
        return ResponseModel(...)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Action failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))
```

**Conventions:**

- All routes under `/api/v1/` prefix
- Tags group related endpoints in Swagger
- `loguru.logger` for all logging (NOT stdlib `logging`)
- HTTPException for client-facing errors
- Async endpoints with `asyncio.to_thread()` for blocking DB ops

## Service Pattern

- Services are plain Python classes or module-level functions
- Located in `backend/services/` (52 files across 7 sub-packages)
- Thin service layer delegates to engines/adapters
- No direct database access from routers — go through services

## Adapter Pattern

```python
# Bybit API call — ALWAYS check retCode
response = await adapter.get_historical_klines(symbol, interval, start, end)
if response.get('retCode') != 0:
    raise APIError(response.get('retMsg'))
```

**Conventions:**

- Rate limit: 120 req/min
- Exponential backoff on HTTP 429
- All adapters in `backend/services/adapters/`
- Never call real Bybit API in tests — use mocks

## Database Pattern

```python
# Repository pattern with SQLAlchemy
from backend.database import get_db

# In async endpoints — wrap blocking calls
rows = await asyncio.to_thread(db.query(Model).filter(...).all)
```

**Conventions:**

- Import `DATA_START_DATE` from `backend/config/database_policy.py` (never hardcode)
- SQLite for local dev (no DATABASE_URL needed)
- Alembic for schema migrations (`alembic upgrade head`)

## Test Pattern

```python
# Naming: test_[function]_[scenario]
def test_rsi_with_valid_data(sample_ohlcv):
    """Test RSI calculation produces valid signals."""
    strategy = RSIMomentumStrategy(params={'period': 14})
    result = strategy.generate_signals(sample_ohlcv)
    assert 'signal' in result.columns
    assert result['signal'].isin([1, -1, 0]).all()

# Fixtures in conftest.py
@pytest.fixture
def sample_ohlcv():
    """Standard OHLCV DataFrame for testing."""
    ...

@pytest.fixture
def mock_adapter():
    """Mocked Bybit adapter — never hits real API."""
    ...
```

**Conventions:**

- Coverage: ≥80% overall, ≥95% for `backend/backtesting/engines/`
- Never call real Bybit API in unit tests
- `pytest.ini` config with markers: `slow`, `integration`
- Use `conftest.py` for shared fixtures

## Error Handling Pattern

- **Application errors**: `loguru.logger.error()` + `HTTPException`
- **API errors**: Check `retCode != 0` from Bybit responses
- **Circuit breaker**: `backend/core/circuit_breaker.py` for external services
- **Resilient client**: `backend/core/resilient_client.py` with retries

## Configuration Pattern

- `pyproject.toml` — project metadata, ruff, pytest config
- `backend/config/` — application configuration
- `backend/config/database_policy.py` — data retention constants
- `backend/core/config.py` — core runtime config
- `config/` — external configuration files
- Environment variables for secrets (never hardcode)

## Naming Conventions

| Entity    | Convention                       | Example                    |
| --------- | -------------------------------- | -------------------------- |
| Files     | snake_case                       | `fallback_engine_v4.py`    |
| Classes   | PascalCase + suffix              | `RSIMomentumStrategy`      |
| Functions | snake_case                       | `generate_signals()`       |
| Constants | UPPER_SNAKE_CASE                 | `DATA_START_DATE`          |
| Routes    | `/api/v1/{resource}/{action}`    | `/api/v1/backtest/run`     |
| Tests     | `test_{function}_{scenario}`     | `test_rsi_with_valid_data` |
| Routers   | `{feature}.py` in `api/routers/` | `backtest.py`              |
